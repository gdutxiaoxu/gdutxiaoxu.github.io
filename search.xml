<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字节跳动抖音 Android 校招面经，已拿 offer</title>
    <url>/2021/04/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%8A%96%E9%9F%B3Android-%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%8C%E5%B7%B2%E6%8B%BF-offer/</url>
    <content><![CDATA[<blockquote>
<p>作者：可爱猫图鉴赏员<br>链接：<a href="https://www.nowcoder.com/discuss/489732?type=0&amp;order=0&amp;pos=2992&amp;page=1&amp;channel=-2&amp;source_id=discuss_tag">https://www.nowcoder.com/discuss/489732?type=0&amp;order=0&amp;pos=2992&amp;page=1&amp;channel=-2&amp;source_id=discuss_tag</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天，在逛博客的时候，看到一篇不错的校招生面经，转载过来，大家可以看一下。</p>
<p>作者背景大概是这样的：</p>
<blockquote>
<p>2021应届秋招</p>
<p>个人背景 ：本科，软件工程专业，有一段暑期实习（美团）和几个安卓项目</p>
<p>提前批投递了字节头条的客户端，挂在了终面，正式批又投了抖音的客户端，简历通过后约了大概一周后面试</p>
</blockquote>
<h2 id="一面（-45min）"><a href="#一面（-45min）" class="headerlink" title="一面（~45min）"></a>一面（~45min）</h2><ol>
<li>介绍项目，讲述一下实习的工作内容和感想（~10min）</li>
<li>什么是内存泄漏，Android里有哪些内存泄漏的场景，原因是什么</li>
<li>JVM的GC过程，GC的算法都有哪些</li>
<li>进程和线程的概念，Android里怎样实现多线程？（Thread  Handler  AsyncTask  IntentService等等）</li>
<li>Handler的原理和使用</li>
<li>Handler是怎么和线程绑定的（Looper），为什么Looper.loop()要设计成死循环</li>
<li>Java的几种内部类，区别是什么</li>
<li>Activity的生命周期和启动模式</li>
<li>写题：二叉树的右视图（层序遍历即可）</li>
</ol>
<p>一面比较短，问的问题也比较基础，大概30分钟后开始二面</p>
<h2 id="二面（-1h30min）"><a href="#二面（-1h30min）" class="headerlink" title="二面（~1h30min）"></a>二面（~1h30min）</h2><ol>
<li>自我介绍</li>
<li>介绍项目，为什么要自学安卓（~5min）</li>
<li>Android如何实现多进程，应用场景是什么（答的不好）</li>
<li>Android的IPC机制（Binder）是否了解（答的也不好）</li>
<li>如何用两个队列（FIFO）实现栈（FILO）</li>
<li>HashMap和HashTable区别，HashMap原理和实现，hash()的算法</li>
<li>如果自己设计hash算***怎么设计，为什么（答的素数取余）</li>
<li>String的hashCode()和Object的hashCode()</li>
<li>虚拟内存和物理内存的概念和关系，内存分页的调度算法</li>
<li>怎么实现LRU缓存（参考leetcode T146）</li>
<li>可以自己写一个java.lang.Object类吗，系统会加载哪一个</li>
<li>Java里泛型的实现</li>
<li>了解常见排序算法吗，手写一下快排</li>
<li>Java里加锁的方式，synchornized关键字的原理，悲观锁和乐观锁都有哪些实现</li>
<li>死锁的条件和解决方法，讲讲银行家算法</li>
<li>TCP的三次握手四次挥手，为什么要四次挥手</li>
<li>TCP的流量控制算法（滑动窗口），拥塞控制算法</li>
<li>怎么解决用户高频点击打开新Activity导致的多实例问题（Activity启动模式）</li>
<li>怎么判断两个无环单链表是否相交</li>
<li>写题：leetcode 445</li>
<li>反问</li>
</ol>
<p>二面问题量非常的大，集中在Java/OS/算法，但并没有特别难以回答的问题，认真准备的话大部分都能答出来。面试官也非常友好，给了很多引导和提示。</p>
<p>因为三面面试官的时间问题，约了两天后的三面</p>
<h2 id="三面（-45min）"><a href="#三面（-45min）" class="headerlink" title="三面（~45min）"></a>三面（~45min）</h2><ol>
<li>自我介绍</li>
<li>介绍一下实习做的工作，是自己完成的吗，遇到什么困难，成果怎么样</li>
<li>RecyclerView怎么实现的item缓存，跟ListView有什么区别（因为项目用到了所以被问了）</li>
<li>写题：1233. 删除子文件夹</li>
<li>设计题：微信的联系人列表功能<ul>
<li>（1）设计添加联系人的API（从可能的方式，数据形式，接口参数方面回答）</li>
<li>（2）怎么实现联系人列表的UI（答的RecyclerView）</li>
<li>（3）怎么实现A-Z首字母的快速定位功能</li>
</ul>
</li>
<li>是自学的Android吗，为什么选择这个方向，有没有什么经验给同样想自学的学弟学妹</li>
<li>是哪里人，为什么想到上海来就业</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>校招生面试，尤其是大厂，说到底，一般主要问几点</p>
<ol>
<li>基础，包括 Java 基础，计算机基础，Android 的一些基础，Handler，线程池原理</li>
<li>项目或者实习经历，做了什么，难点是什么，有什么收获</li>
<li>算法，这个可以多刷刷剑指 offer，leetcode 或者牛客。</li>
</ol>
<p>如果想进入大厂的，建议大二，大三的时候，可以着手开始准备。</p>
<ol>
<li>在大三的时候，尽量争取能够进入中大厂实习，这时候的竞争相对校招会小很多，表现不错的，基本可以直接留下来转正。</li>
<li>投递简历的时候，尽量找师兄师姐内推。简历还可以的，基本可以直接面试，免去了笔试。如果你身边没有熟人的话，我也可以帮你内推哦。</li>
</ol>
<p>最后，送给大家一些我大学时候整理的资料。</p>
<ol>
<li>公众号回复 <strong>Java</strong>，领取马士兵 java 学习视频</li>
<li>公众号回复 <strong>黑马</strong>，领取黑马 52 期不加密视频</li>
<li>公众号回复  <strong>剑指 offer</strong>，领取剑指 offer 题解</li>
</ol>
<h2 id="找到我"><a href="#找到我" class="headerlink" title="找到我"></a>找到我</h2><p>我是站在巨人的肩膀上成长起来的，同样，我也希望成为你们的巨人。觉得不错的话可以关注一下我的微信公众号程序员徐公，在此感谢各位大佬们。主要分享</p>
<p>1.<strong>Android 开发相关知识</strong>：包括 java，kotlin， Android 技术。<br>2.<strong>面试相关分享</strong>：包括常见的面试题目，大厂面试真题、面试经验套路分享。<br>3.<strong>算法相关学习笔记</strong>：比如怎么学习算法，leetcode 常见算法总结，跟大家一起学习算法。<br>4.<strong>时事点评</strong>：主要是关于互联网的，比如小米高管屌丝事件，拼多多女员工猝死事件等</p>
<p>希望我们可以成为朋友，成长路上的忠实伙伴！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/32330cdfb6f0dfc77e5e0eccfc2d7dde.png"></p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（七） - JetPack App Startup 使用及源码浅析</title>
    <url>/2021/04/18/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%83%EF%BC%89-JetPack-App-Startup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>本文收录于 <a href="https://github.com/gdutxiaoxu/AndroidGuide">https://github.com/gdutxiaoxu/AndroidGuide</a> 「Android学习+面试指南」一份涵盖大部分 Android 程序员所需要掌握的核心知识。准备 Android 面试，首选 AndroidGuide！<strong>微信公众号：程序员徐公</strong></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子，写了几篇 Android 启动优化的文章，主要是从两个方面论述的。</p>
<ol>
<li>Application 多线程异步加载，以及怎么解决多线程任务依赖的问题</li>
<li>首页布局优化，从常规的布局嵌套优化到渐进式加载，再到异步加载。</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<p>发布在掘金之后，几篇文章都被推荐上了掘金首页，深得大家的喜欢，阅读量也挺不错的。</p>
<p>有不少公众号粉丝在后台问我 <strong>JetPack App Startup</strong> 是什么，跟我开源的 <a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a> 有什么区别？</p>
<p>今天，就让我们来聊一聊 JetPack App Startup。</p>
<p>目录大概是这样的</p>
<blockquote>
<p>1 什么是 JetPack App Startup <br/><br>2 JetPack App Startup 能解决什么问题 <br/><br>3 JetPack App Startup 基本使用 <br/><br>4 JetPack App Startup 进阶使用 <br/><br>5 JetPack App Startup 源码浅析 <br/><br>6 小结</p>
</blockquote>
<h2 id="什么是-JetPack-App-Startup"><a href="#什么是-JetPack-App-Startup" class="headerlink" title="什么是 JetPack App Startup"></a>什么是 JetPack App Startup</h2><p>我们先来看一下官方的解释，<a href="https://developer.android.com/topic/libraries/app-startup">官方地址</a>：<a href="https://developer.android.com/topic/libraries/app-startup">https://developer.android.com/topic/libraries/app-startup</a></p>
<blockquote>
<p>The App Startup library provides a straightforward, performant way to initialize components at application startup. Both library developers and app developers can use App Startup to streamline startup sequences and explicitly set the order of initialization.</p>
</blockquote>
<blockquote>
<p>Instead of defining separate content providers for each component you need to initialize, App Startup allows you to define component initializers that share a single content provider. This can significantly improve app startup time.</p>
</blockquote>
<p>翻译过来就是：</p>
<ol>
<li>App Startup 这个库提供了一个组件，可以在应用程序启动的时候初始化。</li>
<li>开发人员可以使用这个组件精简启动序列和显式地设置初始化的顺序。 　</li>
<li>我们不需要为每个组件定义单独的 ContentProvider,App Startup 允许您定义的所有组件化共享一个内容提供者。这样可以<strong>极大地减少高应用程序的启动时间</strong></li>
</ol>
<h2 id="JetPack-App-Startup-能解决什么问题"><a href="#JetPack-App-Startup-能解决什么问题" class="headerlink" title="JetPack App Startup 能解决什么问题"></a>JetPack App Startup 能解决什么问题</h2><p><strong>听了上面的介绍，是不是还有点懵？</strong></p>
<p>App Startup 能减少高应用程序的启动时间，它是怎么做到的？</p>
<p>做过 Android 启动优化的，可能都知道，Android 的启动流程是这样的。</p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210417133422.png"></p>
<p>从 <code>Application#attachBaseContext</code> 到 <code>ContentProvider#onCreate</code>，到 <code>Application#onCreate</code> 再到 <code>MainActivity#onCreate</code>。</p>
<p>而 <strong>App Startup</strong> 设计的初衷，正是为了收拢 ContentProvider。有不少第三方的 SDk，为了使用者不必手动调用 <code>SDK#init</code> 方法，使用了 ContentProvider 这一个骚操作。</p>
<p>在 AndroidManifest 里面注册了自己的 xxSDkProvider，然后在 xxSDkProvider 的 onCreate 方面里面进行初始化，确实调用者不需要自己初始化了，可却增加了启动耗时，如果要作优化，还得自己剔除 ContentProvider 的初始化，值不值得，我是感觉没必要，这操作是<strong>真的骚</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;application ...&gt;</span><br><span class="line"></span><br><span class="line">    &lt;provider</span><br><span class="line">        android:name&#x3D;&quot;.xxSDkProvider&quot;</span><br><span class="line">        android:authorities&#x3D;&quot;$&#123;applicationId&#125;.xxSDkProvider&quot;</span><br><span class="line">        android:exported&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class XXSDKProvider : ContentProvider() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(): Boolean &#123;</span><br><span class="line">        Log.d(TAG, &quot;XXSDKProvider create()&quot;)</span><br><span class="line">        XXSDK.init()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p><strong>同时，这里给做启动优化的同学提供了一种思路。打开你的 Apk，看一下 AndroidManiest 里面有多少 provider，看一下是否有这样的骚操作。如果有，改一下，说不定启动优化，一下子就减少了 100 多 毫秒。</strong></p>
<p>接下来，我们来看一下 AppStartUp 怎么使用</p>
<h2 id="AppStartUp-基本使用"><a href="#AppStartUp-基本使用" class="headerlink" title="AppStartUp 基本使用"></a>AppStartUp 基本使用</h2><p>简单来说，分为三步</p>
<ol>
<li>gradle 文件引入App Startup 库。</li>
<li>自定义一个用于初始化的 Initializer。</li>
<li>将自定义 Initializer 配置到 AndroidManifest.xml 当中。</li>
</ol>
<p><strong>第一步，在 build.gradle 文件添加依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;androidx.startup:startup-runtime:1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：自定义实现 Initializer 类</strong></p>
<p>主要有两个方法</p>
<ol>
<li><code>T create(@NonNull Context context)</code> 初始化一个组件，返回给 Application</li>
<li><code>List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies()</code> 当前的 Initializer 依赖于哪些 Initializers，通过这个可以确定先后启动的顺序</li>
</ol>
<p>我们以官方的例子来讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Initializes WorkManager.</span><br><span class="line">class WorkManagerInitializer : Initializer&lt;WorkManager&gt; &#123;</span><br><span class="line">    override fun create(context: Context): WorkManager &#123;</span><br><span class="line">        val configuration &#x3D; Configuration.Builder().build()</span><br><span class="line">        WorkManager.initialize(context, configuration)</span><br><span class="line">        return WorkManager.getInstance(context)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; No dependencies on other libraries.</span><br><span class="line">        return emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkManagerInitializer 返回一个 WorkManager，它不需要依赖于其他的 Initializer，直接返回 emptyList() 即可。</p>
<p>如果需要依赖其他的 Initializer，重写 dependencies 方法，返回即可。如下面的 ExampleLoggerInitializer 依赖于 WorkManagerInitializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Initializes ExampleLogger.</span><br><span class="line">class ExampleLoggerInitializer : Initializer&lt;ExampleLogger&gt; &#123;</span><br><span class="line">    override fun create(context: Context): ExampleLogger &#123;</span><br><span class="line">        &#x2F;&#x2F; WorkManager.getInstance() is non-null only after</span><br><span class="line">        &#x2F;&#x2F; WorkManager is initialized.</span><br><span class="line">        return ExampleLogger(WorkManager.getInstance(context))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; Defines a dependency on WorkManagerInitializer so it can be</span><br><span class="line">        &#x2F;&#x2F; initialized after WorkManager is initialized.</span><br><span class="line">        return listOf(WorkManagerInitializer::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  ExampleLogger(val workManager: WorkManager)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：在 AndroidManifest 里面配置自定义的 InitializationProvider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">    &lt;!-- This entry makes ExampleLoggerInitializer discoverable. --&gt;</span><br><span class="line">    &lt;meta-data  android:name&#x3D;&quot;com.xj.anchortask.appstartup.ExampleLoggerInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure>

<p>它是有固定格式的，配置者只需要配置 meta-data 中的 name 即可。<br><code>android:name=&quot;com.xj.anchortask.appstartup.ExampleLoggerInitializer&quot;</code> 这里的 name 是我们自定义的 Initializer 全路径。</p>
<p>程序运行跑起来，可以看到以下输出结果，符合我们的预期</p>
<blockquote>
<p>2021-04-17 17:48:42.049 28059-28059/com.xj.anchortask I/AnchorTaskApplication: attachBaseContext:<br>2021-04-17 17:48:42.077 28059-28059/com.xj.anchortask I/AnchorTaskApplication: create: WorkManagerInitializer init<br>2021-04-17 17:48:42.077 28059-28059/com.xj.anchortask I/AnchorTaskApplication: create: ExampleLoggerInitializer init<br>2021-04-17 17:48:42.084 28059-28059/com.xj.anchortask I/AnchorTaskApplication: onCreate: </p>
</blockquote>
<h2 id="AppStartUp-进阶使用"><a href="#AppStartUp-进阶使用" class="headerlink" title="AppStartUp 进阶使用"></a>AppStartUp 进阶使用</h2><h3 id="手动初始化"><a href="#手动初始化" class="headerlink" title="手动初始化"></a>手动初始化</h3><p>上面我们讲解了 AppStartUp 的基本使用步骤，如果我们不像在 Application onCreate 之前执行我们的 ExampleLoggerInitializer，要怎么使用呢？</p>
<p>其实很简单，</p>
<ol>
<li>第一步，在 AndroidManifest InitializationProvider 中移除 移除 <code>&lt;meta-data</code> 标签</li>
<li>在代码中调用 AppInitializer initializeComponent 方法初始化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context).initializeComponent(ExampleLoggerInitializer::class.java)</span><br></pre></td></tr></table></figure>

<h2 id="App-start-up-源码分析"><a href="#App-start-up-源码分析" class="headerlink" title="App start up 源码分析"></a>App start up 源码分析</h2><p>我们首先来看一下他的结构，只有简单的几个类</p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210417180733.png"></p>
<p><strong>Initializer</strong> 这个接口就没有必要说了，很简单，只有两个方法。</p>
<p><strong>InitializationProvider</strong> 继承了 ContentProvider，借助了 ContentProvider 会在 Application onCreate 之前执行的特点。来执行一些初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class InitializationProvider extends ContentProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onCreate() &#123;</span><br><span class="line">        Context context &#x3D; getContext();</span><br><span class="line">        if (context !&#x3D; null) &#123;</span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StartupException(&quot;Context cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ----</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在 onCreate 方法中调用  AppInitializer discoverAndInitialize 方法进行初始化。</p>
<ol>
<li>找到 AndroidManifest InitializationProvider 下的 meta 便签</li>
<li>判断 meta 便签下 value 的值是不是 androidx.startup</li>
<li>判断是不是实现 Initializer 接口，是的话，执行 doInitialize 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void discoverAndInitialize() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.beginSection(SECTION_NAME);</span><br><span class="line">        ComponentName provider &#x3D; new ComponentName(mContext.getPackageName(),</span><br><span class="line">                InitializationProvider.class.getName());</span><br><span class="line">        ProviderInfo providerInfo &#x3D; mContext.getPackageManager()</span><br><span class="line">                .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">        Bundle metadata &#x3D; providerInfo.metaData;</span><br><span class="line">        String startup &#x3D; mContext.getString(R.string.androidx_startup);</span><br><span class="line">        &#x2F;&#x2F; 找到 metadata 标签</span><br><span class="line">        if (metadata !&#x3D; null) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; initializing &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">            Set&lt;String&gt; keys &#x3D; metadata.keySet();</span><br><span class="line">            for (String key : keys) &#123;</span><br><span class="line">                String value &#x3D; metadata.getString(key, null);</span><br><span class="line">                &#x2F;&#x2F; 判断 value 的值是不是 androidx.startup</span><br><span class="line">                &#x2F;&#x2F; 判断是不是实现了 Initializer 接口，是的话，反射初始化</span><br><span class="line">                if (startup.equals(value)) &#123;</span><br><span class="line">                    Class&lt;?&gt; clazz &#x3D; Class.forName(key);</span><br><span class="line">                    if (Initializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Class&lt;? extends Initializer&lt;?&gt;&gt; component &#x3D;</span><br><span class="line">                                (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz;</span><br><span class="line">                        mDiscovered.add(component);</span><br><span class="line">                        if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                            StartupLogger.i(String.format(&quot;Discovered %s&quot;, key));</span><br><span class="line">                        &#125;</span><br><span class="line">                        doInitialize(component, initializing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException | ClassNotFoundException exception) &#123;</span><br><span class="line">        throw new StartupException(exception);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>doInitialize 方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T doInitialize(</span><br><span class="line">        @NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span><br><span class="line">        @NonNull Set&lt;Class&lt;?&gt;&gt; initializing) &#123;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        boolean isTracingEnabled &#x3D; Trace.isEnabled();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isTracingEnabled) &#123;</span><br><span class="line">                &#x2F;&#x2F; Use the simpleName here because section names would get too big otherwise.</span><br><span class="line">                Trace.beginSection(component.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            if (initializing.contains(component)) &#123;</span><br><span class="line">                String message &#x3D; String.format(</span><br><span class="line">                        &quot;Cannot initialize %s. Cycle detected.&quot;, component.getName()</span><br><span class="line">                );</span><br><span class="line">                throw new IllegalStateException(message);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result;</span><br><span class="line">            if (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                initializing.add(component);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object instance &#x3D; component.getDeclaredConstructor().newInstance();</span><br><span class="line">                    Initializer&lt;?&gt; initializer &#x3D; (Initializer&lt;?&gt;) instance;</span><br><span class="line">                    List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies &#x3D;</span><br><span class="line">                            initializer.dependencies();</span><br><span class="line"></span><br><span class="line">                    if (!dependencies.isEmpty()) &#123;</span><br><span class="line">                        for (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                            if (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                                doInitialize(clazz, initializing);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initializing %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result &#x3D; initializer.create(mContext);</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initialized %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    initializing.remove(component);</span><br><span class="line">                    mInitialized.put(component, result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    throw new StartupException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result &#x3D; mInitialized.get(component);</span><br><span class="line">            &#125;</span><br><span class="line">            return (T) result;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到在执行初始化的时候，先判断了是否有依赖项，有的话先执行依赖项的初始化</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>App start up，我觉得他的设计初衷应该是为了收拢 ContentProvider，实际上对启动优化的帮助不是很大。</li>
<li>如果你的项目都是同步初始化的话，并且使用到了多个ContentProvider，App Startup可能有一定的优化空间，毕竟统一到了一个ContentProvider中，同时支持了简单的顺序依赖。</li>
<li>ContentProvider 初始化的这个思想，目前有挺多 SDK 这么做的，像 FaceBook 广告 SDK，友盟 SDk 等。我们在启动优化的时候，是不是可以去掉相应的 ContentProvider，减少创建 Provider 的时间</li>
<li>实际项目中 启动优化，大多数啊都会使用多线程异步加载，这时候 App start up 就显得很鸡肋了，没用</li>
</ul>
<p><strong>参考博客：</strong><br><a href="https://blog.csdn.net/guolin_blog/article/details/108026357">Jetpack新成员，App Startup一篇就懂</a></p>
<blockquote>
<p>本文收录于 <a href="https://github.com/gdutxiaoxu/AndroidGuide">https://github.com/gdutxiaoxu/AndroidGuide</a> 「Android学习+面试指南」一份涵盖大部分 Android 程序员所需要掌握的核心知识。准备 Android 面试，首选 AndroidGuide！微信公众号：<strong>程序员徐公</strong></p>
</blockquote>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%20(new).png"></p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 Android 如何自学，Android 学习路线分享，一位 5 年中大厂老哥跟你聊聊</title>
    <url>/2021/04/18/2021-Android-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%EF%BC%8CAndroid-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%88%86%E4%BA%AB%EF%BC%8C%E4%B8%80%E4%BD%8D-5-%E5%B9%B4%E4%B8%AD%E5%A4%A7%E5%8E%82%E8%80%81%E5%93%A5%E8%B7%9F%E4%BD%A0%E8%81%8A%E8%81%8A/</url>
    <content><![CDATA[<p>光阴似箭，日月如梭，时间真的过得飞快。<br>加上实习，从事 Android 开发，差不多有 5 年了，在这里，我分享一下我的经验，在 Android 的学习路上，我是站在巨人的肩膀上成长起来的。</p>
<p>大概分为三个部分</p>
<blockquote>
<p>一、Android 职业规划<br>二、Android 学习路线<br>三、如何进入大厂<br>三、Android 学习资料分享</p>
</blockquote>
<h1 id="Android-成长生涯"><a href="#Android-成长生涯" class="headerlink" title="Android 成长生涯"></a>Android 成长生涯</h1><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E6%88%90%E9%95%BF%E9%98%B6%E6%A2%AF.jpeg"></p>
<h2 id="1-3-年"><a href="#1-3-年" class="headerlink" title="1-3 年"></a>1-3 年</h2><p>前 3 年，我觉得是我们成长最快的时候。</p>
<p>尤其是刚开始工作的一年，刚开始接触项目，我们会接触到很多新知识，比较网络框架的封装，Android 架构 MVVN，MVC，MVP 等。</p>
<p><strong>这段时期是我们进步最快的时候，因为很多东西我们都不会，我们会逼着自己去学习。</strong></p>
<p>第二到第三年，也是我们成长的关键时期。这时候，在项目中，我们基本会自己独立负责需求。这时候的我们，大多数基本功能都可以自己独立实现。需要注意的是<strong>代码风格和代码思维的培养</strong>。</p>
<p><strong>代码风格</strong>，指的是编码习惯。比如方法命名，方法的合理拆分，适当添加注解，注释。听起来可能会很虚，但是千万别小看这些细节。反正我在组里见过一些工作五六年的，代码一坨一坨的，像 si 一样。</p>
<p><strong>代码思维</strong>，有点类似于人的视野和思考方式吧。很多时候，实现某个效果，有很多种方案。我们为了应付需求，可能会随便选择一种，没有去了解其他方案。而这恰恰错过了我们成长的最佳时期。</p>
<p><strong>记住，永远别给自己设限，或许在编程的路上会遇到很多问题，但是总会有解决方法的，而这取决你的态度。</strong></p>
<h2 id="3-5-年"><a href="#3-5-年" class="headerlink" title="3-5 年"></a>3-5 年</h2><p>这个时期，不出意外，我们基本都是高级工程师了。这时候大多数人会遇到瓶颈，<strong>不知道学些什么好。好像什么都会，但是不够深入</strong>。我也遇到这样的情况，现在正在深挖。</p>
<p>这方面我暂时也给不了太多意见，只能说，选择一个方向，静下心来，去学习，相信能收获到我们想要的。</p>
<p>学习方向有很多，比如 Android 性能优化（启动，卡顿， Crash 治理）， JNI C++，gradle 打包，编译速度，音视频等等，这些都是大的方向。</p>
<p><strong>最近写的一些文章，自我感觉还行，有兴趣的可以看看。</strong></p>
<p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<h2 id="5-年之后"><a href="#5-年之后" class="headerlink" title="5 年之后"></a>5 年之后</h2><p><a href="https://mp.weixin.qq.com/s/xCFa2pHxhFGdn51dWoDdQg">技术人的四大出路，你适合哪一个</a></p>
<p>大多数技术人，一般会有以下方向。</p>
<ul>
<li>第一：成为技术大神，比如架构师，及技术专家等。</li>
<li>第二：技术管理，比如技术总监等。</li>
<li>第三：技术转型，如转项目管理，产品等，你牛逼的话，说不定下一个张小龙就是你（哥们，想多了，那有这么容易）。</li>
<li>第四：自主创业，做自媒体等</li>
</ul>
<p>我目前来说，可能会选择第一条路吧，成为一名技术专家。</p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210410172556.png"></p>
<p><strong>在技术的路上，或许会很累，很难，可那又怎样呢</strong></p>
<p>35 岁中年职业危机，很多职业都有，不仅仅局限于程序员。</p>
<p>从本质上面说，自身竞争力下降占很大原因。毕竟，优秀的人才从来不缺少机会。</p>
<p><strong>既然选择了，便只顾风雨兼程。</strong></p>
<p>为了未来有更多的选择，从现在开始，朝着自己的目标努力奋斗吧，书写属于自己的人生。</p>
<hr>
<h1 id="Android-学习路线"><a href="#Android-学习路线" class="headerlink" title="Android 学习路线"></a>Android 学习路线</h1><p><strong>下面，说一下 Android 的学习路线，不会很具体，主要是从大的方面来说，感兴趣的可以看一下。</strong></p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210410174904.png"></p>
<h2 id="搭建基本的开发环境，敲下-Hello-world"><a href="#搭建基本的开发环境，敲下-Hello-world" class="headerlink" title="搭建基本的开发环境，敲下 Hello world"></a>搭建基本的开发环境，敲下 Hello world</h2><p>首先你配置好电脑开发环境。首先需要配置 Java，AndroidStudio 的开发环境。</p>
<p>现在的 IDE 对比几年前的，真的是方便多了，可以自动帮我们配置好环境变量。还记得当年刚开始配环境的时候，<strong>折腾了两三天。在配置变量的时候，有时候英文的逗号输成中文的，在 cmd 窗口输入 Java，一直提醒没有这个命令，一把鼻涕一行泪</strong>。</p>
<p><strong>依稀还记得，当配置完环境之后，敲下第一段程序 <em>Hello world</em> 时的那份喜悦。</strong></p>
<h2 id="掌握基本的语法和常用的数据结构"><a href="#掌握基本的语法和常用的数据结构" class="headerlink" title="掌握基本的语法和常用的数据结构"></a>掌握基本的语法和常用的数据结构</h2><p>第一：你要先掌握基本的语法，可以从一些书籍开始学起。跟着书本慢慢敲，从第一个程序 Hello World 慢慢敲起，<strong>万丈高楼平地起</strong>。</p>
<p>由于 Android 是用 java 或者 kotlin 语言开发的，建议优先掌握 java 语言。这里推荐两本书籍。</p>
<ol>
<li>java 编程思想，一本很经典的 java 书籍</li>
<li>java 剑指 offer，面试神器。校招的时候，有很多面试题目，里面都有涉及到。</li>
</ol>
<p>第二：掌握基本的语法之后，常用的数据结构，数组，链表，队列，栈。这些基本的概念和语法要知道。还有线程，文件 IO 操作，网络操作。</p>
<p>学完这些之后，Java 的基本知识你大概掌握了，这时候建议你动手写一些小项目或者 Demo，比如坦克大战，计算器等，这些网上都有代码。想跟着视频一起学的话，推荐马士兵的视频，可以在我的微信公众号 <strong>程序员徐公</strong> 回复”<strong>Java</strong>“，会将教程发给你</p>
<h2 id="Android-学习入门"><a href="#Android-学习入门" class="headerlink" title="Android 学习入门"></a>Android 学习入门</h2><p>掌握这些之后，你可以去看一些 Android 入门的书籍或者一些视频。</p>
<p>书籍我推荐郭霖的第一行代码，目前出了第三版了，写得真不错。</p>
<p>视频的话，我推荐你可以看黑马的 Android 视频，里面会从一些基本语法讲起，接着是项目实战，会手把手教你实现简单的新闻客户端，360 手机卫士等等。</p>
<p>想获取黑马视频资料的话，可以去我的微信公众号<strong>程序员徐公</strong>回复”<strong>黑马</strong>“两字，会将教程发给你。</p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210410183019.png"></p>
<h2 id="Android-进阶"><a href="#Android-进阶" class="headerlink" title="Android 进阶"></a>Android 进阶</h2><p>学习完基本的知识之后，可以去看看任玉刚的 Android 开发艺术探索，虽然是几年前出版的，但真的是精华。</p>
<p>接着，可以关注一些架构，性能优化方面的。</p>
<ul>
<li>MVC， MVP， MVVN</li>
<li>内存泄露怎么检测，常见的内存泄露有哪些</li>
<li>怎么检测 ANR，有哪些手段呢，优缺点是什么</li>
<li>怎么捕获 Crash，Java Crash 和 native crash 有哪些不同呢</li>
<li> Android 检测启动时间，启动优化怎么做，常见的 Android 启动优化手段有哪些</li>
<li>Android gradle，是怎样打包的，怎样提高编译速度</li>
</ul>
<p><strong>这里推荐几篇不错的文章</strong>。</p>
<p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<h2 id="关注前沿技术"><a href="#关注前沿技术" class="headerlink" title="关注前沿技术"></a>关注前沿技术</h2><p>关注前沿技术，可以去一些论坛，公众号上面逛逛。</p>
<p>论坛的话，推荐掘金，CSDN</p>
<p> Android 技术公众号的话，推荐鸿洋，郭霖的公众号，当然还有我的公众号<strong>程序员徐公</strong>。文章的质量算是比较高的。</p>
<p> 最后，有空的时候多去 <a href="https://github.com/">github</a> 或者 <a href="https://developer.android.com/">google 官网</a> 看看，有什么新技术，一般第一时间会更新。</p>
<hr>
<h1 id="如何进入大厂"><a href="#如何进入大厂" class="headerlink" title="如何进入大厂"></a>如何进入大厂</h1><p>面试是一个双向选择的过程，我们要保持足够的自信。</p>
<p>在我看来，要进入大厂，有 4 点最重要。</p>
<ol>
<li>编程能力，包括常用技术以及常用技术的原理，<strong>毕竟招人，是来干活的，不是来当爹的</strong>。</li>
<li>技术深度，在大厂，分工越来越越明确，职责越来越细。很多时候，需要的是某一个技术领域的人才，而不是什么都懂一点的全才。</li>
<li>算法。</li>
<li>软技能，沟通能力等</li>
</ol>
<h2 id="如何学习算法"><a href="#如何学习算法" class="headerlink" title="如何学习算法"></a>如何学习算法</h2><p>现如今，如果你想进入大厂，腾讯，阿里，头条，拼多多等，不管是社招还是校招，肯定都会面试到算法的。</p>
<p>相信很多人有这样的想法，<strong>面试的时候早火箭，工作的时候拧螺丝</strong>。确实，这种情况非常常见，我也认同。但没办法，谁叫我们想进入大厂呢。</p>
<p><strong>不过，这种情况也可以理解。怎么在几轮面试中确定面试者的水平呢？<br>肯定是考察算法，基础这些，原理这些</strong>。</p>
<p>虽然这些代表不了全部，但起码能在一定程度上代表了面试者的水平能力。要知道，<strong>编程语言其实都是想通的，编程思维和算法能力才是核心。</strong></p>
<p>掌握了原理，编程思维，切换到另外一门语言其实是很快的。这也就是面试官喜欢考察算法和原理的原因。</p>
<p><strong>至于要怎么学习算法，我简单归纳一下</strong></p>
<p>第一：要了解基本的数据结果，数组，链表，Map，Set，二叉树等，了解他们的优缺点，时间复杂度，空间复杂度等</p>
<p>第二：要掌握一些常见的算法，递归，迭代，八大排序，二分查找，贪心算法等</p>
<p>第三：掌握一种算法，不仅要知道 what，还要知道 why（分析各种算法的优缺点），比如 topK问题，有常见的几种解决方案，排序，快排思想，海量数据堆排序</p>
<p>第四：刚开始学的时候，可能会比较吃力，<strong>可以先刷题，慢慢找感觉，从易到难</strong>。</p>
<ul>
<li>比如，第一天，你刷这道算法题的时候看不懂，先不用着急，很多人都是这样过来的，先搜一下答案，看一下别人是怎么解决的。</li>
<li>看懂了之后，自己用代码写一遍，跑一遍。这很重要，很多时候，你以为你自己懂了，但当你在写的时候是写不出来的，在你动手写代码时，会不断加深你的印象</li>
<li>第二天，自己再写一遍，加深印象</li>
</ul>
<p>第五：学好算法不是一日之功，需要长期的积累。建议的做法是每天做一两道题，题目不在多，贵在于理解。坚持一两个月，你会发现你的感觉逐渐好起来了。</p>
<p><a href="https://github.com/gdutxiaoxu/Android_interview">https://github.com/gdutxiaoxu/Android_interview</a></p>
<h1 id="Android-学习资料分析"><a href="#Android-学习资料分析" class="headerlink" title="Android 学习资料分析"></a>Android 学习资料分析</h1><h2 id="黑马-52-期不加密视频"><a href="#黑马-52-期不加密视频" class="headerlink" title="黑马 52 期不加密视频"></a>黑马 52 期不加密视频</h2><p><strong>获取方式在微信公众号 “程序员徐公” 回复“黑马” 两字</strong></p>
<blockquote>
<p>01、安卓基础+JNI (14天)<br>02、Android应用开 发-代码版本管理和实战(1天)<br>03、android案例与项目_手机安全卫士(12天)<br>04、自定义控件与视图(2天)<br>05、android项目 实战_智慧北京(6天)<br>06、android项 目实战_谷歌应用市场(6天)<br>07、android进阶 高阶案例-QQ5.0特效专辑(2天)<br>08、android游戏开发_ 植物大战僵尸(3天)<br>09、android案例与项目_ 百度地图(1天_ 补充)<br>10、android项目实战_智能短信管理(3天_ <em>补充)<br>11、Android</em> _WebView&amp;HTML5开发(1天 _补充) </p>
</blockquote>
<h2 id="Java-马士兵视频"><a href="#Java-马士兵视频" class="headerlink" title="Java  马士兵视频"></a>Java  马士兵视频</h2><p><strong>获取方式在微信公众号 “程序员徐公” 回复“java” 两字</strong></p>
<p><strong>第一部分：J2se学习视频内容包括：</strong></p>
<blockquote>
<p>尚学堂科技_马士兵_JAVA视频教程_JDK5.0_下载-安装-配置<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第01章_JAVA简介_源代码_及重要说明<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第02章_递归补充<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第02章_基础语法<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第03章_面向对象<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第04章_异常处理<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第05章_数组<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第06章_常用类<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第07章_容器<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第08章_IO<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第09章_线程<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第10章_网络<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第11章_GUI<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_专题_日期处理<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_专题_正则表达式</p>
</blockquote>
<p><strong>第二部分：j2se练习项目视频内容包括：</strong></p>
<p>第二部分：j2se练习项目视频内容包括：</p>
<blockquote>
<p>尚学堂科技_马士兵_在线聊天系统雏形视频教程_java_eclipse<br>尚学堂科技_马士兵_坦克大战视频教程_java_eclipse<br>尚学堂科技_马士兵_坦克大战图片版<br>尚学堂科技_马士兵_JAVA_坦克大战网络版视频教程<br>尚学堂科技_马士兵_snake_贪吃蛇内部视频</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上是我这些年来， Android 学习路上的一些简单分享。在 Android 的学习路上，我是站在巨人的肩膀上成长起来的，同样，我也希望成为你们的巨人。</p>
<p>希望我们可以成为朋友，成长路上的忠实伙伴！</p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%EF%BC%88%E4%B8%8D%E5%B8%A6%E6%B0%B4%E5%8D%B0%EF%BC%89.png"></p>
]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马 Android 52 期学习视频，不加密的，免费分享给大家</title>
    <url>/2021/04/17/%E9%BB%91%E9%A9%AC-Android-52-%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%EF%BC%8C%E4%B8%8D%E5%8A%A0%E5%AF%86%E7%9A%84%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6/</url>
    <content><![CDATA[<h1 id="Android-黑马学习视频"><a href="#Android-黑马学习视频" class="headerlink" title="Android 黑马学习视频"></a>Android 黑马学习视频</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>01、安卓基础+JNI (14天)</li>
<li>02、Android应用开 发-代码版本管理和实战(1天)</li>
<li>03、android案 例与项目_手机安全卫士(12天)</li>
<li>04、自定义控件与视图(2天)</li>
<li>05、android项目实战_ 智慧北京(6天)</li>
<li>06、android项目实战_谷歌应用市场(6天)</li>
<li>07、android进阶高阶案例-QQ5.0特效专辑(2天)</li>
<li>08、android游戏开发_植物大战僵尸(3天)</li>
<li>09、android案例与项目_ .百度地图(1天_ 补充)</li>
<li>10、android项目实战_ 智能短信管理(3天_ 补充)</li>
<li>11、Android_ <em>WebView&amp;HTML5开发(1天</em> 补充)</li>
</ul>
<h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><p><a href="https://pan.baidu.com/s/123PF5W2t1SgjQ9wpoFW7Rg">百度云链接</a></p>
<p><a href="https://github.com/gdutxiaoxu/Android_interview">Android 学习 + 面试指南：</a></p>
<p>如果链接过期了，可以关注我的微信公众号“<strong>程序员徐公</strong>”，回复“<strong>黑马</strong>“两字，会自动发给你</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210409172003.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Android 启动优化（六） - 深入理解布局优化</title>
    <url>/2021/02/27/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E5%85%AD%EF%BC%89-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br>我的掘金：<a href="https://juejin.im/user/2207475076966584">https://juejin.im/user/2207475076966584</a>  <br><br>github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br>微信公众号：程序员徐公 <br></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到 Android 启动优化，你一般会想到什么呢？</p>
<ol>
<li>Android 多线程异步加载</li>
<li>Android 首页懒加载</li>
</ol>
<p>对，这是两种很常见的优化手段，但是如果让你主导这件事情，你会如何开始呢？</p>
<ol>
<li>梳理现有的业务，哪些是一定要在启动初始化的，哪些是不必要的</li>
<li>需要在启动初始化的，哪些是可以在主线程初始化的，哪些是可以在子线程初始化的</li>
</ol>
<p>当我们把任务丢到子线程初始化，这时候，我们又会遇到两个问题。</p>
<ol>
<li>在首页，我们需要用到这个库，如果直接使用，这个库可能还没有初始化，这时候直接调用该库，会发生异常，你要怎么解决</li>
<li>当我们的任务相互依赖时，比如 A 依赖于 B， C 也依赖于 B，要怎么解决这种依赖关系。</li>
</ol>
<p>这些你有想过嘛。答案都在这几篇文章里面了，这里我就不展开讲了，有兴趣的可以看一下。</p>
<p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><strong>接下来，我们来说一下布局优化相关的。</strong></p>
<h1 id="布局优化的现状与发展趋势"><a href="#布局优化的现状与发展趋势" class="headerlink" title="布局优化的现状与发展趋势"></a>布局优化的现状与发展趋势</h1><h2 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h2><p>众所周知，布局加载一直是耗时的重灾区。特别是启动阶段，作为第一个 View 加载，更是耗时。</p>
<p>而布局加载之所以耗时，有两个原因。</p>
<ol>
<li>读取 xml 文件，这是一个 IO 操作。</li>
<li>解析 xml 对象，反射创建 View</li>
</ol>
<p>一些很常见的做法是</p>
<ol>
<li>减少布局嵌套层数，减少过度绘制</li>
<li>空界面，错误界面等界面进行懒加载</li>
</ol>
<p> 那除了这些做法，我们还有哪些手段可以优化呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>异步加载</li>
<li>采用代码的方式编写布局</li>
</ol>
<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>google 很久之前提供了 AsyncLayoutInflater，异步加载的方案，不过这种方式有蛮多坑的，下文会介绍</p>
<h3 id="采用代码的方式编写布局"><a href="#采用代码的方式编写布局" class="headerlink" title="采用代码的方式编写布局"></a>采用代码的方式编写布局</h3><p>代码编写的方式编写布局，我们可能想到使用 java 声明布局，对于稍微复杂一点的布局，这种方式是不可取的，存在维护性查，修改困难等问题。为了解决这个问题，github 上面诞生了一系列优秀的开源库。</p>
<p><a href="https://github.com/facebook/litho">litho</a></p>
<p><a href="https://github.com/iReaderAndroid/X2C">X2C</a></p>
<blockquote>
<p>为了即保留xml的优点，又解决它带来的性能问题，我们开发了X2C方案。即在编译生成APK期间，将需要翻译的layout翻译生成对应的java文件，这样对于开发人员来说写布局还是写原来的xml，但对于程序来说，运行时加载的是对应的java文件.<br/><br>我们采用APT（Annotation Processor Tool）+ JavaPoet技术来完成编译期间【注解】-&gt;【解注解】-&gt;【翻译xml】-&gt;【生成java】整个流程的操作。</p>
</blockquote>
<p><strong>这两个开源库在大型的项目基本不会使用，不过他们的价值是值得肯定的，核心思想很有意义</strong>。</p>
<p>xml 布局加载耗时的问题， google 也想改善这种现状，最近 Compose beta 发布了，他是采用声明式 UI 的方式来编写布局，避免了 xml 带来的耗时。同时，还支持布局实时预览。这个应该是以后的发展趋势。</p>
<p><a href="https://github.com/android/compose-samples">compose-samples</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面讲了布局优化的现状与发展趋势，接下来我们一起来看一下，有哪些布局优化手段，可以应用到项目中的。</p>
<ol>
<li>渐进式加载</li>
<li>异步加载</li>
<li>compose 声明式 UI</li>
</ol>
<h1 id="渐进式加载"><a href="#渐进式加载" class="headerlink" title="渐进式加载"></a>渐进式加载</h1><h2 id="什么是渐进式加载"><a href="#什么是渐进式加载" class="headerlink" title="什么是渐进式加载"></a>什么是渐进式加载</h2><p>渐进式加载，简单来说，就是一部分一部分加载，当前帧加载完成之后，再去加载下一帧。</p>
<p>一种极致的做法是，加载 xml 文件，就想加载一个空白的 xml，布局全部使用 ViewStub 标签进行懒加载。</p>
<p>这样设计的好处是可以减缓同一时刻，加载 View 带来的压力，通常的做法是我们先加载核心部分的 View，再逐步去加载其他 View。</p>
<p>有人可能会这样问了，这样的设计很鸡肋，有什么用呢？</p>
<p><strong>确实，在高端机上面作用不明显，甚至可能看不出来，但是在中低端机上面，带来的效果还是很明显的</strong>。在我们项目当中，复杂的页面首帧耗时约可以减少 30%。</p>
<p><strong>优点</strong>：适配成本低，在中低端机上面效果明显。</p>
<p><strong>缺点</strong>：还是需要在主线程读取 xml 文件</p>
<h2 id="核心伪代码"><a href="#核心伪代码" class="headerlink" title="核心伪代码"></a>核心伪代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start()&#123;</span><br><span class="line">    loadA()&#123;</span><br><span class="line">        loadB()&#123;</span><br><span class="line">            loadC()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的这种写法，是可以的，但是这种做法，有一个很明显的缺点，就是会造成回调嵌套层数过多。当然，我们也可以使用 RxJava 来解决这种问题。但是，如果项目中没用 Rxjava，引用进来，会造成包 size 增加。</p>
<p>一个简单的做法就是<strong>使用队列的思想，将所有的 ViewStubTask 添加到队列当中，当当前的 ViewStubTask 加载完成，才加载下一个</strong>，这样可以避免回调嵌套层数过多的问题。</p>
<p>改造之后的代码见</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val decorView &#x3D; this.window.decorView</span><br><span class="line">ViewStubTaskManager.instance(decorView)</span><br><span class="line">            .addTask(ViewStubTaskContent(decorView))</span><br><span class="line">            .addTask(ViewStubTaskTitle(decorView))</span><br><span class="line">            .addTask(ViewStubTaskBottom(decorView))</span><br><span class="line">            .start()</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ViewStubTaskManager private constructor(val decorView: View) : Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private var iViewStubTask: IViewStubTask? &#x3D; null</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        const val TAG &#x3D; &quot;ViewStubTaskManager&quot;</span><br><span class="line"></span><br><span class="line">        @JvmStatic</span><br><span class="line">        fun instance(decorView: View): ViewStubTaskManager &#123;</span><br><span class="line">            return ViewStubTaskManager(decorView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val queue: MutableList&lt;ViewStubTask&gt; &#x3D; CopyOnWriteArrayList()</span><br><span class="line">    private val list: MutableList&lt;ViewStubTask&gt; &#x3D; CopyOnWriteArrayList()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun setCallBack(iViewStubTask: IViewStubTask?): ViewStubTaskManager &#123;</span><br><span class="line">        this.iViewStubTask &#x3D; iViewStubTask</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun addTask(viewStubTasks: List&lt;ViewStubTask&gt;): ViewStubTaskManager &#123;</span><br><span class="line">        queue.addAll(viewStubTasks)</span><br><span class="line">        list.addAll(viewStubTasks)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun addTask(viewStubTask: ViewStubTask): ViewStubTaskManager &#123;</span><br><span class="line">        queue.add(viewStubTask)</span><br><span class="line">        list.add(viewStubTask)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun start() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        iViewStubTask?.beforeTaskExecute()</span><br><span class="line">        &#x2F;&#x2F; 指定 decorView 绘制下一帧的时候会回调里面的 runnable</span><br><span class="line">        ViewCompat.postOnAnimation(decorView, this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun stop() &#123;</span><br><span class="line">        queue.clear()</span><br><span class="line">        list.clear()</span><br><span class="line">        decorView.removeCallbacks(null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun isEmpty() &#x3D; queue.isEmpty() || queue.size &#x3D;&#x3D; 0</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当队列不为空的时候，先加载当前 viewStubTask</span><br><span class="line">            val viewStubTask &#x3D; queue.removeAt(0)</span><br><span class="line">            viewStubTask.inflate()</span><br><span class="line">            iViewStubTask?.onTaskExecute(viewStubTask)</span><br><span class="line">            &#x2F;&#x2F; 加载完成之后，再 postOnAnimation 加载下一个</span><br><span class="line">            ViewCompat.postOnAnimation(decorView, this)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            iViewStubTask?.afterTaskExecute()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnDetach() &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.onDetach()</span><br><span class="line">        &#125;</span><br><span class="line">        list.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnDataReady() &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.onDataReady()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IViewStubTask &#123;</span><br><span class="line"></span><br><span class="line">    fun beforeTaskExecute()</span><br><span class="line"></span><br><span class="line">    fun onTaskExecute(viewStubTask: ViewStubTask)</span><br><span class="line"></span><br><span class="line">    fun afterTaskExecute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/gdutxiaoxu/AnchorTask%EF%BC%8C**%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E4%B8%BB%E8%A6%81%E5%9C%A8">https://github.com/gdutxiaoxu/AnchorTask，**核心代码主要在</a> <code>ViewStubTask</code>，<code>ViewStubTaskManager</code>**, 有兴趣的可以看看</p>
<h1 id="异步加载-1"><a href="#异步加载-1" class="headerlink" title="异步加载"></a>异步加载</h1><p>异步加载，简单来说，就是在子线程创建 View。在实际应用中，我们通常会先预加载 View，常用的方案有：</p>
<ol>
<li>在合适的时候，启动子线程 inflate layout。然后取的时候，直接去缓存里面查找 View 是否已经创建好了，是的话，直接使用缓存。否则，等待子线程 inlfate 完成。</li>
</ol>
<h2 id="AsyncLayoutInflater"><a href="#AsyncLayoutInflater" class="headerlink" title="AsyncLayoutInflater"></a>AsyncLayoutInflater</h2><p>官方提供了一个类，可以来进行异步的inflate，但是有两个缺点：</p>
<ol>
<li>每次都要现场new一个出来</li>
<li>异步加载的view只能通过callback回调才能获得（死穴）</li>
</ol>
<p>因此，我们可以仿造官方的 AsyncLayoutInflater 进行改造。<strong>核心代码在 AsyncInflateManager</strong>。主要介绍两个方法。</p>
<p><code>asyncInflate</code> 方法，在子线程 inflateView，并将加载结果存放到 mInflateMap 里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    @UiThread</span><br><span class="line">fun asyncInflate(</span><br><span class="line">        context: Context,</span><br><span class="line">        vararg items: AsyncInflateItem?</span><br><span class="line">    ) &#123;</span><br><span class="line">        items.forEach &#123; item -&gt;</span><br><span class="line">            if (item &#x3D;&#x3D; null || item.layoutResId &#x3D;&#x3D; 0 || mInflateMap.containsKey(item.inflateKey) || item.isCancelled() || item.isInflating()) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            mInflateMap[item.inflateKey] &#x3D; item</span><br><span class="line">            onAsyncInflateReady(item)</span><br><span class="line">            inflateWithThreadPool(context, item)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>getInflatedView</code> 方法，用来获得异步inflate出来的view，核心思想如下</p>
<ul>
<li>先从缓存结果里面拿 View，拿到了view直接返回</li>
<li>没拿到view，但是子线程在inflate中，等待返回</li>
<li>如果还没开始inflate，由UI线程进行inflate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 用来获得异步inflate出来的view</span><br><span class="line"> *</span><br><span class="line"> * @param context</span><br><span class="line"> * @param layoutResId 需要拿的layoutId</span><br><span class="line"> * @param parent      container</span><br><span class="line"> * @param inflateKey  每一个View会对应一个inflateKey，因为可能许多地方用的同一个 layout，但是需要inflate多个，用InflateKey进行区分</span><br><span class="line"> * @param inflater    外部传进来的inflater，外面如果有inflater，传进来，用来进行可能的SyncInflate，</span><br><span class="line"> * @return 最后inflate出来的view</span><br><span class="line"> *&#x2F;</span><br><span class="line">@UiThread</span><br><span class="line">fun getInflatedView(</span><br><span class="line">    context: Context?,</span><br><span class="line">    layoutResId: Int,</span><br><span class="line">    parent: ViewGroup?,</span><br><span class="line">    inflateKey: String?,</span><br><span class="line">    inflater: LayoutInflater</span><br><span class="line">): View &#123;</span><br><span class="line">    if (!TextUtils.isEmpty(inflateKey) &amp;&amp; mInflateMap.containsKey(inflateKey)) &#123;</span><br><span class="line">        val item &#x3D; mInflateMap[inflateKey]</span><br><span class="line">        val latch &#x3D; mInflateLatchMap[inflateKey]</span><br><span class="line">        if (item !&#x3D; null) &#123;</span><br><span class="line">            val resultView &#x3D; item.inflatedView</span><br><span class="line">            if (resultView !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;拿到了view直接返回</span><br><span class="line">                removeInflateKey(item)</span><br><span class="line">                replaceContextForView(resultView, context)</span><br><span class="line">                Log.i(TAG, &quot;getInflatedView from cache: inflateKey is $inflateKey&quot;)</span><br><span class="line">                return resultView</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (item.isInflating() &amp;&amp; latch !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;没拿到view，但是在inflate中，等待返回</span><br><span class="line">                try &#123;</span><br><span class="line">                    latch.await()</span><br><span class="line">                &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">                    Log.e(TAG, e.message, e)</span><br><span class="line">                &#125;</span><br><span class="line">                removeInflateKey(item)</span><br><span class="line">                if (resultView !&#x3D; null) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;getInflatedView from OtherThread: inflateKey is $inflateKey&quot;)</span><br><span class="line">                    replaceContextForView(resultView, context)</span><br><span class="line">                    return resultView</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果还没开始inflate，则设置为false，UI线程进行inflate</span><br><span class="line">            item.setCancelled(true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, &quot;getInflatedView from UI: inflateKey is $inflateKey&quot;)</span><br><span class="line">    &#x2F;&#x2F;拿异步inflate的View失败，UI线程inflate</span><br><span class="line">    return inflater.inflate(layoutResId, parent, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简单-Demo-示范"><a href="#简单-Demo-示范" class="headerlink" title="简单 Demo 示范"></a>简单 Demo 示范</h2><p>第一步：选择在合适的时机调用  <code>AsyncUtils#asyncInflate</code> 方法预加载 View，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object AsyncUtils &#123;</span><br><span class="line"></span><br><span class="line">    fun asyncInflate(context: Context) &#123;</span><br><span class="line">        val asyncInflateItem &#x3D;</span><br><span class="line">            AsyncInflateItem(</span><br><span class="line">                LAUNCH_FRAGMENT_MAIN,</span><br><span class="line">                R.layout.fragment_asny,</span><br><span class="line">                null,</span><br><span class="line">                null</span><br><span class="line">            )</span><br><span class="line">        AsyncInflateManager.instance.asyncInflate(context, asyncInflateItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun isHomeFragmentOpen() &#x3D;</span><br><span class="line">        getSP(&quot;async_config&quot;).getBoolean(&quot;home_fragment_switch&quot;, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在获取 View 的时候，先去缓存里面查找 View</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater, container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        &#x2F;&#x2F; Inflate the layout for this fragment</span><br><span class="line">        val startTime &#x3D; System.currentTimeMillis()</span><br><span class="line">        val homeFragmentOpen &#x3D; AsyncUtils.isHomeFragmentOpen()</span><br><span class="line">        val inflatedView: View</span><br><span class="line"></span><br><span class="line">        inflatedView &#x3D; AsyncInflateManager.instance.getInflatedView(</span><br><span class="line">            context,</span><br><span class="line">            R.layout.fragment_asny,</span><br><span class="line">            container,</span><br><span class="line">            LAUNCH_FRAGMENT_MAIN,</span><br><span class="line">            inflater</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Log.i(</span><br><span class="line">            TAG,</span><br><span class="line">            &quot;onCreateView: homeFragmentOpen is $homeFragmentOpen, timeInstance is $&#123;System.currentTimeMillis() - startTime&#125;, $&#123;inflatedView.context&#125;&quot;</span><br><span class="line">        )</span><br><span class="line">        return inflatedView</span><br><span class="line">&#x2F;&#x2F;        return inflater.inflate(R.layout.fragment_asny, container, false)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p>
<p>可以大大减少 View 创建的时间，使用这种方案之后，获取 View 的时候基本在 10ms 之内的。</p>
<p><strong>缺点</strong></p>
<ol>
<li>由于 View 是提前创建的，并且会存在在一个 map，需要根据自己的业务场景将 View 从 map 中移除，不然会发生内存泄露</li>
<li>View 如果缓存起来，记得在合适的时候重置 view 的状态，不然有时候会发生奇奇怪怪的现象。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <strong>参考文章</strong></p>
<p><a href="https://juejin.cn/post/6844903924965572615">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a></p>
<ol>
<li>View 的渐进式加载，在 JectPack compose 没有推广之后，推荐使用这种方案，适配成本低</li>
<li>View 的异步加载方案，虽然效果显著，但是适配成本也高，没搞好，容易发生内存泄露</li>
<li>JectPack compose 声明式 UI，基本是未来的趋势，有兴趣的可以提前了解一下他。</li>
</ol>
<p>这篇文章,加上一些 Demo，足足花了我几个晚上的时间，觉得不错的话可以关注一下我的微信公众号<strong>程序员徐公</strong>，小弟在此感谢各位大佬们。</p>
<p>源码地址：<a href="https://github.com/gdutxiaoxu/AnchorTask">https://github.com/gdutxiaoxu/AnchorTask</a></p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（五） - AnchorTask 1.0.0 版本更新了</title>
    <url>/2021/02/18/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89-%20%20AnchorTask%201.0.0%20%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BA%86/</url>
    <content><![CDATA[<blockquote>
<p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f71791b5cb4f96984c4863e0b7fe18~tplv-k3u1fbpfcp-zoom-1.image">点此扫码关注</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周六，吃错了东西，突然头晕，发烧，半夜突然呕吐，拉肚子，整个人被折腾得够呛的。到医院检查，说是 xx 肠炎，吃错东西导致的，整整躺在家休息四天。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb71568b4c2413d93c2aa1303214203~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>今天，终于缓过来了。更新一下 Android 启动优化有向无环图系列的最后一篇文章。最近一段时间，暂时不会更新这方面的文章了。系列文章汇总如下：</p>
<p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图
</a></p>
<p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://juejin.cn/post/6931903136256753672">Android 启动优化（三） - AnchorTask 使用说明 </a></p>
<p><a href="https://juejin.cn/post/6931905215733956616">Android 启动优化（四）- 手把手教你实现 AnchorTask</a></p>
<h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><ol>
<li>之前的 0.1.0 版本 配置前置依赖任务，是通过 <code>AnchorTask getDependsTaskList</code> 的方式，他是通过 <code>className</code> 找到 <code>AnchorTask</code>，并且内聚在当前的 AnchorTask 中，从全局的角度看 ，这种方式不太直观，1.0.0 放弃了这种方式，参考阿里 <code>Alpha</code> 的方式，通过 <code>addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</code></li>
<li>1.0.0 版本新增了 Project 类，并增加 <code>OnProjectExecuteListener</code> 监听</li>
<li>1.0.0 版本新增 <code>OnGetMonitorRecordCallback</code> 监听，方便统计各个任务的耗时</li>
</ol>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p> Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p>
<p>多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p>
<p>假设我们有这样的任务依赖</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3633baa6201b48eebd19283d5613cb74~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>我们要怎么使用它呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val project &#x3D;</span><br><span class="line">    AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)</span><br><span class="line">        .setAnchorTaskCreator(ApplicationAnchorTaskCreator())</span><br><span class="line">        .addTask(TASK_NAME_ZERO)</span><br><span class="line">        .addTask(TASK_NAME_ONE)</span><br><span class="line">        .addTask(TASK_NAME_TWO)</span><br><span class="line">        .addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br><span class="line">        .addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)</span><br><span class="line">        .addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)</span><br><span class="line">        .build()</span><br><span class="line">project.start().await()</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ApplicationAnchorTaskCreator : IAnchorTaskCreator &#123;</span><br><span class="line">    override fun createTask(taskName: String): AnchorTask? &#123;</span><br><span class="line">        when (taskName) &#123;</span><br><span class="line">            TASK_NAME_ZERO -&gt; &#123;</span><br><span class="line">                return AnchorTaskZero()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TASK_NAME_ONE -&gt; &#123;</span><br><span class="line">                return AnchorTaskOne()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_TWO -&gt; &#123;</span><br><span class="line">                return AnchorTaskTwo()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_THREE -&gt; &#123;</span><br><span class="line">                return AnchorTaskThree()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_FOUR -&gt; &#123;</span><br><span class="line">                return AnchorTaskFour()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_FIVE -&gt; &#123;</span><br><span class="line">                return AnchorTaskFive()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Demo 跑起来，可以看到预期的效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b031f5ee23ec4c87bdd495d7499e48ba~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>第一步：在 moulde build.gradle 配置远程依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.xj.android:anchortask:1.0.0&#39;</span><br></pre></td></tr></table></figure>

<p>最新的版本号可以看这里 <a href="https://dl.bintray.com/xujun94/maven/com/xj/android/anchortask/">lastedt version</a></p>
<p>第二步：自定义 <code>AnchorTaskZero</code>，继承 <code>AnchorTask</code>，并指定 <code>taskName</code>，注意 <code>taskName </code>必须是唯一的，因为我们会根据 <code>taskName</code> 找到相应的 <code>AnchorTask</code> 重写相应的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskZero() : AnchorTask(TASK_NAME_ZERO) &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果任务 三 依赖任务 二，任务 一，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br></pre></td></tr></table></figure>

<p>最后，通过 <code> project.start()</code>  方法启动， 如果需要阻塞等待，调用 await() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)</span><br><span class="line">                .setAnchorTaskCreator(ApplicationAnchorTaskCreator())</span><br><span class="line">                .addTask(TASK_NAME_ZERO)</span><br><span class="line">                .addTask(TASK_NAME_ONE)</span><br><span class="line">                .addTask(TASK_NAME_TWO)</span><br><span class="line">                .addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br><span class="line">                .addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)</span><br><span class="line">                .addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)</span><br><span class="line">                .build()</span><br><span class="line">project.start().await()</span><br></pre></td></tr></table></figure>

<h3 id="监听任务回调"><a href="#监听任务回调" class="headerlink" title="监听任务回调"></a>监听任务回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project.addListener(object : OnProjectExecuteListener &#123;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F; project 开始执行的时候</span><br><span class="line">            override fun onProjectStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(MyApplication.TAG, &quot;onProjectStart &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; project 执行一个 task 完成的时候</span><br><span class="line">            override fun onTaskFinish(taskName: String) &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(</span><br><span class="line">                    MyApplication.TAG,</span><br><span class="line">                    &quot;onTaskFinish, taskName is $taskName&quot;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; project 执行完成的时候</span><br><span class="line">            override fun onProjectFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(MyApplication.TAG, &quot;onProjectFinish &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="添加每个任务执行耗时回调"><a href="#添加每个任务执行耗时回调" class="headerlink" title="添加每个任务执行耗时回调"></a>添加每个任务执行耗时回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project.onGetMonitorRecordCallback &#x3D; object : OnGetMonitorRecordCallback &#123;</span><br><span class="line">           </span><br><span class="line">            &#x2F;&#x2F; 所有 task 执行完毕会调用这个方法，Map 存储了 task 的执行时间， key 是 taskName，value 是时间，单位毫秒</span><br><span class="line">            override fun onGetTaskExecuteRecord(result: Map&lt;String?, Long?&gt;?) &#123;</span><br><span class="line">                onGetMonitorRecordCallback?.onGetTaskExecuteRecord(result)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 所有 task 执行完毕会调用这个方法，costTime 执行时间</span><br><span class="line">            override fun onGetProjectExecuteTime(costTime: Long) &#123;</span><br><span class="line">                onGetMonitorRecordCallback?.onGetProjectExecuteTime(costTime)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h2 id="AnchorProject-介绍"><a href="#AnchorProject-介绍" class="headerlink" title="AnchorProject 介绍"></a>AnchorProject 介绍</h2><ol>
<li><code>AnchorTaskDispatcher start</code> 方法必须在主线程调用，子线程调用会抛出异常。</li>
<li><code>await</code> 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走，await 方法携带一个参数，timeOutMillion 表示超时等待的时间</li>
<li><code>await()</code> 方法必须在 start 方法之后调用</li>
<li>添加任务是通过 <code>AnchorProject.Builder().addTask</code> 添加的，典型的构造模式</li>
<li>设置执行的线程池，可以通过 <code>AnchorProject.Builder().setThreadPoolExecutor(TaskExecutorManager.instance.cpuThreadPoolExecutor)</code></li>
</ol>
<h2 id="AnchorTask-介绍"><a href="#AnchorTask-介绍" class="headerlink" title="AnchorTask 介绍"></a>AnchorTask 介绍</h2><p>AnchorTask 实现了 IAnchorTask 接口，主要有几个方法</p>
<ul>
<li><code>isRunOnMainThread(): Boolean</code>表示是否在主线程运行，默认值是 false</li>
<li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li>
<li> <code>needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li>
<li> <code> fun run()</code> 方法，表示任务执行的时候</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskOne : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="监听任务的回调"><a href="#监听任务的回调" class="headerlink" title="监听任务的回调"></a>监听任务的回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val anchorTask &#x3D; AnchorTaskTwo()</span><br><span class="line">        anchorTask.addCallback(object : IAnchorCallBack &#123;</span><br><span class="line">            override fun onAdd() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onAdd: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onStart:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onFinish:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。</p>
<ol>
<li>根据 BFS 构建出有向无环图，并得到它的拓扑排序</li>
<li>在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的<ol>
<li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li>
<li>执行任务</li>
<li> 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li>
</ol>
</li>
</ol>
<p><a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a></p>
<p>想看 1.0.0 版本的具体实现，可以看这篇文章。 <a href="https://github.com/gdutxiaoxu/AnchorTask/wiki/AnchorTask-1.0.0-%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E">AnchorTask 1.0.0 原理说明</a>。</p>
<p><strong>如果你觉得对你有所帮助，可以关注我的微信公众号 <em>程序员徐公</em></strong></p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（四） - 手把手教你实现 AnchorTask</title>
    <url>/2021/01/27/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89-%20%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%20AnchorTask/</url>
    <content><![CDATA[<blockquote>
<p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>
</blockquote>
<p>上一篇博客介绍了 AnchorTask 的基本使用，今天，让我们一起看一下怎么实现它。</p>
<p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图
</a></p>
<p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://juejin.cn/post/6931903136256753672">Android 启动优化（三） - AnchorTask 使用说明 </a></p>
<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>AnchorTask，锚点任务，它的实现原理是构建一个有向无环图，拓扑排序之后，如果任务 B 依赖任务 A，那么 A 一定排在任务 B 之前。</p>
<p><em><strong>了解原理之前，请必须先了解有向无环图和多线程的一些基本知识，不然，下文，你基本是看不懂的</strong></em>。</p>
<h3 id="一个共识"><a href="#一个共识" class="headerlink" title="一个共识"></a>一个共识</h3><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/20210219104449.png"></p>
<ul>
<li><strong>前置任务</strong>：任务 3 依赖于任务 0，1，那么任务 3 的前置任务是任务 0， 1</li>
<li><strong>子任务</strong>：任务 0 执行完之后，任务 3 才能执行，那么称呼任务 3 为 任务 0 的子任务</li>
</ul>
<h3 id="如何构建一个有向无环图"><a href="#如何构建一个有向无环图" class="headerlink" title="如何构建一个有向无环图"></a>如何构建一个有向无环图</h3><p>这里我们采用 BFS 方法实现，算法思想大概是这样的</p>
<ul>
<li>建立入度表，入度为 0 的节点先入队</li>
<li>当队列不为空，进行循环判断<ul>
<li>节点出队，添加到结果 list 当中</li>
<li>将该节点的邻居入度减 1</li>
<li>若邻居课程入度为 0，加入队列</li>
</ul>
</li>
<li>若结果 list 与所有节点数量相等，则证明不存在环。否则，存在环</li>
</ul>
<h3 id="多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？"><a href="#多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？" class="headerlink" title="多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？"></a>多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？</h3><p>这里要解决的主要有三个问题</p>
<ol>
<li>首先我们要解决一个问题，它有哪些前置任务，这个可以用 list 存储，代表它依赖的任务 list。当它所依赖的任务 list 没有执行完毕，当前任务需要等待。</li>
<li>当前任务执行完毕之后，所有依赖它的子任务需要感知到。我们可以用一个 map 来存储这种关系，key 是当前任务，value 是依赖于当前任务的集合（list）</li>
<li>多线程当中，等待和唤醒功能，有多种方式可以实现。wait、notify 机制，ReentrantLock Condition 机制，CountDownLatch 机制。这里我们选择 CountDownLatch 机制，因为 CountDownLatch 有点类似于计数器，特别适合这种场景。</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="IAnchorTask"><a href="#IAnchorTask" class="headerlink" title="IAnchorTask"></a>IAnchorTask</h3><p>首先，我们定义一个 IAnchorTask 接口，主要有一个方法</p>
<ul>
<li><code>isRunOnMainThread(): Boolean</code> 表示是否在主线程运行，默认值是 false</li>
<li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li>
<li> <code> needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li>
<li> <code>fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</code> 方法返回前置任务依赖，默认值是返回 null.</li>
<li> <code> fun run()</code> 方法，表示任务执行的时候</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前任务的前置任务，可以用来确定顶点的入度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它有一个实现类 AnchorTask，增加了 await 和 countdown 方法</p>
<ul>
<li>await 方法，调用它，当前任务会等待</li>
<li>countdown() 方法，如果当前计数器值 &gt; 0,会减一，否则，什么也不操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class AnchorTask : IAnchorTask &#123;</span><br><span class="line"></span><br><span class="line">    private val countDownLatch: CountDownLatch &#x3D; CountDownLatch(getListSize())</span><br><span class="line">    private fun getListSize() &#x3D; getDependsTaskList()?.size ?: 0</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TAG &#x3D; &quot;AnchorTask&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * self call,await</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun await() &#123;</span><br><span class="line">        countDownLatch.await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * parent call, countDown</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun countdown() &#123;</span><br><span class="line">        countDownLatch.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序实现"><a href="#排序实现" class="headerlink" title="排序实现"></a>排序实现</h3><p>无环图的拓扑排序，这里采用的是 BFS 算法。具体的可以见 <code>AnchorTaskUtils#getSortResult</code> 方法，它有三个参数</p>
<ul>
<li>list 存储所有的任务</li>
<li><code> taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt; = HashMap()</code>存储所有的任务,key 是 Class<out AnchorTask>，value 是 AnchorTask</li>
<li>`taskChildMap: MutableMap&lt;Class<out AnchorTask>, ArrayList&lt;Class<out AnchorTask>&gt;?&gt; =<pre><code>  HashMap()`,储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list
</code></pre>
</li>
</ul>
<p>算法思想</p>
<ol>
<li>首先找出所有入度为 0 的队列，用 queue 变量存储</li>
<li>当队列不为空，进行循环判断。<ul>
<li>从队列 pop 出，添加到结果队列</li>
<li>遍历当前任务的子任务，通知他们的入度减一（其实是遍历 taskChildMap），如果入度为 0，添加到队列 queue 里面</li>
</ul>
</li>
<li>当结果队列和 list size 不相等试，证明有环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JvmStatic</span><br><span class="line">fun getSortResult(</span><br><span class="line">    list: MutableList&lt;AnchorTask&gt;, taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt;,</span><br><span class="line">    taskChildMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;?&gt;</span><br><span class="line">): MutableList&lt;AnchorTask&gt; &#123;</span><br><span class="line">    val result &#x3D; ArrayList&lt;AnchorTask&gt;()</span><br><span class="line">    &#x2F;&#x2F; 入度为 0 的队列</span><br><span class="line">    val queue &#x3D; ArrayDeque&lt;AnchorTask&gt;()</span><br><span class="line">    val taskIntegerHashMap &#x3D; HashMap&lt;Class&lt;out AnchorTask&gt;, Int&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 建立每个 task 的入度关系</span><br><span class="line">    list.forEach &#123; anchorTask: AnchorTask -&gt;</span><br><span class="line">        val clz &#x3D; anchorTask.javaClass</span><br><span class="line">        if (taskIntegerHashMap.containsKey(clz)) &#123;</span><br><span class="line">            throw AnchorTaskException(&quot;anchorTask is repeat, anchorTask is $anchorTask, list is $list&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val size &#x3D; anchorTask.getDependsTaskList()?.size ?: 0</span><br><span class="line">        taskIntegerHashMap[clz] &#x3D; size</span><br><span class="line">        taskMap[clz] &#x3D; anchorTask</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            queue.offer(anchorTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 建立每个 task 的 children 关系</span><br><span class="line">    list.forEach &#123; anchorTask: AnchorTask -&gt;</span><br><span class="line">        anchorTask.getDependsTaskList()?.forEach &#123; clz: Class&lt;out AnchorTask&gt; -&gt;</span><br><span class="line">            var list &#x3D; taskChildMap[clz]</span><br><span class="line">            if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">                list &#x3D; ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;()</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(anchorTask.javaClass)</span><br><span class="line">            taskChildMap[clz] &#x3D; list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 BFS 方法获得有向无环图的拓扑排序</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        val anchorTask &#x3D; queue.pop()</span><br><span class="line">        result.add(anchorTask)</span><br><span class="line">        val clz &#x3D; anchorTask.javaClass</span><br><span class="line">        taskChildMap[clz]?.forEach &#123; &#x2F;&#x2F; 遍历所有依赖这个顶点的顶点，移除该顶点之后，如果入度为 0，加入到改队列当中</span><br><span class="line">            var result &#x3D; taskIntegerHashMap[it] ?: 0</span><br><span class="line">            result--</span><br><span class="line">            if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                queue.offer(taskMap[it])</span><br><span class="line">            &#125;</span><br><span class="line">            taskIntegerHashMap[it] &#x3D; result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; size 不相等，证明有环</span><br><span class="line">    if (list.size !&#x3D; result.size) &#123;</span><br><span class="line">        throw AnchorTaskException(&quot;Ring appeared，Please check.list is $list, result is $result&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="AnchorTaskDispatcher"><a href="#AnchorTaskDispatcher" class="headerlink" title="AnchorTaskDispatcher"></a>AnchorTaskDispatcher</h3><p>AnchorTaskDispatcher 这个类很重要，有向无环图的拓扑排序和多线程的依赖唤醒，都是借助这个核心类完成的。</p>
<p>它主要有几个成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 存储所有的任务</span><br><span class="line">    private val list: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 存储所有的任务,key 是 Class&lt;out AnchorTask&gt;，value 是 AnchorTask</span><br><span class="line">    private val taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt; &#x3D; HashMap()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list</span><br><span class="line">    private val taskChildMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;?&gt; &#x3D;</span><br><span class="line">        HashMap()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拓扑排序之后的主线程任务</span><br><span class="line">    private val mainList: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拓扑排序之后的子线程任务</span><br><span class="line">    private val threadList: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要等待的任务总数，用于阻塞</span><br><span class="line">    private lateinit var countDownLatch: CountDownLatch</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要等待的任务总数，用于CountDownLatch</span><br><span class="line">    private val needWaitCount: AtomicInteger &#x3D; AtomicInteger()</span><br></pre></td></tr></table></figure>


<p>它有一个比较重要的方法 <code>setNotifyChildren(anchorTask: AnchorTask)</code> ，有一个方法参数 AnchorTask，它的作用是通知该任务的子任务，当前任务执行完毕，入度数减一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  通知 child countdown,当前的阻塞任务书也需要 countdown</span><br><span class="line"> *&#x2F;</span><br><span class="line">fun setNotifyChildren(anchorTask: AnchorTask) &#123;</span><br><span class="line">    taskChildMap[anchorTask::class.java]?.forEach &#123;</span><br><span class="line">        taskMap[it]?.countdown()</span><br><span class="line">    &#125;</span><br><span class="line">    if (anchorTask.needWait()) &#123;</span><br><span class="line">        countDownLatch.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下 start 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun start(): AnchorTaskDispatcher &#123;</span><br><span class="line">        if (Looper.myLooper() !&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">            throw AnchorTaskException(&quot;start method should be call on main thread&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">        val sortResult &#x3D; AnchorTaskUtils.getSortResult(list, taskMap, taskChildMap)</span><br><span class="line">        LogUtils.i(TAG, &quot;start: sortResult is $sortResult&quot;)</span><br><span class="line">        sortResult.forEach &#123;</span><br><span class="line">            if (it.isRunOnMainThread()) &#123;</span><br><span class="line">                mainList.add(it)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                threadList.add(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch &#x3D; CountDownLatch(needWaitCount.get())</span><br><span class="line"></span><br><span class="line">        val threadPoolExecutor &#x3D;</span><br><span class="line">            this.threadPoolExecutor ?: TaskExecutorManager.instance.cpuThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">        threadList.forEach &#123;</span><br><span class="line">            threadPoolExecutor.execute(AnchorTaskRunnable(this, anchorTask &#x3D; it))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainList.forEach &#123;</span><br><span class="line">            AnchorTaskRunnable(this, anchorTask &#x3D; it).run()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它主要干几件事</p>
<ul>
<li>检测是否在主线程，不是抛出异常，这里为什么要检测在主线程呢？主要是构建有向无环图的过程，我们必须保证是线程安全的</li>
<li>获取有向无环图的拓扑排序</li>
<li>根据拓扑排序的排序结果，执行相应的任务。可以看到在执行任务的时候，我们使用 <code>AnchorTaskRunnable</code> 包裹起来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskRunnable(</span><br><span class="line">    private val anchorTaskDispatcher: AnchorTaskDispatcher,</span><br><span class="line">    private val anchorTask: AnchorTask</span><br><span class="line">) : Runnable &#123;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        Process.setThreadPriority(anchorTask.priority())</span><br><span class="line">        &#x2F;&#x2F;  前置任务没有执行完毕的话，等待，执行完毕的话，往下走</span><br><span class="line">        anchorTask.await()</span><br><span class="line">        anchorTask.onStart()</span><br><span class="line">        &#x2F;&#x2F; 执行任务</span><br><span class="line">        anchorTask.run()</span><br><span class="line">        anchorTask.onFinish()</span><br><span class="line">        &#x2F;&#x2F; 通知子任务，当前任务执行完毕了，相应的计数器要减一。</span><br><span class="line">        anchorTaskDispatcher.setNotifyChildren(anchorTask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>AnchorTaskRunnable 有点类似于装饰者模式，多线程依赖的执行关系在这里都得到体现，只有几行代码</p>
<ol>
<li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li>
<li>执行任务</li>
<li> 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。</p>
<ol>
<li>根据 BFS 构建出有向无环图，并得到它的拓扑排序</li>
<li>在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的<ol>
<li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li>
<li>执行任务</li>
<li>通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li>
</ol>
</li>
</ol>
<p>AnchorTask 源码已经更新到 github，<a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a>。<br>我的微信公众号<strong>程序员徐公</strong>，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（二） - 拓扑排序的原理以及解题思路</title>
    <url>/2021/01/25/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%20-%20%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%20/</url>
    <content><![CDATA[<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>在上一篇文章中 <a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图</a>，我们介绍了有向无环图，以及拓扑排序的两种解法。今天，让我们一起来实战一下。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>拓扑排序的英文名是 Topological sorting。</p>
<p><strong>拓扑排序要解决的问题是给一个图的所有节点排序。有向无环图才有拓扑排序，非有向无环图没有。</strong></p>
<p>换句话说，拓扑排序必须满足以下条件</p>
<p>图必须是一个无环有向图。序列必须满足的条件：</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>我们已 leetcode 上面的一道算法题目作为切入点进行讲解。</p>
<p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">leeocode 210</a>: <a href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p>
<p><strong>eg</strong>: 现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>




<p>这道题，很明显，看起来可以有有向无环图的解法来解决</p>
<h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们首先引入有向图 描述依赖关系</p>
<p>示例：假设 n = 6，先决条件表：[ [3, 0], [3, 1], [4, 1], [4, 2], [5, 3], [5, 4] ]</p>
<ul>
<li>0, 1, 2 没有先修课，可以直接选。其余的，都要先修 2 门课</li>
<li>我们用 有向图 描述这种 依赖关系 (做事的先后关系)：<br><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/20210219104449.png"></li>
</ul>
<p>在有向图中，我们知道，有<strong>入度</strong>和<strong>出度</strong>概念：</p>
<p>如果存在一条有向边 A –&gt; B，则这条边给 A 增加了 1 个出度，给 B 增加了 1 个入度。所以顶点 0、1、2 的 入度为 0。 顶点 3、4、5 的 入度为 2</p>
<h3 id="BFS-前准备工作"><a href="#BFS-前准备工作" class="headerlink" title="BFS 前准备工作"></a>BFS 前准备工作</h3><ul>
<li>我们关心 课程的入度 —— 该值要被减，要被监控</li>
<li>我们关心 课程之间的依赖关系 —— 选这门课会减小哪些课的入度</li>
<li>因此我们需要合适的数据结构，去存储这些关系,这个可以通过哈希表</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>维护一个 queue，里面都是入度为 0 的课程</li>
<li>选择一门课，就让它出列，同时 <strong>查看哈希表</strong>，看它 对应哪些后续课</li>
<li>将这些后续课的 入度 - 1，如果有减至 0 的，就将它推入 queue</li>
<li>不再有新的入度 0 的课入列 时，此时 queue 为空，退出循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private  class Solution &#123;</span><br><span class="line">    public int[] findOrder(int num, int[][] prerequisites) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算所有节点的入度，这里用数组代表哈希表，key 是 index， value 是 inDegree[index].实际开发当中，用 HashMap 比较灵活</span><br><span class="line">        int[] inDegree &#x3D; new int[num];</span><br><span class="line">        for (int[] array : prerequisites) &#123;</span><br><span class="line">            inDegree[array[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找出所有入度为 0 的点，加入到队列当中</span><br><span class="line">        Queue&lt;Integer&gt; queue &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; inDegree.length; i++) &#123;</span><br><span class="line">            if (inDegree[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Integer key &#x3D; queue.poll();</span><br><span class="line">            result.add(key);</span><br><span class="line">            &#x2F;&#x2F; 遍历所有课程</span><br><span class="line">            for (int[] p : prerequisites) &#123;</span><br><span class="line">                &#x2F;&#x2F; 改课程依赖于当前课程 key</span><br><span class="line">                if (key &#x3D;&#x3D; p[1]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 入度减一</span><br><span class="line">                    inDegree[p[0]]--;</span><br><span class="line">                    if (inDegree[p[0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        queue.offer(p[0]); &#x2F;&#x2F; 加入到队列当中</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 数量不相等，说明存在环</span><br><span class="line">        if (result.size() !&#x3D; num) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] array &#x3D; new int[num];</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for (int i : result) &#123;</span><br><span class="line">            array[index++] &#x3D; i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS-解法"><a href="#DFS-解法" class="headerlink" title="DFS 解法"></a>DFS 解法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>对图执行深度优先搜索。</li>
<li>在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。</li>
<li>最后得到栈中顺序的逆序即为拓扑排序顺序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法 2：邻接矩阵 + DFS   由于用的数组，每次都要遍历，效率比较低</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if (numCourses &#x3D;&#x3D; 0) return new int[0];</span><br><span class="line">        &#x2F;&#x2F; 建立邻接矩阵</span><br><span class="line">        int[][] graph &#x3D; new int[numCourses][numCourses];</span><br><span class="line">        for (int[] p : prerequisites) &#123;</span><br><span class="line">            graph[p[1]][p[0]] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录访问状态的数组，访问过了标记 -1，正在访问标记 1，还未访问标记 0</span><br><span class="line">        int[] status &#x3D; new int[numCourses];</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();  &#x2F;&#x2F; 用栈保存访问序列</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (!dfs(graph, status, i, stack)) return new int[0]; &#x2F;&#x2F; 只要存在环就返回</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res &#x3D; new int[numCourses];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            res[i] &#x3D; stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean dfs(int[][] graph, int[] status, int i, Stack&lt;Integer&gt; stack) &#123;</span><br><span class="line">        if (status[i] &#x3D;&#x3D; 1) return false; &#x2F;&#x2F; 当前节点在此次 dfs 中正在访问，说明存在环</span><br><span class="line">        if (status[i] &#x3D;&#x3D; -1) return true;</span><br><span class="line"></span><br><span class="line">        status[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; graph.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; dfs 访问当前课程的后续课程，看是否存在环</span><br><span class="line">            if (graph[i][j] &#x3D;&#x3D; 1 &amp;&amp; !dfs(graph, status, j, stack)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        status[i] &#x3D; -1;  &#x2F;&#x2F; 标记为已访问</span><br><span class="line">        stack.push(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客从实战的角度出发，介绍了有向无环图的两种解法，入度表法和 DFS 法。其中，入度表法很重要，必须掌握。下一篇，我们将从 项目实战的角度来讲解，怎样搭建一个有向无环图的通用框架，敬请期待。</p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（三） - AnchorTask 使用说明</title>
    <url>/2021/01/25/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89-%20AnchorTask%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>
</blockquote>
<p><strong>如果觉得对你有所帮助的，可以关注我的微信公众号，程序员徐公。主要更新 Android 技术，算法，职场相关的。</strong></p>
<p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/qrcode_for_gh_f0b7a2d93f70_430%20(2).jpg"></p>
<p>前两篇博客介绍了 Android 启动优化多线程异步加载依赖问题的解决方案 - 有向无环图，以及如何实现有它。今天，让我们一起来看一下，在 Android 实战中，怎么实现。</p>
<p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图
</a></p>
<p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p>
<p>多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p>
<p>这时候就可以使用 AnchorTask 解决，它的实现原理是构建一个有向无环图，拓扑排序之后，如果任务 B 依赖任务 A，那么 A 一定排在任务 B 之后。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>第一步：在 moulde build.gradle 配置远程依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.xj.android:anchortask:0.1.0&#39;</span><br></pre></td></tr></table></figure>

<p>最新的版本号可以看这里 <a href="https://dl.bintray.com/xujun94/maven/com/xj/android/anchortask/">lastedt version</a></p>
<p>第二步：自定义 AnchorTaskB，继承 AnchorTask，重写相应的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskB : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 在这里进行操作，这里通过睡眠模拟耗时操作</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        com.xj.anchortask.library.log.LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回依赖的任务，这里是通过 class name 去找到对应的 task</span><br><span class="line">    override fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;? &#123;</span><br><span class="line">        return ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;().apply &#123;</span><br><span class="line">            add(AnchorTaskA::class.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果任务 C 依赖任务 B，任务 A，可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskC : AnchorTask() &#123;</span><br><span class="line">   </span><br><span class="line">    override fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;? &#123;</span><br><span class="line">        return ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;().apply &#123;</span><br><span class="line">            add(AnchorTaskA::class.java)</span><br><span class="line">            add(AnchorTaskB::class.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，通过 <code>AnchorTaskDispatcher.instance .addTask(AnchorTaskFive())</code>  添加任务，并调用 start() 方法启动， await() 方法表示阻塞等待所有任务执行完毕。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnchorTaskDispatcher.instance.setContext(this).setLogLevel(LogUtils.LogLevel.DEBUG).setTimeOutMillion(1000L).</span><br><span class="line">            .addTask(AnchorTaskZero())</span><br><span class="line">            .addTask(AnchorTaskOne())</span><br><span class="line">            .addTask(AnchorTaskTwo())</span><br><span class="line">            .addTask(AnchorTaskThree())</span><br><span class="line">            .addTask(AnchorTaskFour())</span><br><span class="line">            .addTask(AnchorTaskFive())</span><br><span class="line">            .start()</span><br><span class="line">            .await()</span><br></pre></td></tr></table></figure>

<h2 id="AnchorTaskDispatcher-介绍"><a href="#AnchorTaskDispatcher-介绍" class="headerlink" title="AnchorTaskDispatcher 介绍"></a>AnchorTaskDispatcher 介绍</h2><ol>
<li><code>AnchorTaskDispatcher start</code> 方法必须在主线程调用，子线程调用会抛出异常。</li>
<li><code>setTimeOutMillion</code> 方法是配合 await() 方法使用的，单独调用没有任何效果，表示 await 等待的超时时间</li>
<li><code>await</code> 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走</li>
<li><code>await()</code> 方法必须在 start 方法之后调用</li>
<li><code>setThreadPoolExecutor</code> 设置 task 执行的线程池</li>
</ol>
<h2 id="AnchorTask-介绍"><a href="#AnchorTask-介绍" class="headerlink" title="AnchorTask 介绍"></a>AnchorTask 介绍</h2><p>AnchorTask 实现了 IAnchorTask 接口，主要有几个方法</p>
<ul>
<li><code>isRunOnMainThread(): Boolean</code> 表示是否在主线程运行，默认值是 false</li>
<li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li>
<li> <code> needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li>
<li> <code>fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</code> 方法返回前置任务依赖，默认值是返回 null.</li>
<li> <code> fun run()</code> 方法，表示任务执行的时候</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前任务的前置任务，可以用来确定顶点的入度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnchorTaskOne : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="监听任务的回调"><a href="#监听任务的回调" class="headerlink" title="监听任务的回调"></a>监听任务的回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val anchorTask &#x3D; AnchorTaskTwo()</span><br><span class="line">        anchorTask.addCallback(object : IAnchorCallBack &#123;</span><br><span class="line">            override fun onAdd() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onAdd: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onRemove() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onRemove: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onStart:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onFinish:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇博客介绍了 AnchorTask 的使用，<br>AnchorTask 源码已经更新到 github，<a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a>，下一篇，将输出 <strong>Android 启动优化（四）- 手把手教你实现 AnchorTask</strong>，敬请期待。</p>
<p>我的微信公众号<strong>程序员徐公</strong>，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动优化（一） - 有向无环图</title>
    <url>/2021/01/18/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%20-%20%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到 Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p>
<p>多线程异步加载方案确实是 ok 的。但如果遇到<strong>前后依赖</strong>的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p>
<p><em>最简单的方案是将任务1 丢到主线程加载，然后再启动多线程异步加载。</em></p>
<p>如果遇到更复杂的依赖呢。</p>
<p>任务3 依赖于任务 2， 任务 2 依赖于任务 1 呢，这时候你要怎么解决。更复杂的依赖关系呢</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p>
<p>总不能将任务 2，任务 3 都放到主线程加载吧，这样多线程加载的意义就不大了。</p>
<p>有没有更好的方案呢？</p>
<p><strong>答案肯定是有的，使用有向无环图。它可以完美解决先后依赖关系。</strong></p>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p><strong>有向无环图（Directed Acyclic Graph, DAG</strong>）是有向图的一种，字面意思的理解就是图中没有环。常常被用来表示事件之间的驱动依赖关系，管理任务之间的调度。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p>
<p><strong>顶点</strong>：图中的一个点，比如顶点 1，顶点 2。</p>
<p><strong>边</strong>：连接两个顶点的线段叫做边，edge。</p>
<p><strong>入度</strong>：代表当前有多少边指向它。</p>
<p>在上图中，顶掉 1 的入度是 0，因为没有任何边指向它。 顶掉 2 的入度是 1， 因为 顶掉 1 指向 顶掉 2. 同理可得出 5 的入度是 2，因为顶掉 4 和顶点 3 指向它</p>
<p><strong>拓扑排序</strong>：拓扑排序是对一个有向图构造拓扑序列的过程。它具有如下特点。</p>
<ul>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>
</ul>
<p>由于有这个特点，因此常常用有向无环图的数据结构用来解决依赖关系。</p>
<p>上图中，拓扑排序之后，任务2肯定排在任务1之后，因为任务2依赖 任务1， 任务3肯定在任务2之后，因为任务3依赖任务2。</p>
<p>拓扑排序一般有两种算法，第一种是入度表法，第二种是 DFS 方法。下面，让我们一起来看一下怎么实现它。</p>
<h2 id="入度表法"><a href="#入度表法" class="headerlink" title="入度表法"></a>入度表法</h2><p>入度表法是根据顶点的入度来判断是否有依赖关系的。若顶点的入度不为 0，则表示它有前置依赖。它也常常被称作 BFS 算法</p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>建立入度表，入度为 0 的节点先入队</li>
<li>当队列不为空，进行循环判断<ul>
<li>节点出队，添加到结果 list 当中</li>
<li>将该节点的邻居入度减 1</li>
<li>若邻居节点入度为 0，加入队列</li>
</ul>
</li>
<li>若结果 list 与所有节点数量相等，则证明不存在环。否则，存在环</li>
</ul>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>下图所示的有向无环图，采用入度表的方法获取拓扑排序过程。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p>
<p>首先，我们选择入度为 0 的顶点，这里顶点 1 的入度为 0，删除顶点 1 之后，图变成如下。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214904.png"></p>
<p>这时候，顶点 2 和顶点 4 的入度都为 0，我们可以随便删除一个顶点。（<strong>这也就是为什么图的拓扑排序不是唯一的原因</strong>）。这里我们删除顶点 2，图变成如下：</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214917.png"></p>
<p>这时候，我们再删除顶点 4，图变成如下：</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214928.png"></p>
<p>选择入度为 0 的顶点 3，删除顶点 3 之后，图标称如下，</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114215037.png"></p>
<p>最后剩余顶点5，输出顶点5，拓扑排序过程结束。最终的输出结果为：</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114215654.png"></p>
<p>到此，优先无环图的入度法的流程已经讲解完毕。你清楚了嘛。</p>
<p>代码的话，下期会一起给出。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>设 AOE 网有 n 个事件，e 个活动，则算法的主要执行是：</p>
<ul>
<li>求每个事件的ve值和vl值：时间复杂度是O(n+e) ；</li>
<li>根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；</li>
</ul>
<p>因此，整个算法的时间复杂度是O(n+e)</p>
<h2 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h2><p>从上面的入度表法，我们可以知道，要得到有向无环图的拓扑排序，我们的关键点要找到入度为 0 的顶点。然后接着删除该结点的相邻所有边。再遍历所有结点。直到入度为 0 的队列为空。这种方法其实是 BFS。</p>
<p>说到 BFS，我们第一时间就想到 DFS。<strong>与 BFS 不同的是，DFS 的关键点在于找到，出度为0的顶点。</strong></p>
<p>总结如下，深度优先搜索过程中，当到达出度为0的顶点时，需要进行回退。在执行回退时记录出度为0的顶点，将其入栈。则最终出栈顺序的逆序即为拓扑排序序列。</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>对图执行深度优先搜索。</li>
<li>在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。</li>
<li>最后得到栈中顺序的逆序即为拓扑排序顺序。</li>
</ul>
<h3 id="实例讲解-1"><a href="#实例讲解-1" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>同样，以下图讲解 DFS 算法的过程。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p>
<p>(1) 从顶点 1 开始出发，开始执行深度优先搜索。顺序为1-&gt;2-&gt;3-&gt;5。</p>
<p>（2）深度优先搜索到达顶点5时，顶点5出度为0。将顶点5入栈。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224006.png"></p>
<p>（3）深度优先搜索执行回退，回退至顶点3。此时顶点3的出度为0，将顶点3入栈。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224021.png"></p>
<p>（4）回退至顶点2，顶点2出度为0，顶点2入栈。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224230.png"></p>
<p>（5）回退至顶点1，顶点1可以前进位置为顶点4，顺序为1-&gt;4。</p>
<p>（6）顶点4出度为0，顶点4入栈。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224240.png"></p>
<p>（7）回退至顶点1，顶点1出度为0，顶点1入栈。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224247.png"></p>
<p>（8）栈的逆序为1-&gt;4-&gt;2-&gt;3-&gt;5。此顺序为拓扑排序结果。</p>
<p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224253.png"></p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度分析：首先深度优先搜索的时间复杂度为O(V+E)，而每次只需将完成访问的顶点存入数组中，需要O(1)，因而总复杂度为O(V+E)。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有向无环图的拓扑排序其实并不难，难度中等。通常，我们一般使用 BFS 算法来解决，DFS 算法比较少用。</p>
<p>对于 BFS（入度表法），它的核心思想是</p>
<ol>
<li>选择一个没有输入边（入度为0）的源顶点（若有多个则任选一个），</li>
<li>将它和它的输出边删除。重复源顶点的删除操作，直到不存在入度为0的源顶点为止。</li>
<li>最终，检测图中的顶点个数，若还有顶点存在则算法无解，否则顶点的删除顺序就是拓扑排序的输出顺序。</li>
</ol>
]]></content>
      <tags>
        <tag>Android 启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官， 怎样实现 Router 框架？</title>
    <url>/2019/07/18/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%20Router%20%E6%A1%86%E6%9E%B6%EF%BC%9F/</url>
    <content><![CDATA[<p>Android 开发中，组件化，模块化是一个老生常谈的问题。随着项目复杂性的增长，模块化是一个必然的趋势。除非你能忍受改一下代码，就需要六七分钟的漫长时间。</p>
<p>模块化，组件化随之带来的另外一个问题是页面的跳转问题，由于代码的隔离，代码之间有时候会无法互相访问。于是，路由（Router）框架诞生了。</p>
<p>目前用得比较多的有阿里的 ARouter，美团的 WMRouter，ActivityRouter 等。</p>
<p>今天，就让我们一起来看一下怎样实现一个路由框架。<br>实现的功能有。</p>
<ol>
<li>基于编译时注解，使用方便</li>
<li>结果回调，每次跳转 Activity 都会回调跳转结果</li>
<li>除了可以使用注解自定义路由，还支持手动分配路由</li>
<li>支持多模块使用，支持组件化使用</li>
</ol>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>第一步，在要跳转的 activity 上面注明 path，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Route(path &#x3D; &quot;activity&#x2F;main&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在要跳转的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;main&quot;).navigation(this);</span><br></pre></td></tr></table></figure>


<h3 id="如果想在多-moule-中使用"><a href="#如果想在多-moule-中使用" class="headerlink" title="如果想在多 moule 中使用"></a>如果想在多 moule 中使用</h3><p>第一步，使用 <code>@Modules(&#123;&quot;app&quot;, &quot;sdk&quot;&#125;)</code> 注明总共有多少个 moudle，并分别在 moudle 中注明当前 moudle 的 名字，使用 <code>@Module(&quot;&quot;)</code> 注解。注意 @Modules({“app”, “sdk”}) 要与 @Module(“”) 一一对应。</p>
<p>在主 moudle 中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Modules(&#123;&quot;app&quot;, &quot;moudle1&quot;&#125;)</span><br><span class="line">@Module(&quot;app&quot;)</span><br><span class="line">public class RouterApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        Router.getInstance().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 moudle1 中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Route(path &#x3D; &quot;my&#x2F;activity&#x2F;main&quot;)</span><br><span class="line">@Module(&quot;moudle1&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以支持多模块使用了。</p>
<h3 id="自定义注入-router"><a href="#自定义注入-router" class="headerlink" title="自定义注入 router"></a>自定义注入 router</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().add(&quot;activity&#x2F;three&quot;, ThreeActivity.class);</span><br></pre></td></tr></table></figure>

<p>跳转的时候调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;three&quot;).navigation(this);</span><br></pre></td></tr></table></figure>


<h3 id="结果回调"><a href="#结果回调" class="headerlink" title="结果回调"></a>结果回调</h3><p>路由跳转结果回调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().build(&quot;my&#x2F;activity&#x2F;main&quot;, new RouterCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean beforeOpen(Context context, Uri uri) &#123; </span><br><span class="line">    &#x2F;&#x2F; 在打开路由之前</span><br><span class="line">        Log.i(TAG, &quot;beforeOpen: uri&#x3D;&quot; + uri);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 在打开路由之后（即打开路由成功之后会回调）</span><br><span class="line">    @Override</span><br><span class="line">    public void afterOpen(Context context, Uri uri) &#123;</span><br><span class="line">        Log.i(TAG, &quot;afterOpen: uri&#x3D;&quot; + uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有找到改 uri</span><br><span class="line">    @Override</span><br><span class="line">    public void notFind(Context context, Uri uri) &#123;</span><br><span class="line">        Log.i(TAG, &quot;notFind: uri&#x3D;&quot; + uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发生错误</span><br><span class="line">    @Override</span><br><span class="line">    public void error(Context context, Uri uri, Throwable e) &#123;</span><br><span class="line">        Log.i(TAG, &quot;error: uri&#x3D;&quot; + uri + &quot;;e&#x3D;&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).navigation(this);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>startActivityForResult 跳转结果回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;two&quot;).navigation(this, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onActivityResult: requestCode&#x3D;&quot; + requestCode + &quot;;resultCode&#x3D;&quot; + resultCode + &quot;;data&#x3D;&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>实现一个 Router 框架，涉及到的主要的知识点如下：</p>
<ol>
<li>注解的处理</li>
<li>怎样解决多个 module 之间的依赖问题，以及如何支持多 module 使用</li>
<li>router 跳转及 activty startActivityForResult 的处理</li>
</ol>
<p>我们带着这三个问题，一起来探索一下。</p>
<p>总共分为四个部分,router-annotion, router-compiler,router-api,stub</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTIzMTYwMjA3LnBuZw?x-oss-process=image/format,png"></p>
<p>router-annotion 主要是定义注解的，用来存放注解文件</p>
<p>router-compiler 主要是用来处理注解的，自动帮我们生成代码</p>
<p>router-api 是对外的 api，用来处理跳转的。</p>
<p>stub 这个是存放一些空的 java 文件，提前占坑。不会打包进 jar。</p>
<h2 id="router-annotion"><a href="#router-annotion" class="headerlink" title="router-annotion"></a>router-annotion</h2><p>主要定义了三个注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Route &#123;</span><br><span class="line">    String path();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Modules &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Module &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Route 注解主要是用来注明跳转的 path 的。</p>
<p>Modules 注解，注明总共有多少个 moudle。</p>
<p>Module 注解，注明当前 moudle 的名字。</p>
<p>Modules，Module 注解主要是为了解决支持多 module 使用的。</p>
<hr>
<h2 id="router-compiler"><a href="#router-compiler" class="headerlink" title="router-compiler"></a>router-compiler</h2><p>router-compiler 只有一个类 RouterProcessor，他的原理其实也是比较简单的，扫描那些类用到注解，并将这些信息存起来，做相应的处理。这里是会生成相应的 java 文件。</p>
<p>主要包括以下两个步骤</p>
<ol>
<li>根据是否有 <code>@Modules</code> <code>@Module</code> 注解，然后生成相应的 <code>RouterInit</code> 文件</li>
<li>扫描 <code>@Route</code> 注解，并根据 <code>moudleName</code> 生成相应的 java 文件</li>
</ol>
<h3 id="注解基本介绍"><a href="#注解基本介绍" class="headerlink" title="注解基本介绍"></a>注解基本介绍</h3><p>在讲解 RouterProcessor 之前，我们先来了解一下注解的基本知识。</p>
<p>如果对于自定义注解还不熟悉的话，可以先看我之前写的这两篇文章。<a href="https://xujun.blog.csdn.net/article/details/70244169">Android 自定义编译时注解1 - 简单的例子</a>，<a href="https://blog.csdn.net/gdutxiaoxu/article/details/70822023">Android 编译时注解 —— 语法详解</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RouterProcessor extends AbstractProcessor &#123;</span><br><span class="line">    private static final boolean DEBUG &#x3D; true;</span><br><span class="line">    private Messager messager;</span><br><span class="line">    private Filer mFiler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">        messager &#x3D; processingEnv.getMessager();</span><br><span class="line">        mFiler &#x3D; processingEnv.getFiler();</span><br><span class="line">        UtilManager.getMgr().init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义你的注解处理器注册到哪些注解上</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; annotations &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(Route.class.getCanonicalName());</span><br><span class="line">        annotations.add(Module.class.getCanonicalName());</span><br><span class="line">        annotations.add(Modules.class.getCanonicalName());</span><br><span class="line">        return annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * java版本</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 首先我们先来看一下 <code>getSupportedAnnotationTypes</code> 方法,这个方法返回的是我们支持扫描的注解。</p>
<h3 id="注解的处理"><a href="#注解的处理" class="headerlink" title="注解的处理"></a>注解的处理</h3><p> 接下来我们再一起来看一下 <code>process</code> 方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">    &#x2F;&#x2F; 注解为 null，直接返回</span><br><span class="line">    if (annotations &#x3D;&#x3D; null || annotations.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UtilManager.getMgr().getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;process&quot;);</span><br><span class="line">    boolean hasModule &#x3D; false;</span><br><span class="line">    boolean hasModules &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; module</span><br><span class="line">    String moduleName &#x3D; &quot;RouterMapping&quot;;</span><br><span class="line">    Set&lt;? extends Element&gt; moduleList &#x3D; roundEnv.getElementsAnnotatedWith(Module.class);</span><br><span class="line">    if (moduleList !&#x3D; null &amp;&amp; moduleList.size() &gt; 0) &#123;</span><br><span class="line">        Module annotation &#x3D; moduleList.iterator().next().getAnnotation(Module.class);</span><br><span class="line">        moduleName &#x3D; moduleName + &quot;_&quot; + annotation.value();</span><br><span class="line">        hasModule &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; modules</span><br><span class="line">    String[] moduleNames &#x3D; null;</span><br><span class="line">    Set&lt;? extends Element&gt; modulesList &#x3D; roundEnv.getElementsAnnotatedWith(Modules.class);</span><br><span class="line">    if (modulesList !&#x3D; null &amp;&amp; modulesList.size() &gt; 0) &#123;</span><br><span class="line">        Element modules &#x3D; modulesList.iterator().next();</span><br><span class="line">        moduleNames &#x3D; modules.getAnnotation(Modules.class).value();</span><br><span class="line">        hasModules &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug(&quot;generate modules RouterInit annotations&#x3D;&quot; + annotations + &quot; roundEnv&#x3D;&quot; + roundEnv);</span><br><span class="line">    debug(&quot;generate modules RouterInit hasModules&#x3D;&quot; + hasModules + &quot; hasModule&#x3D;&quot; + hasModule);</span><br><span class="line">    &#x2F;&#x2F; RouterInit</span><br><span class="line">    if (hasModules) &#123; &#x2F;&#x2F; 有使用 @Modules 注解，生成 RouterInit 文件，适用于多个 moudle</span><br><span class="line">        debug(&quot;generate modules RouterInit&quot;);</span><br><span class="line">        generateModulesRouterInit(moduleNames);</span><br><span class="line">    &#125; else if (!hasModule) &#123; &#x2F;&#x2F; 没有使用 @Modules 注解，并且有使用 @Module，生成相应的 RouterInit 文件，使用与单个 moudle</span><br><span class="line">        debug(&quot;generate default RouterInit&quot;);</span><br><span class="line">        generateDefaultRouterInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 扫描 Route 注解</span><br><span class="line">    Set&lt;? extends Element&gt; elements &#x3D; roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">    List&lt;TargetInfo&gt; targetInfos &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Element element : elements) &#123;</span><br><span class="line">        System.out.println(&quot;elements &#x3D;&quot; + elements);</span><br><span class="line">        &#x2F;&#x2F; 检查类型</span><br><span class="line">        if (!Utils.checkTypeValid(element)) continue;</span><br><span class="line">        TypeElement typeElement &#x3D; (TypeElement) element;</span><br><span class="line">        Route route &#x3D; typeElement.getAnnotation(Route.class);</span><br><span class="line">        targetInfos.add(new TargetInfo(typeElement, route.path()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据 module 名字生成相应的 java 文件</span><br><span class="line">    if (!targetInfos.isEmpty()) &#123;</span><br><span class="line">        generateCode(targetInfos, moduleName);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>，首先判断是否有注解需要处理，没有的话直接返回 <code>annotations == null || annotations.size() == 0</code> 。</p>
<p> 接着我们会判断是否有 <code>@Modules</code> 注解（这种情况是多个 moudle 使用），有的话会调用 <code>generateModulesRouterInit(String[] moduleNames)</code> 方法生成 RouterInit java 文件，当没有 <code>@Modules</code> 注解，并且没有 <code>@Module</code> （这种情况是单个 moudle 使用），会生成默认的 RouterInit 文件。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> private void generateModulesRouterInit(String[] moduleNames) &#123;</span><br><span class="line">    MethodSpec.Builder initMethod &#x3D; MethodSpec.methodBuilder(&quot;init&quot;)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC);</span><br><span class="line">    for (String module : moduleNames) &#123;</span><br><span class="line">        initMethod.addStatement(&quot;RouterMapping_&quot; + module + &quot;.map()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeSpec routerInit &#x3D; TypeSpec.classBuilder(&quot;RouterInit&quot;)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(initMethod.build())</span><br><span class="line">            .build();</span><br><span class="line">    try &#123;</span><br><span class="line">        JavaFile.builder(Constants.ROUTE_CLASS_PACKAGE, routerInit)</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(mFiler);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设说我们有”app”,”moudle1” 两个 moudle，那么我们最终生成的代码是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RouterInit &#123;</span><br><span class="line">  public static final void init() &#123;</span><br><span class="line">    RouterMapping_app.map();</span><br><span class="line">    RouterMapping_moudle1.map();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们都没有使用 @Moudles 和 @Module 注解，那么生成的 RouterInit 文件大概是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class RouterInit &#123;</span><br><span class="line">  public static final void init() &#123;</span><br><span class="line">    RouterMapping.map();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也就是为什么有 stub module 的原因。因为默认情况下，我们需要借助 RouterInit 去初始化 map。如果没有这两个文件，ide 编辑器 在 compile 的时候就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compileOnly project(path: &#39;:stub&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTIzMTczODQzLnBuZw?x-oss-process=image/format,png"></p>
<p>我们引入的方式是使用 compileOnly，这样的话再生成 jar 的时候，不会包括这两个文件，但是可以在 ide 编辑器中运行。这也是一个小技巧。</p>
<h3 id="Route-注解的处理"><a href="#Route-注解的处理" class="headerlink" title="Route 注解的处理"></a>Route 注解的处理</h3><p>我们回过来看 process 方法连对 Route 注解的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 扫描 Route 自己注解</span><br><span class="line">Set&lt;? extends Element&gt; elements &#x3D; roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">List&lt;TargetInfo&gt; targetInfos &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for (Element element : elements) &#123;</span><br><span class="line">    System.out.println(&quot;elements &#x3D;&quot; + elements);</span><br><span class="line">    &#x2F;&#x2F; 检查类型</span><br><span class="line">    if (!Utils.checkTypeValid(element)) continue;</span><br><span class="line">    TypeElement typeElement &#x3D; (TypeElement) element;</span><br><span class="line">    Route route &#x3D; typeElement.getAnnotation(Route.class);</span><br><span class="line">    targetInfos.add(new TargetInfo(typeElement, route.path()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据 module 名字生成相应的 java 文件</span><br><span class="line">if (!targetInfos.isEmpty()) &#123;</span><br><span class="line">    generateCode(targetInfos, moduleName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会扫描所有的 Route 注解，并添加到 targetInfos list 当中，接着调用 <code>generateCode</code> 方法生成相应的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void generateCode(List&lt;TargetInfo&gt; targetInfos, String moduleName) &#123;</span><br><span class="line">      </span><br><span class="line">        MethodSpec.Builder methodSpecBuilder &#x3D; MethodSpec.methodBuilder(&quot;map&quot;)</span><br><span class="line">&#x2F;&#x2F;                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(Modifier.STATIC)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                .addParameter(parameterSpec);</span><br><span class="line">        for (TargetInfo info : targetInfos) &#123;</span><br><span class="line">            methodSpecBuilder.addStatement(&quot;com.xj.router.api.Router.getInstance().add($S, $T.class)&quot;, info.getRoute(), info.getTypeElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TypeSpec typeSpec &#x3D; TypeSpec.classBuilder(moduleName)</span><br><span class="line">&#x2F;&#x2F;                .addSuperinterface(ClassName.get(interfaceType))</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addMethod(methodSpecBuilder.build())</span><br><span class="line">                .addJavadoc(&quot;Generated by Router. Do not edit it!\n&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            JavaFile.builder(Constants.ROUTE_CLASS_PACKAGE, typeSpec)</span><br><span class="line">                    .build()</span><br><span class="line">                    .writeTo(UtilManager.getMgr().getFiler());</span><br><span class="line">            System.out.println(&quot;generateCode: &#x3D;&quot; + Constants.ROUTE_CLASS_PACKAGE + &quot;.&quot; + Constants.ROUTE_CLASS_NAME);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;generateCode:e  &#x3D;&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是使用 javapoet 生成 java 文件，关于 javaposet 的使用可以见<a href="https://github.com/square/javapoet">官网文档</a>,生成的 java 文件是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xj.router.impl;</span><br><span class="line"></span><br><span class="line">import com.xj.arounterdemo.MainActivity;</span><br><span class="line">import com.xj.arounterdemo.OneActivity;</span><br><span class="line">import com.xj.arounterdemo.TwoActivity;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Generated by Router. Do not edit it!</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RouterMapping_app &#123;</span><br><span class="line">  public static void map() &#123;</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;main&quot;, MainActivity.class);</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;one&quot;, OneActivity.class);</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;two&quot;, TwoActivity.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们定义的注解信息，最终都会调用 <code>Router.getInstance().add()</code> 方法存放起来。</p>
<hr>
<h2 id="router-api"><a href="#router-api" class="headerlink" title="router-api"></a>router-api</h2><p>这个 module 主要是多外暴露的 api，最主要的一个文件是 Router。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Router &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;ARouter&quot;;</span><br><span class="line"></span><br><span class="line">    private static final Router instance &#x3D; new Router();</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Class&lt;? extends Activity&gt;&gt; routeMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private boolean loaded;</span><br><span class="line"></span><br><span class="line">    private Router() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Router getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if (loaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        RouterInit.init();</span><br><span class="line">        loaded &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们想要初始化  Router 的时候，代用 init 方法即可。 init 方法会先判断是否初始化过，没有初始化过，会调用 RouterInit#init 方法区初始化。</p>
<p>而在 RouterInit#init 中，会调用 RouterMap_{@moduleName}#map 方法初始化，改方法又调用 <code>Router.getInstance().add()</code> 方法，从而完成初始化</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTU0NDAwLnBuZw?x-oss-process=image/format,png"></p>
<h3 id="router-跳转回调"><a href="#router-跳转回调" class="headerlink" title="router 跳转回调"></a>router 跳转回调</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RouterCallback &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在跳转 router 之前</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean beforeOpen(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在跳转 router 之后</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void afterOpen(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 没有找到改 router</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void notFind(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 跳转 router 错误</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param e</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void error(Context context, Uri uri, Throwable e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void navigation(Activity context, int requestCode, Callback callback) &#123;</span><br><span class="line">    beforeOpen(context);</span><br><span class="line">    boolean isFind &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        Activity activity &#x3D; (Activity) context;</span><br><span class="line">        Intent intent &#x3D; new Intent();</span><br><span class="line">        intent.setComponent(new ComponentName(context.getPackageName(), mActivityName));</span><br><span class="line">        intent.putExtras(mBundle);</span><br><span class="line">        getFragment(activity)</span><br><span class="line">                .setCallback(callback)</span><br><span class="line">                .startActivityForResult(intent, requestCode);</span><br><span class="line">        isFind &#x3D; true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        errorOpen(context, e);</span><br><span class="line">        tryToCallNotFind(e, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isFind) &#123;</span><br><span class="line">        afterOpen(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void tryToCallNotFind(Exception e, Context context) &#123;</span><br><span class="line">    if (e instanceof ClassNotFoundException &amp;&amp; mRouterCallback !&#x3D; null) &#123;</span><br><span class="line">        mRouterCallback.notFind(context, mUri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要看 navigation 方法，在跳转 activity 的时候，首先会会调用<br>beforeOpen 方法回调 RouterCallback#beforeOpen。接着 catch exception 的时候，如果发生错误，会调用 errorOpen 方法回调 RouterCallback#errorOpen 方法。同时调用 tryToCallNotFind 方法判断是否是 ClassNotFoundException，是的话回调 RouterCallback#notFind。</p>
<p>如果没有发生 eception，会回调 RouterCallback#afterOpen。</p>
<h3 id="Activity-的-startActivityForResult-回调"><a href="#Activity-的-startActivityForResult-回调" class="headerlink" title="Activity 的 startActivityForResult 回调"></a>Activity 的 startActivityForResult 回调</h3><p>可以看到我们的 Router 也是支持 startActivityForResult 的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;two&quot;).navigation(this, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onActivityResult: requestCode&#x3D;&quot; + requestCode + &quot;;resultCode&#x3D;&quot; + resultCode + &quot;;data&#x3D;&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它的实现原理其实很简单，是借助一个空白 fragment 实现的，原理的可以看我之前的这一篇文章。</p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果觉得效果不错的话，请到 github 上面 star， 谢谢。 <a href="https://github.com/gdutxiaoxu/Router">Router</a></p>
<p>我们的 Router 框架，流程大概是这样的。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTQ1NjA3LnBuZw?x-oss-process=image/format,png"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTU0NDAwLnBuZw?x-oss-process=image/format,png"></p>
<hr>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>看了上面的文章，文章一开头提到的三个问题，你懂了吗，欢迎在评论区留言评论。</p>
<ol>
<li>注解的处理</li>
<li>怎样解决多个 module 之间的依赖问题，以及如何支持多 module 使用</li>
<li>router 跳转及 activty startActivityForResult 的处理</li>
</ol>
<p>其实，现在很多 router 框架都借助 gradle 插件来实现。这样有一个好处，就是在多 moudle 使用的时候，我们只需要 <code>apply plugin</code> 就 ok,对外屏蔽了一些细节。但其实，他的原理跟我们上面的原理都是差不多的。</p>
<p>接下来，我也会写 gradle plugin 相关的文章，并借助 gradle 实现 Router 框架。有兴趣的话可以关注我的微信公众号，徐公码字，谢谢。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/68926515">java Type 详解</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/68947735">java 反射机制详解</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52017033">注解使用入门（一）</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/70244169">Android 自定义编译时注解1 - 简单的例子</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/70822023">Android 编译时注解 —— 语法详解</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71512754">带你读懂 ButterKnife 的源码</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/100998987">Android 点九图机制讲解及在聊天气泡中的应用</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/103263744">面试官，怎样实现 Router 框架？</a></p>
<p>扫一扫，欢迎关注我的微信公众号 <strong>stormjun94（徐公码字）</strong>， 目前是一名程序员，不仅分享 Android开发相关知识，同时还分享技术人成长历程，包括个人总结，职场经验，面试经验等，希望能让你少走一点弯路。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE4LzE2ZDQ0OGIwNzI4ZGQ3MTY?x-oss-process=image/format,png"></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官，https 真的安全吗，可以抓包吗，如何防止抓包</title>
    <url>/2019/05/18/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%B3%BB%E5%88%97%20-%20https%20%E7%9C%9F%E7%9A%84%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8A%93%E5%8C%85%E5%90%97%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%8A%93%E5%8C%85%E5%90%97/</url>
    <content><![CDATA[<p>@[toc]<br> <strong>往期文章</strong></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97885526">Android 面试必备 - http 与 https 协议</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97618598">Android 面试必备 - 计算机网络基本知识（TCP，UDP，Http，https）</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/98475465">Android 面试必备 - 线程</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/98896053">Android 面试必备 - JVM 及 类加载机制</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/99006458">Android 面试必备 - 系统、App、Activity 启动过程</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/107349652">面试官系列- 你真的了解 http 吗</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/107393249">面试官问， https 真的安全吗，可以抓包吗，如何防止抓包吗</a></p>
<p><strong><a href="https://github.com/gdutxiaoxu/Android_interview">Android_interview github 地址</a></strong></p>
<blockquote>
<p> 我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br> 我的掘金：<a href="https://juejin.im/user/58aa8508570c35006bbd9e03">https://juejin.im/user/58aa8508570c35006bbd9e03</a>  <br><br> github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br> 微信公众号：徐公码字(stormjun94)  <br><br> 知乎：<a href="https://www.zhihu.com/people/xujun94">https://www.zhihu.com/people/xujun94</a>  <br></p>
</blockquote>
<p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94),第一时间会在上面更新</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLWMxMmNjNGUyYjEwMWI5NGE?x-oss-process=image/format,png" alt="image"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间，2020 年已过去一大半了，2020 年很难，各企业裁员的消息蛮多的，降职，不发年终奖等等。2020 年确实是艰难的一年。然而生活总是要继续，时间不给你丧的机会！如果我们能坚持下来，不断提高自己，说不定会有新的机会。</p>
<p>面试中，网络（http， https， tcp， udp）， jvm， 类加载机制等这些基础的知识点是高频出现的，每个程序员都能说上好多。但不一定说到重点，以及理解背后的原理。</p>
<p>我在面试的过程中也经常被问到，于是总结记录了下来。千万不要小瞧这些基础，有时候，你算法，项目经验都过了，但是基础答得不太好。结果可能会通过，但这肯定会影响你的评级，这是特别吃亏的。所以，不如花点时间背一下，理解一下背后的原理。</p>
<p>举一个简单的例子， https 连接过程是怎样的，使用了了哪种加密方式，可以抓包吗，怎样防止抓包，你是否能够对答如下。</p>
<p>废话不多说，开始进入正文。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道，http 通信存在以下问题：</p>
<ul>
<li>通信使用明文可能会被窃听</li>
<li>不验证通信方的身份可能遭遇伪装</li>
<li>无法证明报文的完整型，可能已遭篡改</li>
</ul>
<p>使用 https 可以解决数据安全问题，但是你真的理解 https 吗？</p>
<p><strong>当面试官连续对你发出灵魂追问的时候，你能对答如流吗</strong></p>
<ol>
<li>什么是 https，为什么需要 https</li>
<li>https 的连接过程</li>
<li>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密</li>
<li>https 是绝对安全的吗</li>
<li>https 可以抓包吗</li>
</ol>
<p>如果你能对答自如，恭喜你，https 你已经掌握得差不多了，足够应付面试了。</p>
<h2 id="什么是-https"><a href="#什么是-https" class="headerlink" title="什么是 https"></a>什么是 https</h2><p>简单来说， https 是 http + ssl，对 http  通信内容进行加密，是HTTP的安全版，是使用TLS/SSL加密的HTTP协议</p>
<p>Https的作用：</p>
<ol>
<li>内容加密 建立一个信息安全通道，来保证数据传输的安全；</li>
<li>身份认证 确认网站的真实性</li>
<li>数据完整性 防止内容被第三方冒充或者篡改</li>
</ol>
<h3 id="什么是SSL"><a href="#什么是SSL" class="headerlink" title="什么是SSL"></a>什么是SSL</h3><p>SSL 由 Netscape 公司于1994年创建，它旨在通过Web创建安全的Internet通信。它是一种标准协议，用于加密浏览器和服务器之间的通信。它允许通过Internet安全轻松地传输账号密码、银行卡、手机号等私密信息。</p>
<p>SSL证书就是遵守SSL协议，由受信任的CA机构颁发的数字证书。</p>
<p>SSL/TLS的工作原理:</p>
<p>需要理解SSL/TLS的工作原理，我们需要掌握加密算法。加密算法有两种：对称加密和非对称加密：</p>
<p><strong>对称加密</strong>：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。</p>
<p><strong>非对称加密</strong>：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。</p>
<p>公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。相信大多程序员已经对这种算法很熟悉了：我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地.ssh目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。</p>
<p>公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。</p>
<h2 id="https-的连接过程"><a href="#https-的连接过程" class="headerlink" title="https 的连接过程"></a>https 的连接过程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTJhYTQyNTg5ZDY4YmMxODYucG5n?x-oss-process=image/format,png" alt="image.png"></p>
<p>https 的连接过程大概分为两个阶段，证书验证阶段和数据传输阶段</p>
<h3 id="证书验证阶段"><a href="#证书验证阶段" class="headerlink" title="证书验证阶段"></a>证书验证阶段</h3><p>大概分为三个步骤</p>
<ol>
<li>浏览器发起请求</li>
<li>服务器接收到请求之后，会返回证书，包括公钥</li>
<li>浏览器接收到证书之后，会检验证书是否合法，不合法的话，会弹出告警提示（怎样验证合法，下文会详细解析，这里先忽略）</li>
</ol>
<h3 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h3><p>证书验证合法之后</p>
<ol>
<li>浏览器会生成一个随机数，</li>
<li>使用公钥进行加密，发送给服务端</li>
<li>服务器收到浏览器发来的值，使用私钥进行解密</li>
<li>解析成功之后，使用对称加密算法进行加密，传输给客户端</li>
</ol>
<p>之后双方通信就使用第一步生成的随机数进行加密通信。</p>
<h2 id="https-的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计"><a href="#https-的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计" class="headerlink" title="https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计"></a>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计</h2><p>从上面我们可以知道，https 加密是采用对称加密和非对称机密一起结合的。</p>
<p>在证书验证阶段，使用非对称加密。<br>在数据传输阶段，使用对称机密。</p>
<p>这样设计有一个好处，能最大程度得兼顾安全效率。</p>
<p>在证书验证阶段，使用非对称加密，需要公钥和私钥，假如浏览器的公钥泄漏了，我们还是能够确保随机数的安全，因为加密的数据只有用私钥才能解密。这样能最大程度确保随机数的安全。</p>
<p>在内容传输阶段，使用对称机密，可以大大提高加解密的效率。</p>
<h3 id="内容传输为什么要使用对称机密"><a href="#内容传输为什么要使用对称机密" class="headerlink" title="内容传输为什么要使用对称机密"></a>内容传输为什么要使用对称机密</h3><ol>
<li>对称加密效率比较高</li>
<li>一对公私钥只能实现单向的加解密。只有服务端保存了私钥。如果使用非对称机密，相当于客户端必须有自己的私钥，这样设计的话，每个客户端都有自己的私钥，这很明显是不合理的，因为私钥是需要申请的。</li>
</ol>
<h2 id="https-是绝对安全的吗"><a href="#https-是绝对安全的吗" class="headerlink" title="https 是绝对安全的吗"></a>https 是绝对安全的吗</h2><p>不是绝对安全的，可以通过中间人攻击。</p>
<h3 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h3><p>中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<p>HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，拦截客户端的请求，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTM1ZjE1YzFhNjllZTZiMDYucG5n?x-oss-process=image/format,png" alt="image.png"></p>
<p>过程原理：</p>
<ol>
<li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向正规网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
</ol>
<p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p>
<h3 id="https-是如何防止中间人攻击的"><a href="#https-是如何防止中间人攻击的" class="headerlink" title="https 是如何防止中间人攻击的"></a>https 是如何防止中间人攻击的</h3><p>在https中需要证书，证书的作用是为了防止”中间人攻击”的。 如果有个中间人M拦截客户端请求,然后M向客户端提供自己的公钥，M再向服务端请求公钥,作为”中介者” 这样客户端和服务端都不知道,信息已经被拦截获取了。这时候就需要证明服务端的公钥是正确的.</p>
<p>怎么证明呢?</p>
<p>就需要权威第三方机构来公正了.这个第三方机构就是CA. 也就是说CA是专门对公钥进行认证，进行担保的，也就是专门给公钥做担保的担保公司。 全球知名的CA也就100多个，这些CA都是全球都认可的，比如VeriSign、GlobalSign等，国内知名的CA有WoSign。</p>
<h3 id="浏览器是如何确保CA证书的合法性？"><a href="#浏览器是如何确保CA证书的合法性？" class="headerlink" title="浏览器是如何确保CA证书的合法性？"></a>浏览器是如何确保CA证书的合法性？</h3><p>一、证书包含什么信息？</p>
<p>颁发机构信息、公钥、公司信息、域名、有效期、指纹……</p>
<p>二、证书的合法性依据是什么？</p>
<p>首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。</p>
<p>三、浏览器如何验证证书的合法性？</p>
<p>浏览器发起HTTPS请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p>
<ol>
<li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li>
<li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</li>
<li>判断证书是否被篡改。需要与CA服务器进行校验；</li>
<li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与CA服务器的交互，提高验证效率。</li>
</ol>
<p>以上任意一步都满足的情况下浏览器才认为证书是合法的。</p>
<h2 id="https-可以抓包吗"><a href="#https-可以抓包吗" class="headerlink" title="https 可以抓包吗"></a>https 可以抓包吗</h2><p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。</p>
<p>但是，我们可以通过抓包工具来抓包。它的原理其实是模拟一个中间人。</p>
<p>通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p>
<p>关于 httpps 抓包的原理可以看这一篇文章。</p>
<p><a href="https://juejin.im/post/5cc313755188252d6f11b463">Android平台HTTPS抓包解决方案及问题分析</a></p>
<p><strong>有人可能会问了，既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</strong></p>
<p>HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="如何防止抓包？"><a href="#如何防止抓包？" class="headerlink" title="如何防止抓包？"></a>如何防止抓包？</h3><p>对于HTTPS API接口，如何防止抓包呢？既然问题出在证书信任问题上，那么解决方法就是在我们的APP中预置证书。在TLS/SSL握手时，用预置在本地的证书中的公钥校验服务器的数字签名，只有签名通过才能成功握手。由于数字签名是使用私钥生成的，而私钥只掌握在我们手上，中间人无法伪造一个有效的签名，因此攻击失败，无法抓包。</p>
<p>同时，为了防止预置证书被替换，在证书存储上，可以将证书进行加密后进行「嵌入存储」，如嵌入在图片中或一段语音中。这涉及到信息隐写的领域，这个话题我们有空了详细说。</p>
<p>关于 Android 中Https 请求如何防止中间人攻击和Charles抓包，可以看一下这一篇文章。</p>
<p><a href="https://www.jianshu.com/p/1dd77e56cc3c">Android中Https请求如何防止中间人攻击和Charles抓包原理</a></p>
<h3 id="预置证书-公钥更新问题"><a href="#预置证书-公钥更新问题" class="headerlink" title="预置证书/公钥更新问题"></a>预置证书/公钥更新问题</h3><p>这样做虽然解决了抓包问题，但是也带来了另外一个问题：我们购买的证书都是有有效期的，到期前需要对证书进行更新。主要有两种方式：</p>
<p>提供预置证书更新接口。在当前证书快过期时，APP请求获取新的预置证书，这过渡时期，两个证书同时有效，直到安全完成证书切换。这种方式有一定的维护成本，且不易测试。<br>在APP中只预埋公钥，这样只要私钥不变，即使证书更新也不用更新该公钥。但是，这样不太符合周期性更新私钥的安全审计需求。一个折中的方法是，一次性预置多个公钥，只要任意一个公钥验证通过即可。考虑到我们的证书一般购买周期是3-5年，那么3个公钥，可以使用9-15年，同时，我们在此期间还可以发布新版本废弃老公钥，添加新公钥，这样可以使公钥一直更新下去。</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>开头说到的几个问题，你能对答如流了吗</p>
<ol>
<li>什么是 https，为什么需要 https</li>
<li>https 的连接过程</li>
<li>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密</li>
<li>https 是绝对安全的吗</li>
<li>https 可以抓包吗</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTU5YmRkYTdhMmU3OTQ1MDg?x-oss-process=image/format,png" alt="image"></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官，你真的了解 http 吗</title>
    <url>/2019/05/12/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%B3%BB%E5%88%97-%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20http%20%E5%90%97/</url>
    <content><![CDATA[<p>@[toc]</p>
<blockquote>
<p> 我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br> 我的掘金：<a href="https://juejin.im/user/58aa8508570c35006bbd9e03">https://juejin.im/user/58aa8508570c35006bbd9e03</a>  <br><br> github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br> 微信公众号：徐公码字(stormjun94)  <br><br> 知乎：<a href="https://www.zhihu.com/people/xujun94">https://www.zhihu.com/people/xujun94</a>  <br></p>
</blockquote>
<h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97885526">Android 面试必备 - http 与 https 协议</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97618598">Android 面试必备 - 计算机网络基本知识（TCP，UDP，Http，https）</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/98475465">Android 面试必备 - 线程</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/98896053">Android 面试必备 - JVM 及 类加载机制</a></p>
<p><a href="https://xujun.blog.csdn.net/article/details/99006458">Android 面试必备 - 系统、App、Activity 启动过程</a></p>
<p><strong><a href="https://github.com/gdutxiaoxu/Android_interview">Android_interview github 地址</a></strong></p>
<p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94),第一时间会在上面更新</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQyYmNkMjg?x-oss-process=image/format,png" alt="image"></p>
<h2 id="面试常见"><a href="#面试常见" class="headerlink" title="面试常见"></a>面试常见</h2><h3 id="一道经典的面试题"><a href="#一道经典的面试题" class="headerlink" title="一道经典的面试题"></a>一道经典的面试题</h3><p>还记得这道经典的面试题目吗？从 URL 在浏览器被被输入到页面展现的过程中发生了什么？</p>
<p>总体来说分为以下几个过程:</p>
<ul>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>完整的可以看以下下面的图片</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQxN2I1OGQ?x-oss-process=image/format,png" alt="image"></p>
<h2 id="http-必备基础知识"><a href="#http-必备基础知识" class="headerlink" title="http 必备基础知识"></a>http 必备基础知识</h2><p>HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQzYmYxNTk?x-oss-process=image/format,png" alt="image"></p>
<p>HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。</p>
<ul>
<li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。</li>
<li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。</li>
<li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</li>
</ul>
<h3 id="什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h3><p>无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p>
<p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。<br>如果你的浏览器允许 cookie 的话，查看方式 chrome://settings/content/cookies</p>
<h3 id="几种方法"><a href="#几种方法" class="headerlink" title="几种方法"></a>几种方法</h3><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</p>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</p>
<ul>
<li>GET: 通常用于请求服务器发送某些资源</li>
<li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</li>
<li>OPTIONS: 用于获取目的资源所支持的通信选项</li>
<li>POST: 发送数据给服务器，是<strong>非幂等</strong>的</li>
<li>PUT: 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST不需要置顶资源在服务器的位置，是<strong>幂等</strong>的</li>
<li>DELETE: 用于删除指定的资源</li>
<li>PATCH: 用于对资源进行部分修改</li>
<li>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
<h3 id="http-get-和-post-区别"><a href="#http-get-和-post-区别" class="headerlink" title="http get 和 post 区别"></a>http get 和 post 区别</h3><table>
<thead>
<tr>
<th>Post一般用于更新或者添加资源信息</th>
<th align="center">Get一般用于查询操作，而且应该是安全和幂等的</th>
</tr>
</thead>
<tbody><tr>
<td>Post更加安全</td>
<td align="center">Get会把请求的信息放到URL的后面</td>
</tr>
<tr>
<td>Post传输量一般无大小限制</td>
<td align="center">Get不能大于2KB</td>
</tr>
<tr>
<td>Post执行效率低</td>
<td align="center">Get执行效率略高</td>
</tr>
</tbody></table>
<h3 id="http-put-和-post-区别"><a href="#http-put-和-post-区别" class="headerlink" title="http put 和 post 区别"></a>http put 和 post 区别</h3><p><strong>举一个简单的例子</strong></p>
<p>POST:用于提交请求，可以更新或者创建资源，是非幂等的</p>
<p>举个例子，在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST</p>
<p>PUT: 用于向指定的URI传送更新资源，是幂等的</p>
<p>还是那个例子，用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码</p>
<p><strong>如果从 RESTful API 的角度来理解，PUT 方法是这么工作的：</strong></p>
<p>把一个对象 V 绑定到地址 K 上；今后请求地址 K 时，就会返回对象 V。</p>
<p>如果地址 K 之前曾绑定过另一个对象，比如 V0，那么 V0 会被 V 替换。</p>
<p>举一个简单的例子，假设我的博客后台支持 RESTful API，我可以通过下面的请求发布这篇文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT https:&#x2F;&#x2F;gdutxiao.github.io&#x2F;2018&#x2F;04&#x2F;16&#x2F;http-put-vs-post HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 文章内容正文 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，使用 PUT 方法时，客户端需要在 HTTP 请求中明确指定地址 K。</p>
<p>正如 Java 的例子一样，PUT 方法应当支持幂等性。如果是同一个对象 V，PUT 多次与 PUT 一次返回的结果应该是相同的。客户端可以利用 PUT 的幂等性安全地重试请求，保证客户端的请求至少被服务端处理一次。</p>
<p>如果把上面发布文章的例子用 HTTP POST 方法重写，它可能会是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST https:&#x2F;&#x2F;gdutxiao.github.io&#x2F;post-article HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 文章内容正文 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，地址 K 不是由客户端指定的，而是由服务端生成的。比如，服务端可能会根据日期和文章标题，为本文分配一个地址。</p>
<p>另外，与 PUT 方法不同，POST 方法是不支持幂等性的。同一个请求被处理两次，应当生成两份对象。换句话说，客户端应该只发送一次 POST 请求，而客户端的请求至多会被服务端处理一次。</p>
<blockquote>
<p>现在问题来了，如果真的遇到了网络故障，客户端应该如何重试 POST 请求呢？解决方法其实很简单，我们可以在 POST 请求中隐藏一个唯一的 token，服务端在处理请求后把 token 存入数据库，如果这个 token 之前遇到过，服务端就知道这是重复的 POST 请求，可以不再处理了。</p>
</blockquote>
<h2 id="http-版本"><a href="#http-版本" class="headerlink" title="http 版本"></a>http 版本</h2><h3 id="1-0-与-1-1"><a href="#1-0-与-1-1" class="headerlink" title="1.0 与 1.1"></a>1.0 与 1.1</h3><ul>
<li>http1.0一次只能处理一个请求，不能同时收发数据</li>
<li>http1.1可以处理多个请求，能同时收发数据</li>
<li>http1.1增加可更多字段，如cache-control,keep-alive.</li>
</ul>
<h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><ul>
<li>http 2.0采用二进制的格式传送数据，不再使用文本格式传送数据</li>
<li>http2.0对消息头采用hpack压缩算法，http1.x的版本消息头带有大量的冗余消息</li>
<li>http2.0 采用多路复用，即用一个tcp连接处理所有的请求，真正意义上做到了并发请求，流还支持优先级和流量控制（HTTP/1.x 虽然通过 pipeline也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。）</li>
<li>http2.0支持server push，服务端可以主动把css，jsp文件主动推送到客户端，不需要客户端解析HTML，再发送请求，当客户端需要的时候，它已经在客户端了。</li>
</ul>
<p><strong>缺点</strong></p>
<p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题， <strong>主要是底层支撑的 TCP 协议造成的</strong><br>。HTTP/2的缺点主要有以下几点：</p>
<ul>
<li>TCP 以及 TCP+TLS建立连接的延时</li>
</ul>
<p>HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，<br><strong>这样就需要有两个握手延迟过程</strong> ：</p>
<p>①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。</p>
<p>②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。</p>
<p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</p>
<ul>
<li>TCP的队头阻塞并没有彻底解决</li>
</ul>
<p>上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1<br>了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP<br>都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP<br>连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQ1MTVlNzg?x-oss-process=image/format,png" alt="image"></p>
<h3 id="Http-3-0"><a href="#Http-3-0" class="headerlink" title="Http 3.0"></a>Http 3.0</h3><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。<br>而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQ3MGZmZWM?x-oss-process=image/format,png" alt="image"></p>
<p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。</p>
<h4 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h4><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p>
<ul>
<li>实现了类似TCP的流量控制、传输可靠性的功能。</li>
</ul>
<p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p>
<ul>
<li>实现了快速握手功能。</li>
</ul>
<p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<br><strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong> 。</p>
<ul>
<li>集成了TLS加密功能。</li>
</ul>
<p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p>
<ul>
<li>多路复用，彻底解决TCP中队头阻塞的问题</li>
</ul>
<p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzUxNmVhMzc?x-oss-process=image/format,png" alt="image"></p>
<p>关于 http 3.0 的，如果想了解更多，可以查看这一篇文章。<a href="https://juejin.im/post/5d9abde7e51d4578110dc77f">解密HTTP/2与HTTP/3 的新特性</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</li>
<li>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</li>
</ul>
<h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><table>
<thead>
<tr>
<th>Http 状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求成功</td>
</tr>
<tr>
<td>206</td>
<td>支持断点下载（range = byte = 0 -1024)</td>
</tr>
<tr>
<td>301</td>
<td>永远移动</td>
</tr>
<tr>
<td>302</td>
<td>临时移动</td>
</tr>
<tr>
<td>303</td>
<td>See Other    查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>无更新</td>
</tr>
<tr>
<td>400</td>
<td>Bad request,服务器无法识别</td>
</tr>
<tr>
<td>403</td>
<td>禁止访问</td>
</tr>
<tr>
<td>404</td>
<td>not found</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed    客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error    服务器内部错误，无法完成请求</td>
</tr>
</tbody></table>
<p>关于更详细的可以查看 </p>
<p><a href="https://www.runoob.com/http/http-status-codes.html">http 状态码</a></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>下一篇预告，将会推出 面试官系列 - https 真的安全吗，可以抓包吗，如何防止抓包。</p>
<p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94）</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyYTE3NGY5ZWI?x-oss-process=image/format,png" alt="image"></p>
<p> <strong>目前从事于 Android 开发，除了分享 Android开发相关知识，还有职场心得，面试经验，学习心得，人生感悟等等。希望通过该公众号，让你看到程序猿不一样的一面，我们不只会敲代码，我们还会。。。。。。，期待你的参与</strong></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LiveData 源码分析</title>
    <url>/2019/01/14/Android%20livedata%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96/</url>
    <content><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p>
<p><strong>Android 技术人，一位不羁的码农。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/81273649f00c4d30340a268b8613286b.png" alt="Android 技术人"></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面三篇博客中，我们已经介绍了 lifecycle 的使用及原理，livedata ,ViewModel 的常用用法，今天，让我们一起来学习 livedata  的原理。</p>
<p>我们先来回顾一下 LiveData  的特点：</p>
<p>LiveData 是一个可以被观察的数据持有类，它可以感知 Activity、Fragment或Service 等组件的生命周期。</p>
<ol>
<li>它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI。</li>
<li>不用担心发生内存泄漏</li>
<li>当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。内部已经帮我们封装好了。</li>
<li>当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调 obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver</li>
</ol>
<p>下面，让我们一步步解剖它</p>
<hr>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我们知道 livedata 的使用很简单，它是采用观察者模式实现的</p>
<ol>
<li>添加观察者</li>
<li>在数据改变的时候设置 value，这样会回调 Observer 的 onChanged 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MutableLiveData&lt;<span class="built_in">String</span>&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="observe-方法"><a href="#observe-方法" class="headerlink" title="observe 方法"></a>observe 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">observe</span>(<span class="params">@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否已经销毁</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">	<span class="comment">// observer 已经添加过了，并且缓存的 observer 跟 owner 的 observer 不一致，状态异常，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 已经添加过 Observer 了，返回回去</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加 observer</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，我们先来看一下它的 observe 方法，首先通过 owner.getLifecycle().getCurrentState() 获取状态，判断是否已经被销毁，如果已经被销毁，直接返回。接着用 LifecycleBoundObserver 包装起来。然后从缓存的 mObservers 中读取 observer，如果有，证明已经添加过了。</p>
<p>observe 方法，小结起来就是</p>
<ol>
<li>判断是否已经销毁，如果销毁，直接移除</li>
<li>用 LifecycleBoundObserver 包装传递进来的 observer</li>
<li>是否已经添加过，添加过，直接返回</li>
<li>将包装后的 LifecycleBoundObserver 添加进去</li>
</ol>
<p>因此，当 owner 你（Activity 或者 fragment） 生命周期变化的时候，会回调 LifecycleBoundObserver 的 onStateChanged 方法，onStateChanged 方法又会回调  observer 的 onChange 方法</p>
<h3 id="LifecycleBoundObserver"><a href="#LifecycleBoundObserver" class="headerlink" title="LifecycleBoundObserver"></a>LifecycleBoundObserver</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="title">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    @NonNull final LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">LifecycleBoundObserver</span>(<span class="params">@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean <span class="function"><span class="title">shouldBeActive</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean <span class="function"><span class="title">isAttachedTo</span>(<span class="params">LifecycleOwner owner</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">void</span> <span class="function"><span class="title">detachObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来看一下 LifecycleBoundObserver，继承 ObserverWrapper，实现了 GenericLifecycleObserver 接口。而 GenericLifecycleObserver 接口又实现了 LifecycleObserver 接口。 它包装了我们外部的 observer，有点类似于代理模式。</p>
<p>GenericLifecycleObserver#onStateChanged</p>
<p>Activity 回调周期变化的时候，会回调 onStateChanged ，会先判断 mOwner.getLifecycle().getCurrentState() 是否已经 destroy 了，如果。已经 destroy，直接移除观察者。<strong>这也就是为什么我们不需要手动 remove observer 的原因</strong>。</p>
<p>如果不是销毁状态，会调用 activeStateChanged 方法 ，携带的参数为 shouldBeActive() 返回的值。<br>而当 lifecycle 的 state 为 started 或者 resume 的时候，shouldBeActive 方法的返回值为 true，即表示激活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">   <span class="comment">// owner</span></span><br><span class="line">   mActive = newActive;</span><br><span class="line">   <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">   LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">       onActive();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">       onInactive();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">       dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>activeStateChanged 方法中，，当 newActive 为 true，并且不等于上一次的值，会增加 LiveData 的 mActiveCount 计数。接着可以看到，onActive 会在 mActiveCount 为 1 时触发，onInactive 方法则只会在 mActiveCount 为 0 时触发。<strong>即回调 onActive 方法的时候活跃的 observer 恰好为 1，回调 onInactive 方法的时候，没有一个 Observer 处于激活状态。</strong></p>
<p>当 mActive 为 true 时，会促发 dispatchingValue 方法。</p>
<p>dispatchingValue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果正在处理，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// initiator 不为 null，调用 considerNotify 方法</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 为 null 的时候，遍历所有的 obsever，进行分发</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">	<span class="comment">// 分发完成，设置为 false</span></span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 mDispatchingValue, mDispatchInvalidated 只在 dispatchingValue 方法中使用，显然这两个变量是为了防止重复分发相同的内容。当 initiator 不为 null，只处理当前 observer，为 null 的时候，遍历所有的 obsever，进行分发</p>
<p>considerNotify 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果状态不是在活跃中，直接返回</span><br><span class="line">    if (!observer.mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Check latest state b4 dispatch. Maybe it changed state but we didn&#39;t get the event yet.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; we still first check observer.active to keep it as the entrance for events. So even if</span><br><span class="line">    &#x2F;&#x2F; the observer moved to an active state, if we&#39;ve not received that event, we better not</span><br><span class="line">    &#x2F;&#x2F; notify for a more predictable notification order.</span><br><span class="line">    if (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    if (observer.mLastVersion &gt;&#x3D; mVersion) &#123;</span><br><span class="line">	&#x2F;&#x2F; 数据已经是最新，返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 将上一次的版本号置为最新版本号</span><br><span class="line">    observer.mLastVersion &#x3D; mVersion;</span><br><span class="line">    &#x2F;&#x2F;noinspection unchecked</span><br><span class="line">	&#x2F;&#x2F; 调用外部的 mObserver 的 onChange 方法</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>  如果状态不是在活跃中，直接返回，这也就是为什么当我们的 Activity 处于 onPause， onStop， onDestroy 的时候，不会回调 observer 的 onChange 方法的原因。</li>
<li>  判断数据是否是最新，如果是最新，返回，不处理</li>
<li>数据不是最新，回调 mObserver.onChanged 方法。并将 mData 传递过去</li>
</ol>
<h3 id="setValue"><a href="#setValue" class="headerlink" title="setValue"></a>setValue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">setValue</span>(<span class="params">T value</span>)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setValue 方法中，首先，断言是主线程，接着  mVersion + 1; 并将 value 赋值给 mData，接着调用 dispatchingValue 方法。dispatchingValue 传递 null，代表处理所有 的 observer。</p>
<p><strong>这个时候如果我们依附的 activity 处于 onPause 或者 onStop 的时候，虽然在 dispatchingValue 方法中直接返回，不会调用 observer 的 onChange 方法。但是当所依附的 activity 重新回到前台的时候，会促发  LifecycleBoundObserver onStateChange 方法，onStateChange 又会调用 dispatchingValue 方法，在该方法中，因为 mLastVersion &lt; mVersion。所以会回调 obsever 的 onChange 方法，这也就是 LiveData 设计得比较巧妙的一个地方</strong></p>
<p>同理，当 activity 处于后台的时候，您多次调用 livedata 的 setValue 方法，最终只会回调 livedata observer 的 onChange 方法一次。</p>
<h3 id="postValue"><a href="#postValue" class="headerlink" title="postValue"></a>postValue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">postValue</span>(<span class="params">T value</span>)</span> &#123;</span><br><span class="line">   boolean postTask;</span><br><span class="line">   <span class="comment">// 锁住</span></span><br><span class="line">   synchronized (mDataLock) &#123;</span><br><span class="line">      <span class="comment">// 当前没有人在处理 post 任务</span></span><br><span class="line">       postTask = mPendingData == NOT_SET;</span><br><span class="line">       mPendingData = value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   AppToolkitTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line">private final Runnable mPostValueRunnable = <span class="keyword">new</span> <span class="function"><span class="title">Runnable</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">Object</span> newValue;</span><br><span class="line">       synchronized (mDataLock) &#123;</span><br><span class="line">           newValue = mPendingData;</span><br><span class="line">		   <span class="comment">// 处理完毕之后将 mPendingData 置为 NOT_SET</span></span><br><span class="line">           mPendingData = NOT_SET;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//noinspection unchecked</span></span><br><span class="line">       setValue((T) newValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，采用同步机制，通过 postTask = mPendingData == NOT_SET 有没有人在处理任务。 true，没人在处理任务， false ，有人在处理任务，有人在处理任务的话，直接返回</li>
<li>调用  AppToolkitTaskExecutor.getInstance().postToMainThread 到主线程执行 mPostValueRunnable 任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">    AlwaysActiveObserver wrapper = <span class="keyword">new</span> AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing <span class="keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AlwaysActiveObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为 AlwaysActiveObserver 没有实现 GenericLifecycleObserver 方法接口，所以在 Activity o生命周期变化的时候，不会回调 onStateChange 方法。从而也不会主动 remove 掉 observer。因为我们的 obsever 被 remove 掉是依赖于 Activity 生命周期变化的时候，回调 GenericLifecycleObserver 的 onStateChange 方法。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>liveData 当我们 addObserver 的时候，会用 LifecycleBoundObserver 包装 observer，而 LifecycleBoundObserver 可以感应生命周期，当 activity 生命周期变化的时候，如果不是处于激活状态，判断是否需要 remove 生命周期，需要 remove，不需要，直接返回</li>
<li>当处于激活状态的时候，会判断是不是 mVersion最新版本，不是的话需要将上一次缓存的数据通知相应的 observer，并将 mLastVsersion 置为最新</li>
<li>当我们调用 setValue 的时候，mVersion +1，如果处于激活状态，直接处理，如果不是处理激活状态，返回，等到下次处于激活状态的时候，在进行相应的处理</li>
<li>如果你想 livedata setValue 之后立即回调数据，而不是等到生命周期变化的时候才回调数据，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。因为 AlwaysActiveObserver 没有实现 GenericLifecycleObserver 接口，不能感应生命周期。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6010e8b1224400ad1cf93012b51df699.png"></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Android  Architecture Components    已经写了四篇文章了，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后再更新了，欢迎关注我的公众号，有更新的话会第一时间在公众好上面更新。</p>
]]></content>
      <tags>
        <tag>Android LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LiveData 使用详解</title>
    <url>/2019/01/13/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p>
<p>目录大概如下</p>
<blockquote>
<p>1 LiveData 基本使用<br>2 自定义 Livedata<br>3  Livedata 共享数据<br>4 Livedata  小结</p>
</blockquote>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p>
<p><strong>程序员徐公，一位不羁的码农。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e6df41528ff27a085a266dd18b707a8.png"></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博客中，我们讲解了 lifecycle 的使用及优点。这篇博客让我们一起来了解一下 LiveData 是怎样使用的？</p>
<hr>
<h2 id="为什么要引进-LiveData"><a href="#为什么要引进-LiveData" class="headerlink" title="为什么要引进 LiveData"></a>为什么要引进 LiveData</h2><p>LiveData 是一个可以被观察的数据持有类，它可以感知 Activity、Fragment或Service 等组件的生命周期。简单来说，他主要有一下优点。</p>
<ol>
<li><strong>它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI</strong>。</li>
<li><strong>不用担心发生内存泄漏</strong></li>
<li><strong>当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。它已经帮我们封装好了</strong>。</li>
<li>当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调  obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。</li>
</ol>
<p>回想一下，在你的项目中，是不是经常会碰到这样的问题，当网络请求结果回来的时候，你经常需要判断 Activity 或者 Fragment 是否已经 Destroy， 如果不是 destroy，才更新 UI。</p>
<p>而当你如果使用 Livedata 的话，因为它是在 Activity 处于 onStart 或者 onResume 的状态时，他才会进行相应的回调，因而可以很好得处理这个问题，不必写一大堆的 activity.isDestroyed()。接下来，让我们一起来看一下 LiveData  的使用</p>
<hr>
<h2 id="LiveData-使用"><a href="#LiveData-使用" class="headerlink" title="LiveData 使用"></a>LiveData 使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>引入相关的依赖包</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModel and LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:viewmodel:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:livedata:1.1.0&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在代码中使用</li>
</ol>
<p>LiveData 是一个抽象类，它的实现子类有 <strong>MutableLiveData</strong> ，<strong>MediatorLiveData</strong>。在实际使用中，用得比较多的是 MutableLiveData。他常常结合 ViewModel 一起使用。下面，让我们一起来看一下怎样使用它？</p>
<p>首先，我们先写一个类继承我们的 ViewModel，里面持有 mNameEvent。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private MutableLiveData&lt;<span class="built_in">String</span>&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MutableLiveData&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">getNameEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们在 Activity 中创建  ViewModel，并监听 ViewModel 里面 mNameEvent 数据的变化，当数据改变的时候，我们打印相应的 log，并设置给 textView，显示在界面上。这样我们就完成了对 mNameEvent 数据源的观察。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mTestViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;String&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> String s)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后当我们数据源改变的时候，我们需要调用 livedata 的 setValue 或者 postvalue 方法。他们之间的区别是， 调用 setValue 方法，Observer 的 onChanged 方法会在调用 serValue 方法的线程回调。而<br>postvalue 方法，Observer 的 onChanged 方法将会在主线程回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mTestViewModel.getNameEvent().setValue(name);</span><br></pre></td></tr></table></figure>

<p>可能部分同学有这样的疑问了，<strong>我们的 ViewModel 是通过 ViewModelProviders.of(this).get(TestViewModel.class); 方法创建出来的，如果我们要携带参数，怎么办？</strong></p>
<p>其实，官方也替我们考虑好了，同样是调用 ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) 方法，只不过，需要多传递一个 factory 参数。</p>
<p>Factory 是一个接口，它只有一个 create 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a newly created ViewModel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际当中，我们的做法是：实现 Factory 接口，重写 create 方法，在create 方法里面调用相应的构造函数，返回相应的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mKey;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;String&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getNameEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestViewModel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        mKey = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String mKey;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            mKey = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> TestViewModel(mKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewModelProviders.of(this, new TestViewModel.Factory(mkey)).get(TestViewModel.class)</p>
<hr>
<h2 id="自定义-Livedata"><a href="#自定义-Livedata" class="headerlink" title="自定义 Livedata"></a>自定义 Livedata</h2><p>Livedata 主要有几个方法</p>
<ol>
<li>observe</li>
<li>onActive</li>
<li>onInactive </li>
<li>observeForever </li>
</ol>
<p> void observe (LifecycleOwner owner,     Observer<T> observer)</p>
<blockquote>
<p>Adds the given observer to the observers list within the lifespan of the given owner. The events are dispatched on the main thread. If LiveData already has data set, it will be delivered to the observer.</p>
</blockquote>
<p>void onActive ()</p>
<blockquote>
<p>Called when the number of active observers change to 1 from 0.<br>This callback can be used to know that this LiveData is being used thus should be kept up to date.</p>
</blockquote>
<p>当回调该方法的时候，表示该 liveData 正在背使用，因此应该保持最新</p>
<p> void onInactive ()</p>
<blockquote>
<p>Called when the number of active observers change from 1 to 0.<br>This does not mean that there are no observers left, there may still be observers but their lifecycle states aren’t STARTED or RESUMED (like an Activity in the back stack).<br>You can check if there are observers via hasObservers().</p>
</blockquote>
<p>当该方法回调时，表示他所有的 obervers 没有一个状态处理 STARTED 或者 RESUMED，注意，这不代表没有 observers。</p>
<p>Void observeForever </p>
<p>跟 observe 方法不太一样的是，它在 Activity 处于 onPause ，onStop， onDestroy 的时候，都可以回调 obsever 的 onChange 方法，但是有一点需要注意的是，我们必须手动 remove obsever，否则会发生内存泄漏。</p>
<p>这里我们以观察网络状态变化为例子讲解</p>
<ol>
<li>首先我们自定义一个 Class NetworkLiveData，继承 LiveData，重写它的 onActive 方法和 onInactive 方法</li>
<li>在 onActive 方法中，我们注册监听网络变化的广播，即ConnectivityManager.CONNECTIVITY_ACTION。在 onInactive 方法的时候，我们注销广播。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">NetworkInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">static</span> NetworkLiveData mNetworkLiveData;</span><br><span class="line">    <span class="keyword">private</span> NetworkReceiver mNetworkReceiver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntentFilter mIntentFilter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;NetworkLiveData&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetworkLiveData</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        mNetworkReceiver = <span class="keyword">new</span> NetworkReceiver();</span><br><span class="line">        mIntentFilter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkLiveData <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mNetworkLiveData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNetworkLiveData = <span class="keyword">new</span> NetworkLiveData(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mNetworkLiveData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onActive:&quot;</span>);</span><br><span class="line">        mContext.registerReceiver(mNetworkReceiver, mIntentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInactive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onInactive: &quot;</span>);</span><br><span class="line">        mContext.unregisterReceiver(mNetworkReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            ConnectivityManager manager = (ConnectivityManager) context</span><br><span class="line">                    .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            NetworkInfo activeNetwork = manager.getActiveNetworkInfo();</span><br><span class="line">            getInstance(context).setValue(activeNetwork);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当我们想监听网络变化的时候，我们只需要调用相应的 observe 方法即可，方便又快捷。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">NetworkLiveData.getInstance(<span class="built_in">this</span>).observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;NetworkInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable NetworkInfo networkInfo</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: networkInfo=&quot;</span> +networkInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.jianshu.com/p/4b7945475a6f">https://www.jianshu.com/p/4b7945475a6f</a></p>
<h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><h3 id="Fragment-Activity-之间共享数据"><a href="#Fragment-Activity-之间共享数据" class="headerlink" title="Fragment Activity 之间共享数据"></a>Fragment Activity 之间共享数据</h3><p>我们回过头来再来看一下 ViewModelProvider 的 of 方法，他主要有四个方法，分别是</p>
<ol>
<li>ViewModelProvider of(@NonNull Fragment fragment)</li>
<li>ViewModelProvider of(@NonNull FragmentActivity activity)</li>
<li>ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory)</li>
<li> ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory)</li>
</ol>
<p>1,2 方法之间的主要区别是传入 Fragment 或者 FragmentActivity。而我们知道，通过 ViewModel of 方法创建的 ViewModel 实例， 对于同一个 fragment 或者 fragmentActivity 实例，ViewModel 实例是相同的，因而我们可以利用该特点，在 Fragment 中创建  ViewModel  的时候，传入的是 Fragment 所依附的 Activity。因而他们的 ViewModel 实例是相同的，从而可以做到共享数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// LiveDataSampleActivity(TestFragment 依赖的 Activity）</span></span><br><span class="line">mTestViewModel = ViewModelProviders.of(<span class="built_in">this</span>, <span class="keyword">new</span> TestViewModel.Factory(mkey)).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;<span class="built_in">String</span>&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestFragment 中</span></span><br><span class="line">mViewModel = ViewModelProviders.of(mActivity).get(TestViewModel.class);</span><br><span class="line">mViewModel.getNameEvent().observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s =&quot;</span> + s + <span class="string">&quot; mViewModel.getKey() =&quot;</span> + mViewModel.getKey());</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">        boolean result = mViewModel == ((LiveDataSampleActivity) mListener).mTestViewModel;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s result =&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，LiveDataSampleActivity 和 TestFragment 中的 ViewModel 是同一个实例。即 Activity 和 Fragment 共享数据。</p>
<h3 id="全局共享数据"><a href="#全局共享数据" class="headerlink" title="全局共享数据"></a>全局共享数据</h3><p>说到全局共享数据，我们想一下我们的应用全景，比如说我的账户数据，这个对于整个 App 来说，肯定是全局共享的。有时候，当我们的数据变化的时候，我们需要通知我们相应的界面，刷新 UI。如果用传统的方式来实现，那么我们一般才采取观察者的方式来实现，这样，当我们需要观察数据的时候，我们需要添加 observer，在界面销毁的时候，我们需要移除 observer。</p>
<p>但是，如果我们用 LiveData 来实现的话，它内部逻辑都帮我们封装好了，我们只需要保证 AccountLiveData 是单例的就ok，在需要观察的地方调用 observer 方法即可。也不需要手动移除 observer，不会发生内存泄漏，方便快捷。</p>
<p>这里 AccountLiveData 的实现就不贴出来了，可以参考上面的 NetworkLiveData 实现</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里说一点关于 LiveData 与 ViewModel 的应用场景，我尽量说得通俗一点，不要说得那么官方，这样对新手很难理解。</p>
<p>觉得不错的，请点个赞，让我们看到你们的欢呼声。你们的支持就是我写作的最大动力。</p>
<ol>
<li> LiveData 内部已经实现了观察者模式，如果你的数据要同时通知几个界面，可以采取这种方式</li>
<li> 我们知道 LiveData 数据变化的时候，会回调 Observer 的 onChange 方法，但是回调的前提是 lifecycleOwner（即所依附的 Activity 或者 Fragment） 处于 started 或者 resumed 状态，它才会回调，否则，必须等到 lifecycleOwner 切换到前台的时候，才回调。</li>
<li>因此，这对性能方面确实是一个不小的提升。但是，对于你想做一些类似与在后台工作的（黑科技）， liveData 就不太适合了，你可以使用 observeForever  方法，或者自己实现观察者模式去吧。</li>
</ol>
<p><strong>Lifecycle，LiveData， ViewModel 的基本使用到此已经讲解完毕，想了解他们的实现原理的话可以阅读这两篇文章。</strong></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p>
<p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>Android LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title>Android lifecyle 源码解剖</title>
    <url>/2019/01/12/Android%20lifecyle%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96/</url>
    <content><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p>
<p><strong>徐公码字，一位不羁的码农。</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC84LzE2ZGFhZTAwZDUyNmMxNTM?x-oss-process=image/format,png"></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇博客，我们已经讲解了 lifecycle ，liveData， ViewModel 的使用，这一篇博客，让我们一起来看一下 lifecycle 的原理。</p>
<hr>
<h2 id="从自定义的-lifecycle-说起"><a href="#从自定义的-lifecycle-说起" class="headerlink" title="从自定义的 lifecycle 说起"></a>从自定义的 lifecycle 说起</h2><p>首先我们先来复习一下，如果要自定义 lifecycle，我们要这样做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomLifecycleActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="title">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;CustomLifecycleActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_custom_lifecycle);</span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="built_in">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event = &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.RESUMED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.DESTROYED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle <span class="function"><span class="title">getLifecycle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>第一步:先实现  LifecycleOwner 接口，并返回 mLifecycleRegistry</li>
<li>第二步：在 Activity 生命周期变化的时候，调用   mLifecycleRegistry.markState() 方法标记相应的状态</li>
<li>如果想添加 observer，调用 addObserver 方法添加观察者，这样会在 activity 生命周期变化的时候，回调 observer 的 onchange 方法。</li>
</ol>
<p>我们先来看一下 getLifecycle() 方法， getLifecycle() 它返回的是一个 Lifecycle 的实例，sdk 中默认的实现类为 LifecycleRegistry。</p>
<p>接下来，我们一起来看一下它的 observer 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断是否是 DESTROYED，如果是将初始状态置为 DESTROYED，否则为 INITIALIZED</span><br><span class="line">    State initialState &#x3D; mState &#x3D;&#x3D; DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line"> &#x2F;&#x2F; ObserverWithState 包装</span><br><span class="line">    ObserverWithState statefulObserver &#x3D; new ObserverWithState(observer, initialState);</span><br><span class="line">	&#x2F;&#x2F;  将 observer 作为key，在缓存的 mObserverMap 中查找是否存在</span><br><span class="line">    ObserverWithState previous &#x3D; mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F; 存在，直接返回回去，证明该 observer 已经添加过了。否则，证明还没有添加过该 observer</span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	 </span><br><span class="line">    LifecycleOwner lifecycleOwner &#x3D; mLifecycleOwner.get();</span><br><span class="line">    if (lifecycleOwner &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; it is null we should be destroyed. Fallback quickly</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里 mAddingObserverCounter 为 0 ，mHandlingEvent 为 false</span><br><span class="line">    boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">    State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        &#x2F;&#x2F; mState &#x2F; subling may have been changed recalculate</span><br><span class="line">        targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isReentrance) &#123;</span><br><span class="line">        &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 addObserver 方法中，它主要干这几件事情</p>
<ol>
<li>首先，先初始化状态， 判断当前 mState 是否是 DESTROYED，如果是将初始状态置为 DESTROYED，否则为 INITIALIZED，接着用 ObserverWithState 包装 observer 和 初始化状态 initialState</li>
<li> 将 observer 作为 key，在缓存的 mObserverMap 中查找是否存在，如果存在，证明该 observer 已经添加过，直接返回回去，不必再进行处理。</li>
<li> addObserver 方法中第 21 行 ， isReentrance 一般情况下为 false，什么情况 为 true，暂时未想到，</li>
</ol>
<p>接下来我们先来看 calculateTargetState 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private State calculateTargetState(LifecycleObserver observer) &#123;</span><br><span class="line">   &#x2F;&#x2F; 取出 mObserverMap 的上一个 entry，previous</span><br><span class="line">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous &#x3D; mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果不为空，获取它的状态</span><br><span class="line">    State siblingState &#x3D; previous !&#x3D; null ? previous.getValue().mState : null;</span><br><span class="line">	&#x2F;&#x2F; 判断 mParentStates 是否为 null，不为 null，去最后的一个状态，否则，为 null</span><br><span class="line">    State parentState &#x3D; !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)</span><br><span class="line">            : null;</span><br><span class="line">    &#x2F;&#x2F; 取最小的状态</span><br><span class="line">    return min(min(mState, siblingState), parentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先，取出 mObserverMap 中上一个的 entry，该 LifecycleRegistry 实例如果是第一次调用 addObserver 实例的话，那么是 null，否则是上一个 observer 的 entry</li>
<li>根据 previous 是否为 null，设置 siblingState 的值</li>
<li>判断 mParentStates 是否为 null，不为 null，取 mParentStates 最后一次的状态</li>
<li>取 mState, siblingState 最小的状态 a，再取  a 与 parentState 的状态 b</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">   </span><br><span class="line">    DESTROYED,</span><br><span class="line"></span><br><span class="line">    INITIALIZED,</span><br><span class="line"></span><br><span class="line">    CREATED,</span><br><span class="line"></span><br><span class="line">    STARTED,</span><br><span class="line"></span><br><span class="line">    RESUMED;</span><br><span class="line"></span><br><span class="line">    public boolean isAtLeast(@NonNull State state) &#123;</span><br><span class="line">        return compareTo(state) &gt;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>State 中，他们排序的顺序是 DESTROYED &lt; INITIALIZED &lt; CREATED &lt; STARTED &lt; RESUMED。</p>
<p>我们知道，我们在 activity 的 onCreate 方法中初始化 LifecycleRegistry，并标记它的状态为 CREATED。当我们第一次在 onCreate 方法调用 addObserver 的时候，在 calculateTargetState 方法中，若是首次调用 previous 为 null，则 siblingState，parentState 为 null， 而 mState 为 CREATED，所以最终的状态为 CREATED，即 State targetState = calculateTargetState(observer); 中 targetState 为 CREATED</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取最小的状态</span></span><br><span class="line"><span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br></pre></td></tr></table></figure>

<p>看完 calculateTargetState 方法，我们回过头再来看一下 addObserver 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">     &#x2F;&#x2F; 省略若干行</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里 mAddingObserverCounter 为 0 ，mHandlingEvent 为 false</span><br><span class="line">    boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">    State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        &#x2F;&#x2F; mState &#x2F; subling may have been changed recalculate</span><br><span class="line">        targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isReentrance) &#123;</span><br><span class="line">        &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里 statefulObserver.mState 为 DESTROYED 或者 INITIALIZED，肯定比  CREATED 小。而 mObserverMap.contains(observer) 必定为 true，除非我们手动移除掉 mObserverMap。因而，会走进 while循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushParentState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    mParentStates.add(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>pushParentState(statefulObserver.mState);  很简单，只是将 statefulObserver 的状态添加到 mParentStates 集合中。</p>
<p>继续往下走，接着会调用  statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_START;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected state value &quot;</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>upEvent 方法也很简单，只是返回它的下一个 event。这里因为他们的 state为 INITIALIZED，所以它会返回 ON_CREATE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected event value &quot;</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里 event 为 ON_CREATE，所以 newState 也为 CREATED。   mState = min(mState, newState); mState newState，两者状态相同，所以 mState 也为 CREATED。接着回调 mLifecycleObserver 的 onStateChanged 方法。所以，这里，会收到我们的 onCreate 事件，与我们的预想相符。</p>
<p><strong>但是我们并没有在 onStart，onResume, onPause , onStop 和 onDestroy 方法中调用 mLifecycleRegistry.handleLifecycleEvent 方法，它又是怎样促发 Observer 的 onStateChanged 方法的。这里先不揭晓，我们先来看一下 26.1.0 以后的 AppCompatActivity，待会你就明白了，会感叹 google 真的牛逼！</strong></p>
<hr>
<h2 id="从-26-1-0-以后-AppCompatActivity-的设计说起"><a href="#从-26-1-0-以后-AppCompatActivity-的设计说起" class="headerlink" title="从 26.1.0 以后 AppCompatActivity 的设计说起"></a>从 26.1.0 以后 AppCompatActivity 的设计说起</h2><p> 我们知道，在 26.1.0 以后，如果我们要使用 lifecycle，我们只需要调用以下的方法即可。</p>
<h3 id="SupportActivity"><a href="#SupportActivity" class="headerlink" title="SupportActivity"></a>SupportActivity</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟踪 getLifecycle() 方法，它会跳转到 SupportActivity 的 getLifecycle 方法 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span>, <span class="title">Component</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SupportActivity 中，它默认为我们初始化 mLifecycleRegistry，作为一个成员变量。接着，他在<br>onCreate 方法中调用了  ReportFragment.injectIfNeededIn(this); 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 injectIfNeededIn 方法中，它会判断我们是否已经添加 ReportFragment，没有的话，添加进去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchCreate</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchStart</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchResume</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onActivityCreated</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onPause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>然后，它在 onCreat ，onStart， onResume， onPause， onStop， onDestroy 方法中分别调用 dispatch 方法进行分发生命周期。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">dispatch</span>(<span class="params">Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 dispatch 方法中，会先判断 activity 是不是实现了 LifecycleRegistryOwner ，如果是，直接分发，不过不是，判断是否实现 LifecycleOwner，获取它的 lifecycle，调用它 的 handleLifecycleEvent 进行分发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span>, <span class="title">Component</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<p>而很明显，高版本的 SupportActivity 实现了 LifecycleOwner 接口，并写 LifecycleOwner.getLifecycle() 是 LifecycleRegistry </p>
<h3 id="普通的-Activity"><a href="#普通的-Activity" class="headerlink" title="普通的 Activity"></a>普通的 Activity</h3><p>对于 26.1.0 以后的版本，你会发现，对于普通的 Activity，如果你想要使用 lifecycle，你只需要实现<br>LifecycleOwner 接口即可。当生命周期变化的时候，它也可以回调 Observer 的 onStateChanged 方法。</p>
<p>回到我们前面的问题：</p>
<p><strong>我们并没有在 onStart，onResume, onPause , onStop 和 onDestroy 方法中调用 mLifecycleRegistry.handleLifecycleEvent 方法，它又是怎样促发 onStateChanged 方法的</strong></p>
<p><strong>我们猜想它也是通过 ReportFragment 实现的。</strong>但是在 Activity 的 onCreate 方法中，我们并没有发现它有添加 ReportFragment，我们在 As 全局搜一下，看哪些地方使用到 ReportFragment。如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzlmZTRhZmEwZ3kxZnpoenFuam5nMGoyMGt6MDVlZ2xyLmpwZw?x-oss-process=image/format,png"></p>
<p>从图中可以看到，有几个地方使用到他。我们先来看一下 LifecycleDispatcher</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> AtomicBoolean sInitialized = <span class="keyword">new</span> AtomicBoolean(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInitialized.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 在 init 方法中，监听全局 activity 的创建，从而来添加 fragment</span></span><br><span class="line">        ((Application) context.getApplicationContext())</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> DispatcherActivityCallback());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">&quot;WeakerAccess&quot;</span>)</span><br><span class="line">    @VisibleForTesting</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherActivityCallback</span> <span class="keyword">extends</span> <span class="title">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">        private final FragmentCallback mFragmentCallback;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">DispatcherActivityCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            mFragmentCallback = <span class="keyword">new</span> FragmentCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivityCreated</span>(<span class="params">Activity activity, Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                ((FragmentActivity) activity).getSupportFragmentManager()</span><br><span class="line">                        .registerFragmentLifecycleCallbacks(mFragmentCallback, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ReportFragment.injectIfNeededIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivityStopped</span>(<span class="params">Activity activity</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivitySaveInstanceState</span>(<span class="params">Activity activity, Bundle outState</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略若干代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它 在 init 方法中，通过 context.getApplicationContext() .registerActivityLifecycleCallbacks 监听全局 activity 的创建，在 activity oncreate 的时候，调用 ReportFragment.injectIfNeededIn(activity) ，从而来添加 fragment，进而分发相应的事件。</p>
<p>那 LifecycleDispatcher 的 init 方法又是在哪里调用的呢？ 我们全局搜索一下 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean <span class="function"><span class="title">onCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它是在 ProcessLifecycleOwnerInitializer 的 onCreate 方法中调用的。而 ProcessLifecycleOwnerInitializer 是一个 ContentProvider。我们知道 ContentProvider 一般是在 AndroidManifest 中生命的。</p>
<p>果然，在 extensions-1.1.1.aar 中，我们惊喜地发现，它在 Manifest 里面注册了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;android.arch.lifecycle.extensions&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-sdk android:minSdkVersion=<span class="string">&quot;14&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        &lt;provider</span><br><span class="line">            android:name=<span class="string">&quot;android.arch.lifecycle.ProcessLifecycleOwnerInitializer&quot;</span></span><br><span class="line">            android:authorities=<span class="string">&quot;$&#123;applicationId&#125;.lifecycle-trojan&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">            android:multiprocess=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>而 ContentProvider 的 onCreate 方法优先于 Application 的 onCreate 执行，所以在 Application 之前我们就调用了  ProcessLifecycleOwnerInitializer init 方法，监听了 Activity 的创建，当 Actiivty 创建的时候，会尝试为 Activity 添加 ReportFragment。而 ReportFragment 会在 Activity 生命周期变化的时候帮助我们分发生命周期。</p>
<p>ContentProvider 的 onCreate 方法优先于 Application 的 onCreate 执行，可以查看这一篇博客 <a href="https://blog.csdn.net/long117long/article/details/66477562">Android系统中的Application和四大组件一些方法的启动顺序和一些坑</a></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ok，我们来梳理一下。</p>
<p><strong>对于 26.1.0 以后的 SupportActivity</strong></p>
<p>它在 Activity onCreate 的时候添加了 ReportFragment，这个 ReportFragment 相当于一个代理，它在 onActivityCreated 的时候  dispatch(Lifecycle.Event.ON_CREATE) 进行分发生命周期，onStart， onResume, onPause, onStop,  onDestroy 的时候也是如此。而 在  dispatch 中 它调用了 LifecycleRegistry handleLifecycleEvent 的方法。而 LifecycleRegistry 方法中经过一系列处理，它又调用了 observer 的 onStateChange 方法，去通知相应的 observer。</p>
<p><strong>对于普通的 Activity</strong></p>
<p>它利用了 ContentProvide 的特征，它是在 Application onCreate 之前初始化的，他在 ProcessLifecycleOwnerInitializer oncreate 的时候监听 Activity 的创建，在 Activity 创建的时候，判断是否已经添加过 ReportFragment，没有的话，添加进去。<em><strong>这是一个很巧妙的设计，隐式初始化了 lifecycle。</strong></em></p>
<p>用流程图表示如下：</p>
<p>该图片引用自  <a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374">Android 架构组件（一）——Lifecycle</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnppenp0OHVvdmoyMHlnMWthd240LmpwZw?x-oss-process=image/format,png"></p>
<h3 id="Lifecycle-设计借鉴"><a href="#Lifecycle-设计借鉴" class="headerlink" title="Lifecycle 设计借鉴"></a>Lifecycle 设计借鉴</h3><ol>
<li>利用 ProcessLifecycleOwnerInitializer contentProvider 来隐式加载</li>
</ol>
<p>想一下，如果 ProcessLifecycleOwnerInitializer 不利用 contentProvider 来隐式加载的话，对于 普通的 Activity，旧版本等，如果想使用 lifecycle，那必须在基类中，手动调用  ReportFragment.injectIfNeededIn(activity) 的方法。</p>
<ol start="2">
<li>利用 fragment 来分发生命周期</li>
</ol>
<p>利用  fragment 来分发生命周期有两个优点</p>
<ul>
<li>将逻辑从 Activity 中剥离出来，减少耦合，方便复用</li>
<li>可以做到在 Activity onCreate 之后才回调 observer 的 CREATED Event 事件。如果是通过 Application registerActivityLifecycleCallbacks 方法来分发生命周期的话，因为 ActivityLifecycleCallbacks 的 onActivityCreated 是在 Activity oncreate 之前调用的。</li>
</ul>
<p>下一篇：<a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><strong>推荐阅读：</strong></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/81394050">java 代理模式详解</a><br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/51824769">观察者设计模式 Vs 事件委托（java）</a><br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p>
]]></content>
      <tags>
        <tag>Android lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Android lifecycle 使用详解</title>
    <url>/2019/01/11/Android%20lifecycle%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p>
<p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210406234353804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://developer.android.com/topic/libraries/architecture/">Architecture Components   </a></p>
<p>lifecycle 是 2107 年 google 大会推出来的，它属于 architecture compoment 里面的一个组件，它可以干什么用呢？ 简单得来说，它可以用来检查 Activity 的生命周期，而不必强依赖  Activity。</p>
<hr>
<h2 id="为什么要引进-lifecycle"><a href="#为什么要引进-lifecycle" class="headerlink" title="为什么要引进 lifecycle"></a>为什么要引进 lifecycle</h2><p>举一下我们最常用的 MVP 例子，没引进 lifecycle 之前，我们需要在 Activity 或者 Fragment 销毁的时候，即 onDestroy 的时候手动调用 onDestroy 方法，这里会带来一些问题，每一次在 Activity 或者 Fragment 销毁的烧开后都要调用 presenter.destory() 方法，这样的代码枯燥，毫无意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPresenter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPresenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        presenter= <span class="keyword">new</span> MyPresenter ();</span><br><span class="line">        presenter.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        presenter.destory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以定义一些 IBasePresenter 的接口，在 BaseActivity 的时候调用 IBasePresenter 的 onDestroy 方法，这样也确实能做到。只不过稍微繁琐一点。</p>
<p>那如果是别的类的呢，比如 MediaCompoment，在 Activity 的时候，我们需要销毁一些资源，按照传统的方法，我们还是需要在 Activity onDestroy 的时候手动调用 onDestroy 方法。那有没有更好的方法呢?当然是有的，lifecycle 就可以解决这个问题。接下来，我们先来看一下 Lifycycle 的基本使用。</p>
<hr>
<h2 id="Lifycycle-的基本使用"><a href="#Lifycycle-的基本使用" class="headerlink" title="Lifycycle 的基本使用"></a>Lifycycle 的基本使用</h2><ol>
<li>引入相关的依赖包</li>
</ol>
<p>Lifecycle 已经是稳定版，它包含在 support library 26.1.0 及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModel and LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:viewmodel:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:livedata:1.1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>support library在26.1.0 之前，lifecycle 并没有集成进去，需要我们引入另外的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.0.0-alpha4&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用</li>
</ol>
<p>这里同样分为几种情况</p>
<ol>
<li>support library 26.1.0  之后，且继承 FragmentActivity，那么我们直接调用  getLifecycle().addObserver 方法即可，当 Activity 的生命周期变化的时候，将会回调 onStateChanged 的方法，状态分别是一一对应的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">   </span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> support library 26.1.0 之后，不是继承 FragmentActivity，只是简单地继承 Actiivty</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleLifecycleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="title">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;SimpleLifecycleActivity&quot;</span>;</span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_simple_lifecycle);</span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="built_in">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle <span class="function"><span class="title">getLifecycle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li> support library 26.1.0  之前</li>
</ol>
<p>（现在的 support library 基本都在 26.1.0 之后了，这个可以忽略）</p>
<p>第一步：实现 LifecycleOwner 接口，并返回响应的  Lifecycle</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public interface LifecycleOwner &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return </span>The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @NonNull</span><br><span class="line">    Lifecycle getLifecycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在 Activity 生命周期变化的时候，调用  mLifecycleRegistry.handleLifecycleEvent 方法，分发相应的生命周期。</p>
<p>第三步：调用 Lifecycle 的 addObserver 方法添加相应的 Observer。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> GenericLifecycleObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged:event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.RESUMED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.DESTROYED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们回过头来看一下我们上面提出的问题？</p>
<p>MediaCompoment 在 Activity ondestroy 的时候，我们需要销毁一些资源，用传统的方法，我们需要在 Activity onDestroy 的时候手动调用 onDestroy 方法。这样会存在一个问题，调用者必须知道比较清楚得知道 MediaCompoment 的设计，否则可能会忘记调用 onDestroy 的方法。</p>
<p>那有没有一种方法， 当 Activity 生命周期变化的时候，MediaCompoment 自身能够检测到 Activity 的 生命周期变化，从而做相应的处理。</p>
<p>答案当然是有的，使用 lifycycle。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MediaCompoment</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;MediaCompoment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private final LifecycleOwner mLifecycleOwner;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">MediaCompoment</span>(<span class="params">LifecycleOwner lifecycleOwner</span>)</span> &#123;</span><br><span class="line">        mLifecycleOwner = lifecycleOwner;</span><br><span class="line">        mLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, final Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">                    onCreate();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_START) &#123;</span><br><span class="line">                    onStart();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_RESUME) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">                    onPause();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">                    onStop();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    onDestroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onPause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ol>
<li>lifycycle 其实是用观察者模式实现的，当 Activity 生命周期变化的时候，通知相应的 Observers 即观察者。</li>
<li>使用 lifecycle，我们可以将释放资源的动作内聚在自身，减少与调用者之间的耦合。</li>
</ol>
<p>下一篇博客：<a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p>
<p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>Android lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Hook 机制之简单实战</title>
    <url>/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-Hook"><a href="#什么是-Hook" class="headerlink" title="什么是 Hook"></a>什么是 Hook</h3><p><strong>Hook 又叫“钩子”</strong>，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入。</p>
<p>这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p>
<h3 id="Hook-分类"><a href="#Hook-分类" class="headerlink" title="Hook 分类"></a>Hook 分类</h3><p>1.根据Android开发模式，Native模式（C/C++）和Java模式（Java）区分，在Android平台上 </p>
<ul>
<li>Java层级的Hook； </li>
<li>Native层级的Hook； </li>
</ul>
<p>2.根 Hook 对象与 Hook 后处理事件方式不同，Hook还分为： </p>
<ul>
<li>消息Hook； </li>
<li>API Hook； </li>
</ul>
<p>3.针对Hook的不同进程上来说，还可以分为： </p>
<ul>
<li>全局Hook； </li>
<li>单个进程Hook； </li>
</ul>
<h3 id="常见-Hook-框架"><a href="#常见-Hook-框架" class="headerlink" title="常见 Hook 框架"></a>常见 Hook 框架</h3><p>在Android开发中，有以下常见的一些Hook框架：</p>
<ol>
<li><strong>Xposed</strong></li>
</ol>
<p>通过替换 /system/bin/app_process 程序控制 Zygote 进程，使得 app_process 在启动过程中会加载 XposedBridge.jar 这个 Jar 包，从而完成对 Zygote 进程及其创建的 Dalvik 虚拟机的劫持。 </p>
<p>Xposed 在开机的时候完成对所有的 Hook Function 的劫持，在原 Function 执行的前后加上自定义代码。</p>
<ol start="2">
<li><strong>Cydia Substrate</strong></li>
</ol>
<p>Cydia Substrate 框架为苹果用户提供了越狱相关的服务框架，当然也推出了 Android 版 。Cydia Substrate 是一个代码修改平台，它可以修改任何进程的代码。</p>
<p>不管是用 Java 还是 C/C++（native代码）编写的，而 Xposed 只支持 Hook app_process 中的 Java 函数。</p>
<ol start="3">
<li>Legend</li>
</ol>
<p>Legend 是 Android 免 Root 环境下的一个 Apk Hook 框架，该框架代码设计简洁，通用性高，适合逆向工程时一些 Hook 场景。大部分的功能都放到了 Java 层，这样的兼容性就非常好。 </p>
<p>原理是这样的，直接构造出新旧方法对应的虚拟机数据结构，然后替换信息写到内存中即可。</p>
<h3 id="Hook-必须掌握的知识"><a href="#Hook-必须掌握的知识" class="headerlink" title="Hook 必须掌握的知识"></a>Hook 必须掌握的知识</h3><ul>
<li>反射 </li>
</ul>
<p>如果你对反射还不是很熟悉的话，建议你先复习一下 java 反射的相关知识。有兴趣的，可以看一下我的这一篇博客 <a href="https://blog.csdn.net/gdutxiaoxu/article/details/68947735">Java 反射机制详解</a></p>
<ul>
<li>java 的动态代理</li>
</ul>
<p>动态代理是指在运行时动态生成代理类，不需要我们像静态代理那个去手动写一个个的代理类。在 java 中，我们可以使用 InvocationHandler 实现动态代理，有兴趣的，可以查看我的这一篇博客 <a href="https://blog.csdn.net/gdutxiaoxu/article/details/81394050">java  代理模式详解</a></p>
<p>本文的主要内容是讲解单个进程的 Hook，以及怎样 Hook。有兴趣的可以关注我的微信公众号：<strong>程序员徐公</strong><br><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="Hook-使用实例"><a href="#Hook-使用实例" class="headerlink" title="Hook 使用实例"></a>Hook 使用实例</h2><h3 id="Hook-选择的关键点"><a href="#Hook-选择的关键点" class="headerlink" title="Hook 选择的关键点"></a>Hook 选择的关键点</h3><ul>
<li><p>Hook 的选择点：尽量静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。</p>
</li>
<li><p>Hook 过程：</p>
<ul>
<li>寻找 Hook 点，原则是尽量静态变量或者单例对象，尽量 Hook public 的对象和方法。</li>
<li>选择合适的代理方式，如果是接口可以用动态代理。</li>
<li>偷梁换柱——用代理对象替换原始对象。</li>
</ul>
</li>
<li><p>Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。</p>
</li>
</ul>
<h3 id="简单案例一-使用-Hook-修改-View-OnClickListener-事件"><a href="#简单案例一-使用-Hook-修改-View-OnClickListener-事件" class="headerlink" title="简单案例一: 使用 Hook 修改 View.OnClickListener 事件"></a>简单案例一: 使用 Hook 修改 View.OnClickListener 事件</h3><p>首先，我们先分析 View.setOnClickListener 源码，找出合适的 Hook 点。可以看到 OnClickListener 对象被保存在了一个叫做 ListenerInfo 的内部类里，其中 mListenerInfo 是 View 的成员变量。ListeneInfo 里面保存了 View 的各种监听事件。因此，我们可以想办法 hook ListenerInfo 的 mOnClickListener 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">    if (!isClickable()) &#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener &#x3D; l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class ListenerInfo &#123;</span><br><span class="line"></span><br><span class="line">     ---</span><br><span class="line"></span><br><span class="line">    ListenerInfo getListenerInfo() &#123;</span><br><span class="line">        if (mListenerInfo !&#x3D; null) &#123;</span><br><span class="line">            return mListenerInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        mListenerInfo &#x3D; new ListenerInfo();</span><br><span class="line">        return mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们一起来看一下怎样 Hook View.OnClickListener 事件？</p>
<p>大概分为三步：</p>
<ul>
<li>第一步：获取 ListenerInfo 对象</li>
</ul>
<p>从 View 的源代码，我们可以知道我们可以通过 getListenerInfo 方法获取，于是，我们利用反射得到 ListenerInfo 对象</p>
<ul>
<li>第二步：获取原始的 OnClickListener事件方法</li>
</ul>
<p>从上面的分析，我们知道 OnClickListener 事件被保存在 ListenerInfo 里面，同理我们利用反射获取</p>
<ul>
<li>第三步：偷梁换柱，用 Hook代理类 替换原始的 OnClickListener</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void hookOnClickListener(View view) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步：反射得到 ListenerInfo 对象</span><br><span class="line">    Method getListenerInfo &#x3D; View.class.getDeclaredMethod(&quot;getListenerInfo&quot;);</span><br><span class="line">    getListenerInfo.setAccessible(true);</span><br><span class="line">    Object listenerInfo &#x3D; getListenerInfo.invoke(view);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到原始的 OnClickListener事件方法</span><br><span class="line">    Class&lt;?&gt; listenerInfoClz &#x3D; Class.forName(&quot;android.view.View$ListenerInfo&quot;);</span><br><span class="line">    Field mOnClickListener &#x3D; listenerInfoClz.getDeclaredField(&quot;mOnClickListener&quot;);</span><br><span class="line">    mOnClickListener.setAccessible(true);</span><br><span class="line">    View.OnClickListener originOnClickListener &#x3D; (View.OnClickListener) mOnClickListener.get(listenerInfo);</span><br><span class="line">    &#x2F;&#x2F; 第三步：用 Hook代理类 替换原始的 OnClickListener</span><br><span class="line">    View.OnClickListener hookedOnClickListener &#x3D; new HookedClickListenerProxy(originOnClickListener);</span><br><span class="line">    mOnClickListener.set(listenerInfo, hookedOnClickListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HookedClickListenerProxy implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private View.OnClickListener origin;</span><br><span class="line"></span><br><span class="line">    public HookedClickListenerProxy(View.OnClickListener origin) &#123;</span><br><span class="line">        this.origin &#x3D; origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Toast.makeText(v.getContext(), &quot;Hook Click Listener&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        if (origin !&#x3D; null) &#123;</span><br><span class="line">            origin.onClick(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行以下代码，将会看到当我们点击该按钮的时候，会弹出 toast “Hook Click Listener”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mBtn1 &#x3D; (Button) findViewById(R.id.btn_1);</span><br><span class="line">mBtn1.setOnClickListener(this);</span><br><span class="line">try &#123;</span><br><span class="line">    HookHelper.hookOnClickListener(mBtn1);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单案例二：-HooK-Notification"><a href="#简单案例二：-HooK-Notification" class="headerlink" title="简单案例二： HooK Notification"></a>简单案例二： HooK Notification</h3><p>发送消息到通知栏的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">notificationManager.notify(id, builder.build());</span><br></pre></td></tr></table></figure>


<p>跟踪 notify 方法发现最终会调用到 notifyAsUser 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void notify(String tag, int id, Notification notification)</span><br><span class="line">&#123;</span><br><span class="line">    notifyAsUser(tag, id, notification, new UserHandle(UserHandle.myUserId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在 notifyAsUser 方法中，我们惊喜地发现 service 是一个单例，因此，我们可以想方法 hook 住这个 service，而 notifyAsUser 最终会调用到 service 的 enqueueNotificationWithTag 方法。因此 hook 住 service 的 enqueueNotificationWithTag 方法即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    INotificationManager service &#x3D; getService();</span><br><span class="line">    String pkg &#x3D; mContext.getPackageName();</span><br><span class="line">    &#x2F;&#x2F; Fix the notification as best we can.</span><br><span class="line">    Notification.addFieldsFromContext(mContext, notification);</span><br><span class="line">    if (notification.sound !&#x3D; null) &#123;</span><br><span class="line">        notification.sound &#x3D; notification.sound.getCanonicalUri();</span><br><span class="line">        if (StrictMode.vmFileUriExposureEnabled()) &#123;</span><br><span class="line">            notification.sound.checkFileUriExposed(&quot;Notification.sound&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fixLegacySmallIcon(notification, pkg);</span><br><span class="line">    if (mContext.getApplicationInfo().targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">        if (notification.getSmallIcon() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid notification (no valid small icon): &quot;</span><br><span class="line">                    + notification);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (localLOGV) Log.v(TAG, pkg + &quot;: notify(&quot; + id + &quot;, &quot; + notification + &quot;)&quot;);</span><br><span class="line">    final Notification copy &#x3D; Builder.maybeCloneStrippedForDelivery(notification);</span><br><span class="line">    try &#123;</span><br><span class="line">        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id,</span><br><span class="line">                copy, user.getIdentifier());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static INotificationManager sService;</span><br><span class="line"></span><br><span class="line">static public INotificationManager getService()</span><br><span class="line">&#123;</span><br><span class="line">    if (sService !&#x3D; null) &#123;</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b &#x3D; ServiceManager.getService(&quot;notification&quot;);</span><br><span class="line">    sService &#x3D; INotificationManager.Stub.asInterface(b);</span><br><span class="line">    return sService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上，要 Hook  Notification，大概需要三步：</p>
<ul>
<li>第一步：得到 NotificationManager 的 sService</li>
<li>第二步：因为 sService 是接口，所以我们可以使用动态代理，获取动态代理对象</li>
<li>第三步：偷梁换柱，使用动态代理对象 proxyNotiMng 替换系统的 sService</li>
</ul>
<p>于是，我们可以写出如下的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void hookNotificationManager(final Context context) throws Exception &#123;</span><br><span class="line">    NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">    Method getService &#x3D; NotificationManager.class.getDeclaredMethod(&quot;getService&quot;);</span><br><span class="line">    getService.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 sService</span><br><span class="line">    final Object sOriginService &#x3D; getService.invoke(notificationManager);</span><br><span class="line"></span><br><span class="line">    Class iNotiMngClz &#x3D; Class.forName(&quot;android.app.INotificationManager&quot;);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到我们的动态代理对象</span><br><span class="line">    Object proxyNotiMng &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;iNotiMngClz&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            Log.d(TAG, &quot;invoke: name&#x3D;&quot; + name);</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Toast.makeText(context.getApplicationContext(), &quot;检测到有人发通知了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(sOriginService, args);</span><br><span class="line">            &#x2F;&#x2F; 拦截通知，什么也不做</span><br><span class="line">            &#x2F;&#x2F;                    return null;</span><br><span class="line">            &#x2F;&#x2F; 或者是根据通知的 Tag 和 ID 进行筛选</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 sService</span><br><span class="line">    Field sServiceField &#x3D; NotificationManager.class.getDeclaredField(&quot;sService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(notificationManager, proxyNotiMng);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Hook-使用进阶"><a href="#Hook-使用进阶" class="headerlink" title="Hook 使用进阶"></a>Hook 使用进阶</h2><h3 id="Hook-ClipboardManager"><a href="#Hook-ClipboardManager" class="headerlink" title="Hook ClipboardManager"></a>Hook ClipboardManager</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><p>从上面的 hook NotificationManager 例子中，我们可以得知 NotificationManager 中有一个静态变量 sService，这个变量是远端的 service。因此，我们尝试查找 ClipboardManager 中是不是也存在相同的类似静态变量。</p>
<p>查看它的源码发现它存在 mService 变量，该变量是在 ClipboardManager 构造函数中初始化的，而 ClipboardManager 的构造方法用 @hide 标记，表明该方法对调用者不可见。</p>
<p>而我们知道 ClipboardManager，NotificationManager 其实这些都是单例的，即系统只会创建一次。因此我们也可以认为<br>ClipboardManager 的 mService 是单例的。因此 mService 应该是可以考虑 hook 的一个点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClipboardManager extends android.text.ClipboardManager &#123;</span><br><span class="line">    private final Context mContext;</span><br><span class="line">    private final IClipboard mService;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#123;@hide&#125; *&#x2F;</span><br><span class="line">    public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mService &#x3D; IClipboard.Stub.asInterface(</span><br><span class="line">                ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们再来一个看一下 ClipboardManager 的相关方法 setPrimaryClip ， getPrimaryClip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setPrimaryClip(ClipData clip) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (clip !&#x3D; null) &#123;</span><br><span class="line">            clip.prepareToLeaveProcess(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.setPrimaryClip(clip, mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current primary clip on the clipboard.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ClipData getPrimaryClip() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return mService.getPrimaryClip(mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这些方法最终都会调用到 mService 的相关方法。因此，ClipboardManager 的 mService 确实是一个可以 hook 的一个点。</p>
<p><strong>hook ClipboardManager.mService  的实现</strong></p>
<p>大概需要三个步骤</p>
<ul>
<li>第一步：得到 ClipboardManager 的 mService</li>
<li>第二步：初始化动态代理对象</li>
<li>第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void hookClipboardService(final Context context) throws Exception &#123;</span><br><span class="line">    ClipboardManager clipboardManager &#x3D; (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line">    Field mServiceFiled &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    mServiceFiled.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 mService</span><br><span class="line">    final Object mService &#x3D; mServiceFiled.get(clipboardManager);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二步：初始化动态代理对象</span><br><span class="line">    Class aClass &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">    Object proxyInstance &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;aClass&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;setPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Object arg &#x3D; args[0];</span><br><span class="line">                if (arg instanceof ClipData) &#123;</span><br><span class="line">                    ClipData clipData &#x3D; (ClipData) arg;</span><br><span class="line">                    int itemCount &#x3D; clipData.getItemCount();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; itemCount; i++) &#123;</span><br><span class="line">                        ClipData.Item item &#x3D; clipData.getItemAt(i);</span><br><span class="line">                        Log.i(TAG, &quot;invoke: item&#x3D;&quot; + item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人设置粘贴板内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; else if (&quot;getPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人要获取粘贴板的内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(mService, args);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</span><br><span class="line">    Field sServiceField &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(clipboardManager, proxyInstance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnR4ajVleWl6aWcyMGM3MG9wcTdyLmdpZg"></p>
<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>对 Android 源码有基本了解的人都知道，Android 中的各种 Manager 都是通过 ServiceManager 获取的。因此，我们可以通过 ServiceManager hook 所有系统 Manager，ClipboardManager 当然也不例外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老套路</p>
<ul>
<li>第一步：通过反射获取剪切板服务的远程Binder对象，这里我们可以通过 ServiceManager getService 方法获得</li>
<li>第二步：创建我们的动态代理对象，动态代理原来的Binder对象</li>
<li>第三步：偷梁换柱，把我们的动态代理对象设置进去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void hookClipboardService() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取剪切板服务的远程Binder对象</span><br><span class="line">    Class serviceManager &#x3D; Class.forName(&quot;android.os.ServiceManager&quot;);</span><br><span class="line">    Method getServiceMethod &#x3D; serviceManager.getMethod(&quot;getService&quot;, String.class);</span><br><span class="line">    IBinder remoteBinder &#x3D; (IBinder) getServiceMethod.invoke(null, Context.CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新建一个我们需要的Binder，动态代理原来的Binder对象</span><br><span class="line">    IBinder hookBinder &#x3D; (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">            new Class[]&#123;IBinder.class&#125;, new ClipboardHookRemoteBinderHandler(remoteBinder));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取ServiceManger存储Binder对象的缓存集合,把我们新建的代理Binder放进缓存</span><br><span class="line">    Field sCacheField &#x3D; serviceManager.getDeclaredField(&quot;sCache&quot;);</span><br><span class="line">    sCacheField.setAccessible(true);</span><br><span class="line">    Map&lt;String, IBinder&gt; sCache &#x3D; (Map&lt;String, IBinder&gt;) sCacheField.get(null);</span><br><span class="line">    sCache.put(Context.CLIPBOARD_SERVICE, hookBinder);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ClipboardHookRemoteBinderHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private IBinder remoteBinder;</span><br><span class="line">    private Class iInterface;</span><br><span class="line">    private Class stubClass;</span><br><span class="line"></span><br><span class="line">    public ClipboardHookRemoteBinderHandler(IBinder remoteBinder) &#123;</span><br><span class="line">        this.remoteBinder &#x3D; remoteBinder;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.iInterface &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">            this.stubClass &#x3D; Class.forName(&quot;android.content.IClipboard$Stub&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Log.d(&quot;RemoteBinderHandler&quot;, method.getName() + &quot;() is invoked&quot;);</span><br><span class="line">        if (&quot;queryLocalInterface&quot;.equals(method.getName())) &#123;</span><br><span class="line">            &#x2F;&#x2F;这里不能拦截具体的服务的方法，因为这是一个远程的Binder，还没有转化为本地Binder对象</span><br><span class="line">            &#x2F;&#x2F;所以先拦截我们所知的queryLocalInterface方法，返回一个本地Binder对象的代理</span><br><span class="line">            return Proxy.newProxyInstance(remoteBinder.getClass().getClassLoader(),</span><br><span class="line">                    new Class[]&#123;this.iInterface&#125;,</span><br><span class="line">                    new ClipboardHookLocalBinderHandler(remoteBinder, stubClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return method.invoke(remoteBinder, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Hook-Activity"><a href="#Hook-Activity" class="headerlink" title="Hook Activity"></a>Hook Activity</h3><p>关于怎样 hook activity，以及怎样启动没有在 AndroidManifet 注册的 activity，可以查看我的这一篇博客。</p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/81459910">Android Hook Activity 的几种姿势</a></p>
<p><strong>源码下载地址</strong>： <a href="https://github.com/gdutxiaoxu/HookDemo">HookDemo</a></p>
<hr>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p>
<p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p>
<p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p>
<p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p>
<p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p>
<p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p>
<p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p>
<p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义-Behavior-仿新浪微博发现页的实现</title>
    <url>/2017/05/12/%E8%87%AA%E5%AE%9A%E4%B9%89%20Behavior%20-%20%E4%BB%BF%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%8F%91%E7%8E%B0%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71553411">NestedScrolling 机制深入解析</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71616547"> 一步步带你读懂 CoordinatorLayout 源码</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71732642">自定义 Behavior -仿新浪微博发现页的实现</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/52939127">ViewPager，ScrollView 嵌套ViewPager滑动冲突解决</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/88383135">自定义 behavior - 完美仿 QQ 浏览器首页，美团商家详情页</a></p>
<p>  <strong>重磅消息：小编我开始运营自己的公众号了， 目前从事于 Android 开发，除了分享 Android开发相关知识，还有职场心得，面试经验，学习心得，人生感悟等等。希望通过该公众号，让你看到程序猿不一样的一面，我们不只会敲代码，我们还会。。。。。。</strong></p>
<p>  <strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94），或者拿起你的手机扫一扫，期待你的参与</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmUyMjk5MGU?x-oss-process=image/format,png" alt="Android 技术人"></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>我们先来看一下新浪微博发现页的效果：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmYzMzFjY2E?x-oss-process=image/format,png"></p>
<p>接下来我们在来看一下我们仿照新浪微博实现的效果</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmY0NTFhNDg?x-oss-process=image/format,png" alt="仿新浪微博效果图"></p>
<h2 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h2><p>我们这里先定义两种状态，open 和  close 状态。</p>
<ul>
<li>open 状态指 Tab+ViewPager 还没有滑动到顶部的时候，header 还 没有被完全移除屏幕的时候</li>
<li>close 状态指 Tab+ViewPager 滑动到顶部的时候，Header 被移除屏幕的时候 </li>
</ul>
<p>从效果图，我们可以看到 在 open 状态下，我们向上滑动 ViewPager 里面的 RecyclerView  的 时候，<strong>RecyclerView 并不会向上移动（RecyclerView 的滑动事件交给 外部的容器处理，被被全部消费掉了），而是整个布局（指 Header + Tab +ViewPager）会向上偏移</strong> 。当 Tab 滑动到顶部的时候，我们向上滑动 ViewPager 里面的 RecyclerView 的时候，<strong>RecyclerView  可以正常向上滑动，即此时外部容器没有拦截滑动事件</strong>。</p>
<p>同时我们可以看到在 open 状态的时候，我们是不支持下拉刷新的，这个比较容易实现，监听页面的状态，如果是 open 状态，我们设置 SwipeRefreshLayout setEnabled 为 false，这样不会 拦截事件，在页面 close 的时候，设置 SwipeRefreshLayout setEnabled 为 TRUE，这样就可以支持下拉刷新了。</p>
<p>基于上面的分析，我们这里可以把整个效果划分为两个部分，第一部分为 Header，第二部分为 Tab+ViewPager。<strong>下文统一把第一部分称为 Header，第二部分称为 Content 。</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzA5ZDJjZWU?x-oss-process=image/format,png"></p>
<p>需要实现的效果为：在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView  的 滑动事件。</p>
<p>在上一篇博客 <a href="http://blog.csdn.net/gdutxiaoxu/article/details/71616547">一步步带你读懂 CoordinatorLayout 源码</a> 中，我们有提到在 CoordinatorLayout中，我们可以通过 给子 View 自定义 Behavior 来处理事件。它是一个容器，实现了 NestedScrollingParent 接口。它并不会直接处理事件，而是会尽可能地交给子 View 的 Behavior 进行处理。因此，为了减少依赖，<strong>我们把这两部分的关系定义为 Content 依赖于  Header。Header 移动的时候，Content 跟着 移动。所以，我们在处理滑动事件的时候，只需要处理好 Header 部分的 Behavior 就oK了，Content 部分的 Behavior 不需要处理滑动事件，只需依赖于  Header ，跟着做相应的移动即可。</strong></p>
<hr>
<h2 id="Header-部分的实现"><a href="#Header-部分的实现" class="headerlink" title="Header 部分的实现"></a>Header 部分的实现</h2><p>Header 部分实现的两个关键点在于</p>
<ol>
<li>在页面状态为 open 的时候，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView  的 滑动事件</li>
<li>在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。</li>
</ol>
<h3 id="第一个关键点的实现"><a href="#第一个关键点的实现" class="headerlink" title="第一个关键点的实现"></a>第一个关键点的实现</h3><p>这里区分页面状态是 open 还是  close 状态是通过 Header 是否移除屏幕来区分的，即 child.getTranslationY() == getHeaderOffsetRange() 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean isClosed(View child) &#123;</span><br><span class="line">    boolean isClosed &#x3D; child.getTranslationY() &#x3D;&#x3D; getHeaderOffsetRange();</span><br><span class="line">    return isClosed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<a href="http://blog.csdn.net/gdutxiaoxu/article/details/71553411">NestedScrolling 机制深入解析</a>博客中，我们对 NestedScrolling 机制做了如下的总结。</p>
<ul>
<li>在 Action_Down 的时候，Scrolling child 会调用 startNestedScroll 方法，通过 childHelper 回调 Scrolling Parent 的 startNestedScroll 方法。 </li>
<li>在 Action_move 的时候，Scrolling Child 要开始滑动的时候，会调用dispatchNestedPreScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否要先于 Child 进行 滑动，若需要的话，会调用 Parent 的 onNestedPreScroll 方法，协同 Child 一起进行滑动</li>
<li>当 ScrollingChild 滑动完成的时候，会调用 dispatchNestedScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否需要进行滑动，需要的话，会 调用 Parent 的 onNestedScroll 方法</li>
<li>在 Action_down,Action_move 的时候，会调用 Scrolling Child 的stopNestedScroll ，通过 ChildHelper 询问 Scrolling parent 的 stopNestedScroll 方法。</li>
<li>如果需要处理 Fling 动作，我们可以通过 VelocityTrackerCompat 获得相应的速度，并在 Action_up 的时候，调用 dispatchNestedPreFling 方法，通过 ChildHelper 询问 Parent 是否需要先于 child 进行 Fling 动作<br>在 Child 处理完 Fling 动作时候，如果 Scrolling Parent 还需要处理 Fling 动作，我们可以调用 dispatchNestedFling 方法，通过 ChildHelper ，调用 Parent 的 onNestedFling 方法</li>
</ul>
<p><strong>而 RecyclerView  也是 Scrolling Child （实现了 NestedScrollingChild 接口），RecyclerView 在开始滑动的 时候会先调用  CoordinatorLayout 的 startNestedScroll 方法，而 CoordinatorLayout 会 调用子 View  的 Behavior 的  startNestedScroll 方法。并且只有 boolean startNestedScroll   返回  TRUE 的 时候，才会调用接下里 Behavior 中的 onNestedPreScroll 和 onNestedScroll 方法。</strong></p>
<p>所以，我们在 WeiboHeaderPagerBehavior 的 onStartNestedScroll 方法可以这样写，可以确保 只拦截垂直方向上的滚动事件，且当前状态是打开的并且还可以继续向上收缩的时候还会拦截</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View</span><br><span class="line">        directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">    if (BuildConfig.DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes&#x3D;&quot; + nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean canScroll &#x3D; canScroll(child, 0);</span><br><span class="line">    &#x2F;&#x2F;拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩</span><br><span class="line">    return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0 &amp;&amp; canScroll &amp;&amp;</span><br><span class="line">            !isClosed(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截事件之后，我们需要在 RecyclerView 滑动之前消耗事件，并且移动 Header，让其向上偏移。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                              int dx, int dy, int[] consumed) &#123;</span><br><span class="line">    super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">    &#x2F;&#x2F;dy&gt;0 scroll up;dy&lt;0,scroll down</span><br><span class="line">    Log.i(TAG, &quot;onNestedPreScroll: dy&#x3D;&quot; + dy);</span><br><span class="line">    float halfOfDis &#x3D; dy;</span><br><span class="line">    &#x2F;&#x2F;    不能滑动了，直接给 Header 设置 终值，防止出错</span><br><span class="line">    if (!canScroll(child, halfOfDis)) &#123;</span><br><span class="line">        child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.setTranslationY(child.getTranslationY() - halfOfDis);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;consumed all scroll behavior after we started Nested Scrolling</span><br><span class="line">    consumed[1] &#x3D; dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，我们也需要处理 Fling 事件，在页面没有完全关闭的 时候，消费所有 fling 事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                float velocityX, float velocityY) &#123;</span><br><span class="line">    &#x2F;&#x2F; consumed the flinging behavior until Closed</span><br><span class="line">    return !isClosed(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于滑动到顶部的动画，我是通过 mOverScroller + FlingRunnable 来实现的 。完整代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WeiboHeaderPagerBehavior extends ViewOffsetBehavior &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;UcNewsHeaderPager&quot;;</span><br><span class="line">    public static final int STATE_OPENED &#x3D; 0;</span><br><span class="line">    public static final int STATE_CLOSED &#x3D; 1;</span><br><span class="line">    public static final int DURATION_SHORT &#x3D; 300;</span><br><span class="line">    public static final int DURATION_LONG &#x3D; 600;</span><br><span class="line"></span><br><span class="line">    private int mCurState &#x3D; STATE_OPENED;</span><br><span class="line">    private OnPagerStateListener mPagerStateListener;</span><br><span class="line"></span><br><span class="line">    private OverScroller mOverScroller;</span><br><span class="line"></span><br><span class="line">    private WeakReference&lt;CoordinatorLayout&gt; mParent;</span><br><span class="line">    private WeakReference&lt;View&gt; mChild;</span><br><span class="line"></span><br><span class="line">    public void setPagerStateListener(OnPagerStateListener pagerStateListener) &#123;</span><br><span class="line">        mPagerStateListener &#x3D; pagerStateListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboHeaderPagerBehavior() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboHeaderPagerBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mOverScroller &#x3D; new OverScroller(BaseAPP.getAppContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void layoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123;</span><br><span class="line">        super.layoutChild(parent, child, layoutDirection);</span><br><span class="line">        mParent &#x3D; new WeakReference&lt;CoordinatorLayout&gt;(parent);</span><br><span class="line">        mChild &#x3D; new WeakReference&lt;View&gt;(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View</span><br><span class="line">            directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes&#x3D;&quot; + nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean canScroll &#x3D; canScroll(child, 0);</span><br><span class="line">        &#x2F;&#x2F;拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩</span><br><span class="line">        return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0 &amp;&amp; canScroll &amp;&amp;</span><br><span class="line">                !isClosed(child);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                    float velocityX, float velocityY) &#123;</span><br><span class="line">        &#x2F;&#x2F; consumed the flinging behavior until Closed</span><br><span class="line"></span><br><span class="line">        boolean coumsed &#x3D; !isClosed(child);</span><br><span class="line">        Log.i(TAG, &quot;onNestedPreFling: coumsed&#x3D;&quot; +coumsed);</span><br><span class="line">        return coumsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                 float velocityX, float velocityY, boolean consumed) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onNestedFling: velocityY&#x3D;&quot; +velocityY);</span><br><span class="line">        return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY,</span><br><span class="line">                consumed);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isClosed(View child) &#123;</span><br><span class="line">        boolean isClosed &#x3D; child.getTranslationY() &#x3D;&#x3D; getHeaderOffsetRange();</span><br><span class="line">        return isClosed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isClosed() &#123;</span><br><span class="line">        return mCurState &#x3D;&#x3D; STATE_CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void changeState(int newState) &#123;</span><br><span class="line">        if (mCurState !&#x3D; newState) &#123;</span><br><span class="line">            mCurState &#x3D; newState;</span><br><span class="line">            if (mCurState &#x3D;&#x3D; STATE_OPENED) &#123;</span><br><span class="line">                if (mPagerStateListener !&#x3D; null) &#123;</span><br><span class="line">                    mPagerStateListener.onPagerOpened();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mPagerStateListener !&#x3D; null) &#123;</span><br><span class="line">                    mPagerStateListener.onPagerClosed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表示 Header TransLationY 的值是否达到我们指定的阀值， headerOffsetRange，到达了，返回 false，</span><br><span class="line">    &#x2F;&#x2F; 否则，返回 true。注意 TransLationY 是负数。</span><br><span class="line">    private boolean canScroll(View child, float pendingDy) &#123;</span><br><span class="line">        int pendingTranslationY &#x3D; (int) (child.getTranslationY() - pendingDy);</span><br><span class="line">        int headerOffsetRange &#x3D; getHeaderOffsetRange();</span><br><span class="line">        if (pendingTranslationY &gt;&#x3D; headerOffsetRange &amp;&amp; pendingTranslationY &lt;&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(CoordinatorLayout parent, final View child, MotionEvent</span><br><span class="line">            ev) &#123;</span><br><span class="line"></span><br><span class="line">        boolean closed &#x3D; isClosed();</span><br><span class="line">        Log.i(TAG, &quot;onInterceptTouchEvent: closed&#x3D;&quot; + closed);</span><br><span class="line">        if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_UP &amp;&amp; !closed) &#123;</span><br><span class="line">            handleActionUp(parent,child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onInterceptTouchEvent(parent, child, ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                  int dx, int dy, int[] consumed) &#123;</span><br><span class="line">        super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">        &#x2F;&#x2F;dy&gt;0 scroll up;dy&lt;0,scroll down</span><br><span class="line">        Log.i(TAG, &quot;onNestedPreScroll: dy&#x3D;&quot; + dy);</span><br><span class="line">        float halfOfDis &#x3D; dy;</span><br><span class="line">        &#x2F;&#x2F;    不能滑动了，直接给 Header 设置 终值，防止出错</span><br><span class="line">        if (!canScroll(child, halfOfDis)) &#123;</span><br><span class="line">            child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            child.setTranslationY(child.getTranslationY() - halfOfDis);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;consumed all scroll behavior after we started Nested Scrolling</span><br><span class="line">        consumed[1] &#x3D; dy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    需要注意的是  Header 我们是通过 setTranslationY 来移出屏幕的，所以这个值是负数</span><br><span class="line">    private int getHeaderOffsetRange() &#123;</span><br><span class="line">        return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen</span><br><span class="line">                .weibo_header_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleActionUp(CoordinatorLayout parent, final View child) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;handleActionUp: &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">            child.removeCallbacks(mFlingRunnable);</span><br><span class="line">            mFlingRunnable &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">        if (child.getTranslationY() &lt; getHeaderOffsetRange() &#x2F; 6.0f) &#123;</span><br><span class="line">            mFlingRunnable.scrollToClosed(DURATION_SHORT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mFlingRunnable.scrollToOpen(DURATION_SHORT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void onFlingFinished(CoordinatorLayout coordinatorLayout, View layout) &#123;</span><br><span class="line">        changeState(isClosed(layout) ? STATE_CLOSED : STATE_OPENED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openPager() &#123;</span><br><span class="line">        openPager(DURATION_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param duration open animation duration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void openPager(int duration) &#123;</span><br><span class="line">        View child &#x3D; mChild.get();</span><br><span class="line">        CoordinatorLayout parent &#x3D; mParent.get();</span><br><span class="line">        if (isClosed() &amp;&amp; child !&#x3D; null) &#123;</span><br><span class="line">            if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">                child.removeCallbacks(mFlingRunnable);</span><br><span class="line">                mFlingRunnable &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">            mFlingRunnable.scrollToOpen(duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void closePager() &#123;</span><br><span class="line">        closePager(DURATION_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param duration close animation duration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void closePager(int duration) &#123;</span><br><span class="line">        View child &#x3D; mChild.get();</span><br><span class="line">        CoordinatorLayout parent &#x3D; mParent.get();</span><br><span class="line">        if (!isClosed()) &#123;</span><br><span class="line">            if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">                child.removeCallbacks(mFlingRunnable);</span><br><span class="line">                mFlingRunnable &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">            mFlingRunnable.scrollToClosed(duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private FlingRunnable mFlingRunnable;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * For animation , Why not use &#123;@link android.view.ViewPropertyAnimator &#125; to play animation</span><br><span class="line">     * is of the</span><br><span class="line">     * other &#123;@link CoordinatorLayout.Behavior&#125; that depend on this could not receiving the</span><br><span class="line">     * correct result of</span><br><span class="line">     * &#123;@link View#getTranslationY()&#125; after animation finished for whatever reason that i don&#39;t know</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private class FlingRunnable implements Runnable &#123;</span><br><span class="line">        private final CoordinatorLayout mParent;</span><br><span class="line">        private final View mLayout;</span><br><span class="line"></span><br><span class="line">        FlingRunnable(CoordinatorLayout parent, View layout) &#123;</span><br><span class="line">            mParent &#x3D; parent;</span><br><span class="line">            mLayout &#x3D; layout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void scrollToClosed(int duration) &#123;</span><br><span class="line">            float curTranslationY &#x3D; ViewCompat.getTranslationY(mLayout);</span><br><span class="line">            float dy &#x3D; getHeaderOffsetRange() - curTranslationY;</span><br><span class="line">            if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed:offest:&quot; + getHeaderOffsetRange());</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur0:&quot; + curTranslationY + &quot;,end0:&quot; + dy);</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur:&quot; + Math.round(curTranslationY) + &quot;,end:&quot; + Math</span><br><span class="line">                        .round(dy));</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur1:&quot; + (int) (curTranslationY) + &quot;,end:&quot; + (int) dy);</span><br><span class="line">            &#125;</span><br><span class="line">            mOverScroller.startScroll(0, Math.round(curTranslationY - 0.1f), 0, Math.round(dy +</span><br><span class="line">                    0.1f), duration);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void scrollToOpen(int duration) &#123;</span><br><span class="line">            float curTranslationY &#x3D; ViewCompat.getTranslationY(mLayout);</span><br><span class="line">            mOverScroller.startScroll(0, (int) curTranslationY, 0, (int) -curTranslationY,</span><br><span class="line">                    duration);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void start() &#123;</span><br><span class="line">            if (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">                mFlingRunnable &#x3D; new FlingRunnable(mParent, mLayout);</span><br><span class="line">                ViewCompat.postOnAnimation(mLayout, mFlingRunnable);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                onFlingFinished(mParent, mLayout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mLayout !&#x3D; null &amp;&amp; mOverScroller !&#x3D; null) &#123;</span><br><span class="line">                if (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">                    if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;run: &quot; + mOverScroller.getCurrY());</span><br><span class="line">                    &#125;</span><br><span class="line">                    ViewCompat.setTranslationY(mLayout, mOverScroller.getCurrY());</span><br><span class="line">                    ViewCompat.postOnAnimation(mLayout, this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    onFlingFinished(mParent, mLayout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * callback for HeaderPager &#39;s state</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public interface OnPagerStateListener &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * do callback when pager closed</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void onPagerClosed();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * do callback when pager opened</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void onPagerOpened();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二个关键点的实现"><a href="#第二个关键点的实现" class="headerlink" title="第二个关键点的实现"></a>第二个关键点的实现</h3><p>在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。</p>
<p>在第一个关键点的实现上，我们是通过自定义 Behavior 来处理 ViewPager 里面 RecyclerView 的移动的，那我们要怎样监听整个 Header 的滑动了。</p>
<p>那就是重写 LinearLayout，将滑动事件交给 ScrollingParent（这里是CoordinatorLayout） 去处理，CoordinatorLayout 再交给子 View 的 behavior 去处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NestedLinearLayout extends LinearLayout implements NestedScrollingChild &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;NestedLinearLayout&quot;;</span><br><span class="line"></span><br><span class="line">    private final int[] offset &#x3D; new int[2];</span><br><span class="line">    private final int[] consumed &#x3D; new int[2];</span><br><span class="line"></span><br><span class="line">    private NestedScrollingChildHelper mScrollingChildHelper;</span><br><span class="line">    private int lastY;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        if (mScrollingChildHelper &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mScrollingChildHelper &#x3D; new NestedScrollingChildHelper(this);</span><br><span class="line">            mScrollingChildHelper.setNestedScrollingEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction())&#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                lastY &#x3D; (int) event.getRawY();</span><br><span class="line">                &#x2F;&#x2F; 当开始滑动的时候，告诉父view</span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_HORIZONTAL</span><br><span class="line">                        | ViewCompat.SCROLL_AXIS_VERTICAL);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction())&#123;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&#x3D;&quot;);</span><br><span class="line">                int y &#x3D; (int) (event.getRawY());</span><br><span class="line">                int dy &#x3D;lastY- y;</span><br><span class="line">                lastY &#x3D; y;</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: lastY&#x3D;&quot; + lastY);</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: dy&#x3D;&quot; + dy);</span><br><span class="line">                &#x2F;&#x2F;  dy &lt; 0 下拉， dy&gt;0 赏花</span><br><span class="line">                if (dy &gt;0) &#123; &#x2F;&#x2F; 上滑的时候才交给父类去处理</span><br><span class="line">                    if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) &#x2F;&#x2F; 如果找到了支持嵌套滚动的父类</span><br><span class="line">                            &amp;&amp; dispatchNestedPreScroll(0, dy, consumed, offset)) &#123;&#x2F;&#x2F;</span><br><span class="line">                        &#x2F;&#x2F; 父类进行了一部分滚动</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) &#x2F;&#x2F; 如果找到了支持嵌套滚动的父类</span><br><span class="line">                            &amp;&amp; dispatchNestedScroll(0, 0, 0,dy, offset)) &#123;&#x2F;&#x2F;</span><br><span class="line">                        &#x2F;&#x2F; 父类进行了一部分滚动</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private NestedScrollingChildHelper getScrollingChildHelper() &#123;</span><br><span class="line">        return mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接口实现--------------------------------------------------</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class="line">        getScrollingChildHelper().setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isNestedScrollingEnabled() &#123;</span><br><span class="line">        return getScrollingChildHelper().isNestedScrollingEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean startNestedScroll(int axes) &#123;</span><br><span class="line">        return getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stopNestedScroll() &#123;</span><br><span class="line">        getScrollingChildHelper().stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNestedScrollingParent() &#123;</span><br><span class="line">        return getScrollingChildHelper().hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,</span><br><span class="line">                                        int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedScroll(dxConsumed,</span><br><span class="line">                dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed,</span><br><span class="line">                                           int[] offsetInWindow) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy,</span><br><span class="line">                consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedFling(float velocityX, float velocityY,</span><br><span class="line">                                       boolean consumed) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedFling(velocityX,</span><br><span class="line">                velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedPreFling(velocityX,</span><br><span class="line">                velocityY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Content-部分的实现"><a href="#Content-部分的实现" class="headerlink" title="Content 部分的实现"></a>Content 部分的实现</h2><p>Content 部分的实现也主要有两个关键点</p>
<ul>
<li>整体置于 Header 之下</li>
<li>Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。</li>
</ul>
<h3 id="第一个关键点的实现-1"><a href="#第一个关键点的实现-1" class="headerlink" title="第一个关键点的实现"></a>第一个关键点的实现</h3><p>整体置于 Header 之下。这个我们可以参考 APPBarLayout 的 behavior，它是这样处理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Copy from Android design library</span><br><span class="line"> * &lt;p&#x2F;&gt;</span><br><span class="line"> * Created by xujun</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class HeaderScrollingViewBehavior extends ViewOffsetBehavior&lt;View&gt; &#123;</span><br><span class="line">    private final Rect mTempRect1 &#x3D; new Rect();</span><br><span class="line">    private final Rect mTempRect2 &#x3D; new Rect();</span><br><span class="line"></span><br><span class="line">    private int mVerticalLayoutGap &#x3D; 0;</span><br><span class="line">    private int mOverlayTop;</span><br><span class="line"></span><br><span class="line">    public HeaderScrollingViewBehavior() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeaderScrollingViewBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">        final int childLpHeight &#x3D; child.getLayoutParams().height;</span><br><span class="line">        if (childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.MATCH_PARENT || childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; If the menu&#39;s height is set to match_parent&#x2F;wrap_content then measure it</span><br><span class="line">            &#x2F;&#x2F; with the maximum visible height</span><br><span class="line"></span><br><span class="line">            final List&lt;View&gt; dependencies &#x3D; parent.getDependencies(child);</span><br><span class="line">            final View header &#x3D; findFirstDependency(dependencies);</span><br><span class="line">            if (header !&#x3D; null) &#123;</span><br><span class="line">                if (ViewCompat.getFitsSystemWindows(header) &amp;&amp; !ViewCompat.getFitsSystemWindows(child)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If the header is fitting system windows then we need to also,</span><br><span class="line">                    &#x2F;&#x2F; otherwise we&#39;ll get CoL&#39;s compatible measuring</span><br><span class="line">                    ViewCompat.setFitsSystemWindows(child, true);</span><br><span class="line"></span><br><span class="line">                    if (ViewCompat.getFitsSystemWindows(child)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If the set succeeded, trigger a new layout and return true</span><br><span class="line">                        child.requestLayout();</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (ViewCompat.isLaidOut(header)) &#123;</span><br><span class="line">                    int availableHeight &#x3D; View.MeasureSpec.getSize(parentHeightMeasureSpec);</span><br><span class="line">                    if (availableHeight &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If the measure spec doesn&#39;t specify a size, use the current height</span><br><span class="line">                        availableHeight &#x3D; parent.getHeight();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final int height &#x3D; availableHeight - header.getMeasuredHeight() + getScrollRange(header);</span><br><span class="line">                    final int heightMeasureSpec &#x3D; View.MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.MATCH_PARENT ? View.MeasureSpec.EXACTLY : View.MeasureSpec.AT_MOST);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Now measure the scrolling view with the correct height</span><br><span class="line">                    parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed);</span><br><span class="line"></span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void layoutChild(final CoordinatorLayout parent, final View child, final int layoutDirection) &#123;</span><br><span class="line">        final List&lt;View&gt; dependencies &#x3D; parent.getDependencies(child);</span><br><span class="line">        final View header &#x3D; findFirstDependency(dependencies);</span><br><span class="line"></span><br><span class="line">        if (header !&#x3D; null) &#123;</span><br><span class="line">            final CoordinatorLayout.LayoutParams lp &#x3D; (CoordinatorLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">            final Rect available &#x3D; mTempRect1;</span><br><span class="line">            available.set(parent.getPaddingLeft() + lp.leftMargin, header.getBottom() + lp.topMargin,</span><br><span class="line">                    parent.getWidth() - parent.getPaddingRight() - lp.rightMargin,</span><br><span class="line">                    parent.getHeight() + header.getBottom() - parent.getPaddingBottom() - lp.bottomMargin);</span><br><span class="line"></span><br><span class="line">            final Rect out &#x3D; mTempRect2;</span><br><span class="line">            GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(), child.getMeasuredHeight(), available, out, layoutDirection);</span><br><span class="line"></span><br><span class="line">            final int overlap &#x3D; getOverlapPixelsForOffset(header);</span><br><span class="line"></span><br><span class="line">            child.layout(out.left, out.top - overlap, out.right, out.bottom - overlap);</span><br><span class="line">            mVerticalLayoutGap &#x3D; out.top - header.getBottom();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If we don&#39;t have a dependency, let super handle it</span><br><span class="line">            super.layoutChild(parent, child, layoutDirection);</span><br><span class="line">            mVerticalLayoutGap &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float getOverlapRatioForOffset(final View header) &#123;</span><br><span class="line">        return 1f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int getOverlapPixelsForOffset(final View header) &#123;</span><br><span class="line">        return mOverlayTop &#x3D;&#x3D; 0</span><br><span class="line">                ? 0</span><br><span class="line">                : MathUtils.constrain(Math.round(getOverlapRatioForOffset(header) * mOverlayTop),</span><br><span class="line">                0, mOverlayTop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int resolveGravity(int gravity) &#123;</span><br><span class="line">        return gravity &#x3D;&#x3D; Gravity.NO_GRAVITY ? GravityCompat.START | Gravity.TOP : gravity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract View findFirstDependency(List&lt;View&gt; views);</span><br><span class="line"></span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        return v.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The gap between the top of the scrolling view and the bottom of the header layout in pixels.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int getVerticalLayoutGap() &#123;</span><br><span class="line">        return mVerticalLayoutGap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set the distance that this view should overlap any &#123;@link AppBarLayout&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param overlayTop the distance in px</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final void setOverlayTop(int overlayTop) &#123;</span><br><span class="line">        mOverlayTop &#x3D; overlayTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the distance that this view should overlap any &#123;@link AppBarLayout&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final int getOverlayTop() &#123;</span><br><span class="line">        return mOverlayTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个基类的代码还是很好理解的，因为之前就说过了，正常来说被依赖的 View 会优先于依赖它的 View 处理，所以需要依赖的 View 可以在 measure/layout 的时候，找到依赖的 View 并获取到它的测量/布局的信息，这里的处理就是依靠着这种关系来实现的.</p>
<p>我们的实现类，需要重写的除了抽象方法 findFirstDependency 外，还需要重写 getScrollRange，我们把 Header<br>的 Id id_weibo_header 定义在 ids.xml 资源文件内，方便依赖的判断.</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzI1ZWZiMTA?x-oss-process=image/format,png"></p>
<p>至于缩放的高度，根据 结果图 得知是 0，得出如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int getFinalHeight() &#123;</span><br><span class="line">     Resources resources &#x3D; BaseAPP.getInstance().getResources();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        if (isDependOn(v)) &#123;</span><br><span class="line">            return Math.max(0, v.getMeasuredHeight() - getFinalHeight());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.getScrollRange(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="第二个关键点的实现："><a href="#第二个关键点的实现：" class="headerlink" title="第二个关键点的实现："></a>第二个关键点的实现：</h3><p>Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。</p>
<p>主要的逻辑就是 在 layoutDependsOn 方法里面，判断 dependcy  是不是 HeaderView  ，是的话，返回TRUE，这样在 Header 位置发生变化的时候，会回调 onDependentViewChanged 方法，在该方法里面，做相应的偏移。TranslationY 是根据比例算出来的   translationY = (int) (-dependencyTranslationY / (getHeaderOffsetRange() * 1.0f) * getScrollRange(dependency));</p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WeiboContentBehavior extends HeaderScrollingViewBehavior &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;WeiboContentBehavior&quot;;</span><br><span class="line"></span><br><span class="line">    public WeiboContentBehavior() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboContentBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        return isDependOn(dependency);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onDependentViewChanged&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        offsetChildAsNeeded(parent, child, dependency);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void offsetChildAsNeeded(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        float dependencyTranslationY &#x3D; dependency.getTranslationY();</span><br><span class="line">        int translationY &#x3D; (int) (-dependencyTranslationY &#x2F; (getHeaderOffsetRange() * 1.0f) * </span><br><span class="line">                getScrollRange(dependency));</span><br><span class="line">        Log.i(TAG, &quot;offsetChildAsNeeded: translationY&#x3D;&quot; + translationY);</span><br><span class="line">        child.setTranslationY(translationY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected View findFirstDependency(List&lt;View&gt; views) &#123;</span><br><span class="line">        for (int i &#x3D; 0, z &#x3D; views.size(); i &lt; z; i++) &#123;</span><br><span class="line">            View view &#x3D; views.get(i);</span><br><span class="line">            if (isDependOn(view)) return view;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        if (isDependOn(v)) &#123;</span><br><span class="line">            return Math.max(0, v.getMeasuredHeight() - getFinalHeight());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.getScrollRange(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getHeaderOffsetRange() &#123;</span><br><span class="line">        return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen</span><br><span class="line">                .weibo_header_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getFinalHeight() &#123;</span><br><span class="line">        Resources resources &#x3D; BaseAPP.getInstance().getResources();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isDependOn(View dependency) &#123;</span><br><span class="line">        return dependency !&#x3D; null &amp;&amp; dependency.getId() &#x3D;&#x3D; R.id.id_weibo_header;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul>
<li>NestedScrolling 机制，对比传统的事件分发机制真的很强大。这种仿新浪微博发现页效果， 如果用传统的事件分发机制来做，估计很难实现，处理起来会有一大堆坑。</li>
<li>看完了这种仿新浪微博发现页的效果，你是不是学到了什么?如果让你 模仿 仿 QQ 浏览器首页效果，你能实现话。</li>
</ul>
<p>最后，特别感谢写这篇博客 <a href="http://www.jianshu.com/p/f7989a2a3ec2">自定义Behavior的艺术探索-仿UC浏览器主页</a> 的开发者，没有这篇博客作为参考，这种效果我很大几率是实现 不了的。大家觉得效果还不错的话，顺手到 github 上面给我 star，谢谢。<a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample">github 地址</a></p>
<hr>
<p>参考文章：</p>
<p><a href="http://www.jianshu.com/p/f7989a2a3ec2">自定义Behavior的艺术探索-仿UC浏览器主页</a></p>
<p><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample">github 地址</a></p>
<p>最后的最后，卖一下广告，欢迎大家关注我的微信公众号 徐公码字，扫一扫下方二维码或搜索微信号 stormjun94，即可关注。 目前专注于 Android 开发，主要分享 Android开发相关知识和一些相关的优秀文章，包括个人总结，职场经验等。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzM2YmMyMDc?x-oss-process=image/format,png"></p>
]]></content>
  </entry>
  <entry>
    <title>16年，平凡而又收获的一年</title>
    <url>/2016/12/31/16%E5%B9%B4%EF%BC%8C%E5%B9%B3%E5%87%A1%E8%80%8C%E5%8F%88%E6%94%B6%E8%8E%B7%E7%9A%84%E4%B8%80%E5%B9%B4/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53958513">文章首发地址CSDN:</a></p>
<p>岁月如水，时间飞逝，转眼间，已经到了年尾，即将引来新的一年，我要赶紧抓住16年的尾巴，写篇文章记录一下我16年的点点滴滴。篇章大概如下，学习&amp;工作室篇，实习篇，盛夏六月， 博客篇，秋招篇，情感篇，展望未来。</p>
<h2 id="学习-amp-工作室篇"><a href="#学习-amp-工作室篇" class="headerlink" title="学习&amp;工作室篇"></a><strong>学习&amp;工作室篇</strong></h2><p><img src="http://ww3.sinaimg.cn/mw690/9fe4afa0jw1fbabc2n6myj206g064aa3.jpg"></p>
<p>春节弹指一瞬间，转眼间已经到了正月18，迷恋着春节家人朋友团聚时候喜悦的气氛，我依依不舍地乘着大巴回到了学校，开始新的学期。在大学的时光里，没有想高三时光一样，三点一线。在大学里，多的是自由。每天，我往返于工作室和宿舍之间，那时每天只想着能争取多点时间 学习自己感兴趣的东西————也就是我现在所从事的职业Android开发。每天为了挤出一个多小时的时间来学习，尝试过中午不睡觉，坚持了两个多星期。结果是中午不睡，晚上崩溃———下午不睡觉，下午学习的时候还是精神蓬勃的，到了晚上，睡意就来了，经常打瞌睡。结果呢，相信你也猜到了，学习的东西反而少了，效率下降了好多。</p>
<p>原因，浅而明显，第一，一个人的精力是有限的，我们要注意劳逸结合；第二，以前我都是有午睡的习惯的，突然改变了习惯，肯定要有一段适应期。</p>
<p>至于说到劳逸结合，高中的时候就深有体会，大学写编程的时候更是深深刻在心里。有时候，写编程，在调bug的时候，在哪里捣鼓了几个小时，终究是被它折服了，被它弄得心浮气躁。这时候不烦放下手头的工作，出去走走，感受一下大自然，放松一下头脑，接着回来工作，许多时候你会发现bug一下子就解决了。这个时候你通常我会感慨，我擦，我是一个傻逼，这么简单的问题竟然弄了这么久，心里头不禁也涌上来一股满足感————那是一种付出辛苦努力而得到的满足。</p>
<p>有许多人说，写编程会让一个人性格变得烦躁。哈哈，有时候确实会，不过，有时候我更想说的是，写编程往往是我们变得更加耐心和细心。每一次我们在跟bug作斗争的时候，我们的耐心正在一点点培养。</p>
<p>许多人说程序员活像闷葫芦，<strong>钱多话少死得早</strong>。怎么说呢，这句话还是有一点道理的，首先钱多呢，这个就不必详讲了，相对大多数打工族来说，程序猿的工资相对来是还是比较高的。话少呢，确实也有一定的道理，因为我们整天面对的是电脑，比较少与人沟通交流，久而久之，语言表达能力肯定会退化不少的，有时候在与人交谈中，也不知道谁聊什么话题好，这就给了大家一种印象——话少。至于“死得早”，我们知道程序猿加班相对比较多，尤其是项目要上线的时候，经常会加班，而且工作强度相对来说有比较强。确实，如果你不注意锻炼的话，真的对身体伤害很大的。但只要你注意一下，每个星期坚持两三次锻炼，也是照样精神饱满的。</p>
<h2 id="实习篇"><a href="#实习篇" class="headerlink" title="实习篇"></a><strong>实习篇</strong></h2><p><img src="http://ww1.sinaimg.cn/mw690/9fe4afa0jw1fbabdkdyimj209s064glk.jpg"></p>
<p>说起实习的那段时间，那真的是一段艰辛岁月。每天实习完回到宿舍，有时候身心俱疲，根本就提不起精神来继续学习，我也因此颓废了一段时间，每天回到宿舍后，就开始看电影，看电视剧——后面我调整了自己的状态，在实习完回来的时候继续学习。</p>
<p>如果你问我那段时间累不累？我可以很肯定地告诉你，累成狗。但是我从未后悔过，因为一段岁月过得很充实，正如我们高三备考的那段岁月——只为心中的那一个目标。</p>
<h2 id="盛夏六月"><a href="#盛夏六月" class="headerlink" title="盛夏六月"></a><strong>盛夏六月</strong></h2><p><img src="http://ww1.sinaimg.cn/mw690/9fe4afa0jw1fbabcvlqtmj20av064q31.jpg"></p>
<p>每天的五六月份，都是我们学校的毕业季。送走了一拨人，又即将引来新的一拨人，注入新的血液。在这段时间，对我感触最深的是，应该是我二哥和我社团的几个师兄和师姐牌毕业照的时候，他们说大学时光飞快，要好好珍惜接下来的大学时光。</p>
<p>有时候也在想，一年后的自己会是怎样的呢？</p>
<p><strong>真的很感谢他们，曾今他们在我大学最迷茫的时候引导了我，为我指点迷津。</strong></p>
<h2 id="博客篇"><a href="#博客篇" class="headerlink" title="博客篇"></a><strong>博客篇</strong></h2><p><img src="http://ww2.sinaimg.cn/mw690/9fe4afa0jw1fbabeiodgfj208l064jrf.jpg"></p>
<p>我正式写博客的时候应该是四月底五月初的时候，像大多数人一样，刚开始写博客的时候完全没有思路，写出来的文章条理性差，访问量也很少。我记忆比较深的一篇博客是我在写这篇博客的时候：<br><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51292440">二分查找的相关算法题</a> ，那时候些博客写到深夜12点多，就发布了出去，第二天醒来，访问量竟然超过一千了。一千的访问量对于经常写博客或者有一定知名度的博客来说，根本就是小菜一碟，算不了什么。但对于我之前几篇博客都是几十最多一百多的访问量的人来说，这无疑是意义非凡的。这意味着对我这篇博客质量的认可，正如我们付出的努力得到认可的喜悦一样。</p>
<h3 id="为什么写博客呢"><a href="#为什么写博客呢" class="headerlink" title="为什么写博客呢"></a>为什么写博客呢</h3><p>（当然我不是在说我写博客有多了不起，我只是在分享一下自己的经历而已————  一些人或许会这样想，坚持写博客有什么了不起的，网上一大堆人在写博客，怎么不见他们在说写博客辛苦，或者吹捧。<strong>有一些腹黑的人更恶劣的，甚至会骂你，谴责你，不懂得谦虚，骄傲自大。</strong>  </p>
<p>对于第一类人，分情况讨论一下，如果是那种整天无所事事的人，那我会嗤之以鼻，如果是那种很努力的人，整天辛苦奋斗的人，那我们写博客确实算不了什么。</p>
<p>而对于那些动不动就站在道德制高点的那些人，我真的不知道说写什么说。这种人我们真的不必跟他们太较真，较真你就输了。</p>
<p>总之，说了这么久，只想表达这样的意思，坚持走自己认为正确的路，世界那么大，让别人说去吧。</p>
<p>这里分享一个故事，是几天前发生的，是Android开发者 StormhZhang 的故事，故事概要是这样的，StromZhang 在他的公众号推送了一篇广告，结果有一些人就说他作为一名技术总监，还发广告，差不差这点钱，进而有提升到道德方面，有一些人更过分，甚至流言谩骂。殊不知他做技术分享帮助了多少人？这里就不过多介绍了，欲知详情，请自行搜索。</p>
<p>哈哈，扯蛋了这么久，终于来说我能够坚持下来写博客的原因呢？原因其实很简单，对于经常写博客的人，我相信他们都有一个共同点，写着写着就爱上博客了。即使说没有写博客，也喜欢用笔记将自己认为有价值的东西记录下来，just so<br>simple。当然，写博客有几个好处，锻炼自己的写作能力，提高自己的思维，更难能可贵的是，你能够在写博客的时候遇到一些志同道合的朋友。目前我还没有遇到，<strong>期待img</strong>，说一下我的一个经历，之前有一个技术疑问一直解决不了，后面在写相关博客的时候，在博客的最后提了出来，后面有热心的网友帮忙解答了，那时候真的很感动。</p>
<h2 id="秋招篇"><a href="#秋招篇" class="headerlink" title="秋招篇"></a><strong>秋招篇</strong></h2><p>说起我的秋招之旅，可能对于身边的人来说，我相对是比较轻松的。可是对于许多大神来说，差的还不是一截半截。记得我经常说过一句话，比上不足，比下有余。</p>
<p>八月中旬的时候，秋招的号角正式吹响了。刚开始是一些BAT之类的公司内推，筛选简历或者笔试，很遗憾，我全部都没有通过。九月中旬的时候，BAT，网易，CVTE等这些知名企业开始校招了，很遗憾笔试也是全部没有通过。一方面是今年校招缩水了，招的人很少，一方面可能自己的笔试成绩也不是十分突出。那时候，心底是有点慌的，因为校招开始了半个多月，竟然一个笔试都没有通过，面试也没有。</p>
<p>于是，我自己独自一人来到腾讯面试的地方——喜来登大酒店，想去霸面。刚开始，想趁着他们在面试的时候跟着他们上去，可是还是被挡在电梯外面了。于是就去霸面区交了简历，后面想“趁水摸鱼” 坐上电梯，直接去找面试官，跟他说想霸面。可是还是被挡在第一外面了。于是就没有继续找机会坐上电梯去了。结果的最后，就是在里面空坐了一天，霸面fail，一天就这样 get over。其实，那时候如果真的下定决心要上去的话，机会还是很大的，等到有房可上去的时候，跟他们一起上去就好了。之所以当时没有那样做，可能自己还没有足够的信心。可是去之前是信心满满要去霸面的，可到现场遇到一点小阻碍却退却了，也许这就是我性格的一个弱点吧。</p>
<p>到了九月底的时候，也开始面试了，陆续收到了美图，久邦数码，步步高等公司的offer，最终签了美图公司，在十月初的时候也结束了我的秋招之旅。</p>
<p>在秋招，对于面试，我也没有一些很好的技巧。对于技术岗位的，我只能说三分口才，七分实力。对于搞技术的人，千万不要忽略语言表达能力方面的培养与提高，一方面在面试的时候你会吃很大亏，另一方面对你以后人生的发展也是很不利的。我在表达这方面就吃过挺多亏的，现在表达能力还是有待提高。</p>
<h2 id="情感篇"><a href="#情感篇" class="headerlink" title="情感篇"></a><strong>情感篇</strong></h2><p>说了这么久，来稍微说一点轻松一点的东西呢？那就是说情感方面的呢，其实我的情感篇真的没什么可说的，大学到现在也没谈过恋爱，可能是一直没有遇到合适的人吧，或者是我的情商有点低吧。谁说得清楚呢？</p>
<p>至于亲情方面，我想说的是，有空就多回家看看吧。对于父母来说，子女经常回家就是最好的礼物呢，比得多钱财万贯。</p>
<h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p><img src="http://ww2.sinaimg.cn/mw690/9fe4afa0jw1fbabfpa3r9j20b2064jrg.jpg"></p>
<p>旧的一年即将过去了，新的一年即将到来。在新的一年，大概有以下计划</p>
<ol>
<li>在毕业前来一次说走你就走的旅行（不过到时候实习不知道有没有时间，尽量争取吧）</li>
<li>CSDN争取申请到博客专家号，现在是准博客专家</li>
</ol>
<p>截张图记录一下我现在博客的访问量</p>
<p><img src="http://ww3.sinaimg.cn/large/9fe4afa0jw1fbab6l662fj20770el753.jpg"></p>
<p>17年，即将到来的新的一年，希望家人朋友身体健康，实习，工作顺利。最后的最后，为了青春和热血，再次拼搏加油，致我的青春，青春万岁。</p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53958513">文章首发地址CSDN:</a></p>
]]></content>
  </entry>
  <entry>
    <title>你真的了解View的坐标吗？</title>
    <url>/2016/12/12/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3View%E7%9A%84%E5%9D%90%E6%A0%87%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53700020">文章首发CSDN地址 :</a></p>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>View，对我们来说在熟悉不过了，从接触Android开始，我们就一直在接触View，界面当中到处都是 View，比如我们经常用到的TextView，Button，LinearLayout等等，但是我们真的了解View吗？尤其是View的坐标。mLeft,mRight,mY,mX,mTranslationY,mScoollY,相对于屏幕的坐标等等这些概念你真的清楚了吗？如果真的清楚了，那你没有必要读这篇博客，如果你还是有一些模糊，建议花上几分钟的时间读一下。</p>
<p>为什么要写这一篇博客呢？</p>
<p>因为掌握View的坐标很重要，尤其是对于自定义View，学习动画有重大的意义。</p>
<p>这篇博客主要讲解一下问题</p>
<ul>
<li>View 的 getLeft（）和get Right（）和  getTop（） 和getBottom（）</li>
<li>View 的 getＹ（）， getTranslationY() 和 getTop（） 之间的联系</li>
<li>View 的  getScroolY  和 View 的 scrollTo() 和 scrollBy（）</li>
<li>event.getY 和  event.getRawY()</li>
<li>扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faog7dpkajj20a90i70ty.jpg"></p>
<p> 简单说明一下（上图Activity采用默认Style，状态栏和标题栏都会显示）：最大的草绿色区域是屏幕界面，红色次大区域我们称之为“应用界面区域”，最小紫色的区域我们称之为“View绘制区域”；屏幕顶端、应用界面区之外的那部分显示手机电池网络运营商信息的为“状态栏”，应用区域顶端、View绘制区外部显示Activity名称的部分我们称为“标题栏”。</p>
<p>从这张图片我们可以看到<br>在Android中，当ActionBar存在的情况下，</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">屏幕的 高度=状态栏+应用区域的高度=状态栏的 高度+（标题栏的 高度+<span class="keyword">View</span> 绘制区域的高度）</span><br></pre></td></tr></table></figure>


<p>当ActionBar不存在的情况下</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">屏幕的高度=状态栏+应用区域的高度=状态栏的 高度+（<span class="keyword">View</span> 绘制区域的 高度）</span><br></pre></td></tr></table></figure>



<h2 id="View-的-getLeft（）和getRight（）和-getTop（）-和getBottom（）"><a href="#View-的-getLeft（）和getRight（）和-getTop（）-和getBottom（）" class="headerlink" title="View 的 getLeft（）和getRight（）和  getTop（） 和getBottom（）"></a>View 的 getLeft（）和getRight（）和  getTop（） 和getBottom（）</h2><figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span>.getLeft<span class="literal">()</span> ;</span><br><span class="line"><span class="type">View</span>.getTop<span class="literal">()</span> ;</span><br><span class="line"><span class="type">View</span>.getBottom<span class="literal">()</span>;</span><br><span class="line"><span class="type">View</span>.getRight<span class="literal">()</span> ; </span><br></pre></td></tr></table></figure>

<p>top是左上角纵坐标，left是左上角横坐标，right是右下角横坐标，bottom是右下角纵坐标,都是相对于它的<strong>直接父View</strong>而言的，而不是相对于<strong>屏幕</strong>而言的。这一点要区分清楚。那那个坐标是相对于屏幕而言的呢，以及要怎样获取相对于屏幕的坐标呢？</p>
<p>目前View里面的变量还没有一个是相对于屏幕而言的，但是我们可以获取到相对于屏幕的坐标。一般来说，我们要获取View的坐标和高度 等，都必须等到View绘制完毕以后才能获取的到，在Activity 的 onCreate（）方法 里面 是获取不到的，必须 等到View绘制完毕以后才能获取地到View的响应的坐标，一般来说，主要 有以下两种方法。</p>
<p>第一种方法，onWindowFocusChanged（）方法里面进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onWindowFocusChanged(hasFocus); </span><br><span class="line">  <span class="comment">//确保只会调用一次</span></span><br><span class="line">   <span class="keyword">if</span>(first)&#123;</span><br><span class="line">     first=<span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];     </span><br><span class="line">     mView.getLocationOnScreen(location);</span><br><span class="line">     <span class="keyword">int</span> x1 = location[<span class="number">0</span>]  ;</span><br><span class="line">     <span class="keyword">int</span> y1 = location[<span class="number">1</span>]  ;</span><br><span class="line">     Log.i(TAG, <span class="string">&quot;onCreate: x1=&quot;</span> +x1);</span><br><span class="line">     Log.i(TAG, <span class="string">&quot;onCreate: y1=&quot;</span> +y1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法，在视图树绘制完成的时候进行测量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver</span><br><span class="line">        .OnGlobalLayoutListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//   移除监听器，确保只会调用一次，否则在视图树发挥改变的时候又会调用</span></span><br><span class="line">        mView.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        mView.getLocationOnScreen(location);</span><br><span class="line">        <span class="keyword">int</span> x1 = location[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y1 = location[<span class="number">1</span>];</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate: x1=&quot;</span> + x1);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate: y1=&quot;</span> + y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>




<h2 id="View-的-getY（），-getTranslationY-和-getTop（）-之间的联"><a href="#View-的-getY（），-getTranslationY-和-getTop（）-之间的联" class="headerlink" title="View 的 getＹ（）， getTranslationY() 和 getTop（） 之间的联"></a>View 的 getＹ（）， getTranslationY() 和 getTop（） 之间的联</h2><p>getＹ（）</p>
<blockquote>
<p>Added in API level 14<br>The visual y position of this view, in pixels.(返回的是View视觉上的图标，即我们眼睛看到位置的Y坐标，注意也是相对于<strong>直接父View</strong>而言的默认值跟getTop（）相同，别急，下面会解释）</p>
</blockquote>
<p>getTranslationY()</p>
<blockquote>
<p>Added in API level 14<br>The vertical position of this view relative to its top position, in pixels.(竖直方向上相对于top的偏移量，默认值为0）</p>
</blockquote>
<p>那 getY（） 和 getTranslationY（） 和 getTop （） 到底有什么关系呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;drawing&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> mTop + getTranslationY();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;drawing&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTranslationY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRenderNode.getTranslationY();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ViewDebug</span>.CapturedViewProperty</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从以上的源码我们可以知道 getY（）= getTranslationY（）+ getTop （），而 getTranslationY（） 的默认值是0，除非我们通过 setTranlationY（） 来改变它，这也就是我们上面上到的 getY 默认值跟 getTop（）相同</p>
<p>那我们要怎样改变 top值 和 Y 值呢？ 很明显就是调用相应的set方法 ，即 setY（） 和setTop（） ，就可以改变他们 的值。</p>
<h2 id="View-的-getScroolY-和-View-的-scrollTo-和-scrollBy（）"><a href="#View-的-getScroolY-和-View-的-scrollTo-和-scrollBy（）" class="headerlink" title="View 的  getScroolY  和 View 的 scrollTo() 和 scrollBy（）"></a>View 的  getScroolY  和 View 的 scrollTo() 和 scrollBy（）</h2><p>getScrollY是一个比较特别的函数，因为它涉及一个值叫mScrollY，简单说，getScrollY一般得到的都是0，除非你调用过scrollTo或scrollBy这两个函数来改变它。</p>
<h3 id="scrollTo-和-scrollBy（）"><a href="#scrollTo-和-scrollBy（）" class="headerlink" title="scrollTo() 和 scrollBy（）"></a>scrollTo() 和 scrollBy（）</h3><p>从字面意思我们可以知道 scrollTo() 是滑动到哪里的意思 ，scrollBy（）是相对当前的位置滑动了多少。当然这一点在源码中也是可以体现出来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有几点需要注意的是</p>
<ul>
<li>不论是scrollTo或scrollBy，其实都是对View的内容进行滚动而不是对View本身，你可以做个小实验，一个LinearLayouy背景是黄色，里面放置一个子LinearLayout背景是蓝色，调用scrollTo或scrollBy，移动的永远是蓝色的子LinearLayout。</li>
<li>还有就是scrollTo和scrollBy函数的参数和坐标系是“相反的”，比如scrollTo(-100,0)，View的内容是向X轴正方向移动的，这个相反打引号是因为并不是真正的相反，具体可以看源码，关于这两个函数的源码分析大家可以看<a href="http://blog.csdn.net/xplee0576/article/details/24242383?utm_source=tuicool&utm_medium=referral">Android——源码角度分析View的scrollBy()和scrollTo()的参数正负问题</a>，一目了然。</li>
</ul>
<h2 id="View-的-width-和-height"><a href="#View-的-width-和-height" class="headerlink" title="View 的 width 和 height"></a>View 的 width 和 height</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;layout&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Android的 height 是由 mBottom  和 mTop 共同得出的，那我们要怎样设置Android的高度呢？有人会说直接在xml里面设置 android:height=””  不就OK了，那我们如果要动态设置height的高度呢，怎么办？你可能会想到 setWidth（）方法？但是我们找遍了View的所有方法，都没有发现 setWidth（）方法，那要怎样动态设置height呢？其实有两种方法</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">int</span> <span class="built_in">width</span>=<span class="number">50</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">height</span>=<span class="number">100</span>;</span><br><span class="line">ViewGroup.LayoutParams layoutParams = view.getLayoutParams();</span><br><span class="line"><span class="keyword">if</span>(layoutParams==<span class="keyword">null</span>)&#123;</span><br><span class="line">    layoutParams=<span class="keyword">new</span> ViewGroup.LayoutParams(<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    layoutParams.<span class="built_in">height</span>=<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line">view.setLayoutParams(layoutParams);</span><br></pre></td></tr></table></figure>

<p>第二种方法，单独地改变top或者bottom的值，这种方法不推荐使用</p>
<p>至于width，它跟height基本一样，只不过它是有mRight 和mLeft 共同决定而已。</p>
<p>需要注意的是，平时我们在执行动画的过程，不推荐使用LayoutParams来改变View的状态，因为改变LayoutParams会调用requestLayout（）方法，会标记当前View及父容器，同时逐层向上提交，直到ViewRootImpl处理该事件，ViewRootImpl会调用三大流程，从measure开始，对于每一个含有标记位的view及其子View都会进行测量、布局、绘制，性能较差，源码体现如下：关于requestLayout （）方法的更多分析可以查看这一篇博客<a href="http://blog.csdn.net/a553181867/article/details/51583060">Android View 深度分析requestLayout、invalidate与postInvalidate</a></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLayoutParams</span>(<span class="params">ViewGroup.LayoutParams <span class="keyword">params</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">params</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Layout parameters cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayoutParams = <span class="keyword">params</span>;</span><br><span class="line">    resolveLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (mParent instanceof ViewGroup) &#123;</span><br><span class="line">        ((ViewGroup) mParent).onSetLayoutParams(<span class="keyword">this</span>, <span class="keyword">params</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们如果在api 14 以后 ，在动画执行过程中，要改变View的状态，推荐使用setTranslationY（）和setTranslationX（0等方法，而 尽量避免改变LayoutParams.因为性能嫌贵来说较差。</p>
<h2 id="event-getY-和-event-getRawY"><a href="#event-getY-和-event-getRawY" class="headerlink" title="event.getY() 和  event.getRawY()"></a>event.getY() 和  event.getRawY()</h2><p> 要区分于MotionEvent.getRawX() 和MotionEvent.getX();,</p>
<p>在public boolean onTouch(View view, MotionEvent event) 中，当你触到控件时，x,y是相对于该控件左上点（控件本身）的相对位置。 而rawx,rawy始终是相对于屏幕的位置。getX()是表示Widget相对于自身左上角的x坐标,而getRawX()是表示相对于屏幕左上角的x坐标值 (注意:这个屏幕左上角是手机屏幕左上角,不管activity是否有titleBar或是否全屏幕)。</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0jw1faplvwpqj3j207c06aaa5.jpg"></p>
<h2 id="扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度"><a href="#扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度" class="headerlink" title="扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度"></a>扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class="line">    super.onWindowFocusChanged(hasFocus);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;屏幕</span><br><span class="line">    DisplayMetrics dm &#x3D; new DisplayMetrics();</span><br><span class="line">    getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">    Log.e(TAG, &quot;屏幕高:&quot; + dm.heightPixels);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;应用区域</span><br><span class="line">    Rect outRect1 &#x3D; new Rect();</span><br><span class="line">    getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1);</span><br><span class="line">    &#x2F;&#x2F;这个也就是状态栏的 高度</span><br><span class="line">    Log.e(TAG, &quot;应用区顶部&quot; + outRect1.top);</span><br><span class="line">    </span><br><span class="line">    Log.e(TAG, &quot;应用区高&quot; + outRect1.height());</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这个方法必须在有actionBar的情况下才能获取到状态栏的高度</span><br><span class="line">    &#x2F;&#x2F;View绘制区域</span><br><span class="line">    Rect outRect2 &#x3D; new Rect();</span><br><span class="line">    getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(outRect2);</span><br><span class="line">    Log.e(TAG, &quot;View绘制区域顶部-错误方法：&quot; + outRect2.top);   &#x2F;&#x2F;不能像上边一样由outRect2.top获取，这种方式获得的top是0，可能是bug吧</span><br><span class="line">    Log.e(TAG, &quot;View绘制区域高度：&quot; + outRect2.height());</span><br><span class="line"></span><br><span class="line">    int viewTop &#x3D; getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();   &#x2F;&#x2F;要用这种方法</span><br><span class="line">    Log.e(TAG, &quot;View绘制区域顶部-正确方法：&quot; + viewTop);</span><br><span class="line"></span><br><span class="line">    int titleBarHeight&#x3D;viewTop;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, &quot;onWindowFocusChanged: 标题栏高度titleBarHeight&#x3D;&quot; +titleBarHeight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这里我们需要注意的 是在ActionBar存在的情况下，通过这种方法我们才能够得出titleBar的高度，否则是无法得到的，因为viewTop 为0.</p>
<hr>
<p>这篇博客到此为止，关于更多自定义View 的一些例子，可以看我以下的博客 </p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51765428"><strong>常用的自定义View例子一(FlowLayout)</strong></a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51772308"><strong>自定义View常用例子二（点击展开隐藏控件，九宫格图片控件）</strong></a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51804844"><strong>常用的自定义View例子三（MultiInterfaceView多界面处理）</strong></a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51804865"><strong>常用的自定义控件四（QuickBarView）</strong></a></p>
]]></content>
  </entry>
  <entry>
    <title>手把手教你用Hexo+Github 搭建属于自己的博客</title>
    <url>/2016/12/11/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8Hexo-Github-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>程序员徐公，希望让你看到程序猿不同的一面，除了分享 Coding，，还有职场心得，面试经验，学习心得，人生感悟等等。希望通过该公众号，我们不只会敲代码，我们还会。。。。。。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210406233311953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>在大三的时候，一直就想搭建属于自己的一个博客，但由于各种原因，最终都不了了之，恰好最近比较有空，于是就自己参照网上的教程，搭建了属于自己的博客。</p>
<p>至于为什么要搭建自己的博客了？</p>
<p>哈哈，大概是为了装逼吧，同时自己搭建博客的话，样式的选择也比较自由，可以自己选择，不需要受限于各大平台。</p>
<p>转载请注明原博客地址：<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">手把手教你用Hexo+Github 搭建属于自己的博客</a></p>
<p>大概可以分为以下几个步骤</p>
<ol>
<li>搭建环境准备（包括node.js和git环境，gitHub账户的配置）</li>
<li>安装Hexo</li>
<li>配置Hexo</li>
<li>怎样将Hexo与github page 联系起来</li>
<li>怎样发布文章</li>
<li>主题 推荐</li>
<li>主题Net的简单配置</li>
<li>添加sitemap和feed插件</li>
<li>添加404 公益页面</li>
</ol>
<h2 id="搭建环境准备"><a href="#搭建环境准备" class="headerlink" title="搭建环境准备"></a><strong>搭建环境准备</strong></h2><p>大概可以分为以下三步</p>
<ul>
<li>Node.js 的安装和准备</li>
<li>git的安装和准备</li>
<li>gitHub账户的配置</li>
</ul>
<h3 id="配置Node-js环境"><a href="#配置Node-js环境" class="headerlink" title="配置Node.js环境"></a>配置Node.js环境</h3><ol>
<li>下载Node.js安装文件：</li>
</ol>
<ul>
<li><a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi">Windows Installer 32-bit</a></li>
<li><a href="https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi">Windows Installer 64-bit</a></li>
</ul>
<p>根据自己的Windows版本选择相应的安装文件，要是不知道，就安装32-bit的吧- -。 如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/573d6502fed68f7b6088bff827f5d38a.png"></p>
<p>保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：</p>
<p>Windows的运行界面</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191348220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。</p>
<p><img src="https://img-blog.csdnimg.cn/2021041719141554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="配置Git环境"><a href="#配置Git环境" class="headerlink" title="配置Git环境"></a>配置Git环境</h3><p>下载Git安装文件：</p>
<p><a href="https://git-scm.com/downloads">GIt官网下载地址：</a></p>
<p><a href="https://github-cloud.s3.amazonaws.com/releases/23216272/84b33b96-87f5-11e5-8f91-32080286239e.exe?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAISTNZFOVBIJMK3TQ/20161210/us-east-1/s3/aws4_request&X-Amz-Date=20161210T033734Z&X-Amz-Expires=300&X-Amz-Signature=912c155bbe0fe970ca7b948f5f0d5e8c68c712b7fb8006062f53c8638c62c7b6&X-Amz-SignedHeaders=host&actor_id=14971673&response-content-disposition=attachment;%20filename=Git-2.6.3-64-bit.exe&response-content-type=application/octet-stream">Git-2.6.3-64-bit.exe</a></p>
<p>然后就进入了Git的安装界面，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191433141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Git安装界面</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9800536a9332846c27e3e0d7d6449ae9.png"></p>
<p>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：</p>
<p>Git PATH设置</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e0e7904ab77974fd281801aa30dee01e.png"></p>
<p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。<br>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191452606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>关于 git的下载即安装，可以参考我的这一篇博客： <a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></p>
<h3 id="github账户的注册和配置"><a href="#github账户的注册和配置" class="headerlink" title="github账户的注册和配置"></a>github账户的注册和配置</h3><p>如果已经拥有账号，请跳过此步~</p>
<p>第一步: Github注册</p>
<p>打开<a href="https://github.com/%EF%BC%8C%E5%9C%A8%E4%B8%8B%E5%9B%BE%E7%9A%84%E6%A1%86%E4%B8%AD%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%8C%E9%82%AE%E7%AE%B1%EF%BC%8C%E5%AF%86%E7%A0%81%E3%80%82">https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210417191509394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。</p>
<p>一定要确认注册，否则无法使用gh-pages！</p>
<p>第二步: 创建代码库</p>
<p>登陆之后，点击页面右上角的加号，选择New repository：</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191528405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"></p>
<p>新建代码库</p>
<p>进入代码库创建页面：</p>
<p>在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191553408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>注意：比如我的github名称是gdutxiaoxu ,这里你就填 gdutxiaoxu.github.io,如果你的名字是xujun，那你就填 xujun.github.io</strong></p>
<p>第三步: . 代码库设置</p>
<p>正确创建之后，你将会看到如下界面：</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191610749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191634165.png"></p>
<p>Github pages</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191652331.png"></p>
<p>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p>
<p>到此搭建hexo博客的相关环境配置已经完成，下面开始讲解Hexo的相关配置</p>
<hr>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h2><p>在自己认为合适的地方创建一个文件夹，这里我以E：/hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191711751.png" alt="在这里插入图片描述"></p>
<p>在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>


<p>然后你将会看到:</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191733391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>

<p>然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<p>如果你看到了如图文字，则说明已经安装成功了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9cb2f935baed299cd52c30f346c7366b.png"></p>
<hr>
<h2 id="hexo的相关配置"><a href="#hexo的相关配置" class="headerlink" title="hexo的相关配置"></a><strong>hexo的相关配置</strong></h2><p><strong>初始化Hexo</strong></p>
<p>接着上面的操作，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>


<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>


<p>之后npm将会自动安装你需要的组件，只需要等待npm操作即可。</p>
<p><strong>首次体验Hexo</strong></p>
<p>继续操作，同样是在命令行中，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/2021041719175613.png" alt="在这里插入图片描述"></p>
<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后会提示：</p>
<blockquote>
<p>INFO  Hexo is running at <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p>在浏览器中打开<a href="http://localhost:4000/%EF%BC%8C%E4%BD%A0%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0%EF%BC%9A">http://localhost:4000/，你将会看到：</a></p>
<p><img src="https://img-blog.csdnimg.cn/2021041719181532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>到目前为止，Hexo在本地的配置已经全都结束了。</p>
<p>下面会讲解怎样将Hexo与github page 联系起来</p>
<hr>
<h2 id="怎样将Hexo与github-page-联系起来"><a href="#怎样将Hexo与github-page-联系起来" class="headerlink" title="怎样将Hexo与github page 联系起来"></a><strong>怎样将Hexo与github page 联系起来</strong></h2><p>大概分为以下几步</p>
<ul>
<li>配置git个人信息</li>
<li>配置Deployment</li>
</ul>
<h3 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h3><p>如果你之前已经配置好git个人信息，请跳过这一个 步骤，直接来到</p>
<p>1、设置Git的user name和email：(如果是第一次的话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xujun&quot;</span><br><span class="line">git config --global user.email &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>2、生成密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>


<h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><p>同样在_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>比如我的仓库的地址是<a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:gdutxiaoxu/gdutxiaoxu.github.io.git，所以配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:gdutxiaoxu&#x2F;gdutxiaoxu.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="写博客、发布文章"><a href="#写博客、发布文章" class="headerlink" title="写博客、发布文章"></a>写博客、发布文章</h2><p>新建一篇博客，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210417191837780.png" alt="在这里插入图片描述"></p>
<p>这时候在我的 电脑的目录下 F:\hexo\source\ _posts 将会看到  article title.md 文件</p>
<p> 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   &#x2F;&#x2F; 生成</span><br><span class="line">hexo d   &#x2F;&#x2F; 部署</span><br></pre></td></tr></table></figure>

<p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g #在部署前先生成</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210417191858877.png" alt="在这里插入图片描述"></p>
<p>部署成功后访问 你的地址，<a href="https://yourName.github.io（这里输入我的地址：">https://yourName.github.io（这里输入我的地址：</a> <a href="https://gdutxiao.github.io/">https://gdutxiao.github.io</a> ),将可以看到生成的文章。</p>
<p><strong>踩坑提醒</strong></p>
<ul>
<li>1）注意需要提前安装一个扩展：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p> <strong>如果没有执行者行命令，将会提醒</strong></p>
<blockquote>
<p>deloyer not found:git</p>
</blockquote>
<ul>
<li>2）如果出现下面这样的错误，<blockquote>
<p>Permission denied (publickey).<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.</p>
</blockquote>
</li>
</ul>
<p>则是因为没有设置好public key所致。<br>在本机生成public key,不懂的可以参考我的这一篇博客<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></p>
<hr>
<h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a><strong>主题推荐</strong></h2><p>每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。有两个比较好的主题推荐给大家。</p>
<p><strong>Yilia</strong></p>
<p>Yilia 是为 hexo 2.4+制作的主题。<br>崇尚简约优雅，以及极致的性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191921903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://litten.github.io/">Yilia地址</a></p>
<p><strong>NexT</strong></p>
<p>我的网站就是采用这个主题，简洁美观。<br>目前Github上Star最高的Hexo主题，支持几种不同的风格。<br>作者提供了非常完善的配置说明。</p>
<p><img src="https://img-blog.csdnimg.cn/20210417191939669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="Net主题的配置"><a href="#Net主题的配置" class="headerlink" title="Net主题的配置"></a><strong>Net主题的配置</strong></h2><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p>
<p>比如我的电脑下的  F:\hexo 目录下的成为 站点配置文件，F:\hexo\themes\next 目录下的成为主题配置文件。</p>
<p>1）<strong>安装 NexT</strong></p>
<p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p>
<p>下载主题</p>
<p>如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。</p>
<p>克隆最新版本<br>下载稳定版本<br>在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>



<p>2）<strong>启用主题</strong></p>
<p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</p>
<p>启用 NexT 主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p>
<p>3）<strong>验证主题</strong></p>
<p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p>
<blockquote>
<p>INFO  Hexo is running at <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p>此时即可使用浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> ，检查站点是否正确运行。</p>
<p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p>
<p><img src="https://img-blog.csdnimg.cn/20210417192009136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"></p>
<p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p>
<p>4）<strong>主题设定</strong></p>
<p>选择 Scheme</p>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">Mist - Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces - 双栏 Scheme，小家碧玉似的清新</span><br><span class="line">Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面</span><br></pre></td></tr></table></figure>
<p>注释 # 即可。</p>
<p>选择 Pisce Scheme</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>

<p>5）<strong>设置语言</strong></p>
<p>编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>

<p>目前 NexT 支持的语言如以下表格所示：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>代码</th>
<th>设定实例</th>
</tr>
</thead>
<tbody><tr>
<td>English</td>
<td>en</td>
<td>language: en</td>
</tr>
<tr>
<td>简体中文</td>
<td>zh-Hans</td>
<td>language: zh-Hans</td>
</tr>
<tr>
<td>Français</td>
<td>fr-FR</td>
<td>language: fr-FR</td>
</tr>
<tr>
<td>Português</td>
<td>pt</td>
<td>language: pt</td>
</tr>
<tr>
<td>繁體中文</td>
<td>zh-hk 或者 zh-tw</td>
<td>language: zh-hk</td>
</tr>
<tr>
<td>Русский язык</td>
<td>ru</td>
<td>language: ru</td>
</tr>
<tr>
<td>Deutsch</td>
<td>de</td>
<td>language: de</td>
</tr>
<tr>
<td>日本語</td>
<td>ja</td>
<td>language: ja</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
<td>language: id</td>
</tr>
</tbody></table>
<p>6）<strong>设置 菜单</strong></p>
<p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p>
<p>编辑主题配置文件，修改以下内容：</p>
<p>设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。</p>
<p>菜单示例配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;</span><br><span class="line">  archives: &#x2F;archives</span><br><span class="line">  #about: &#x2F;about</span><br><span class="line">  #categories: &#x2F;categories</span><br><span class="line">  tags: &#x2F;tags</span><br><span class="line">  #commonweal: &#x2F;404.html</span><br></pre></td></tr></table></figure>

<p>若你的站点运行在子目录中，请将链接前缀的 / 去掉</p>
<p>NexT 默认的菜单项有（标注  的项表示需要手动创建这个页面）：</p>
<table>
<thead>
<tr>
<th>键值</th>
<th>设定值</th>
<th>显示文本（简体中文）</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td>home: /</td>
<td>主页</td>
</tr>
<tr>
<td>archives</td>
<td>archives: /archives</td>
<td>归档页</td>
</tr>
<tr>
<td>categories</td>
<td>categories: /categories</td>
<td>分类页</td>
</tr>
<tr>
<td>tags</td>
<td>tags: /tags</td>
<td>标签页</td>
</tr>
<tr>
<td>about</td>
<td>about: /about</td>
<td>关于页面</td>
</tr>
<tr>
<td>commonweal</td>
<td>commonweal: /404.html</td>
<td>公益 404</td>
</tr>
</tbody></table>
<p>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。</p>
<p>以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br><span class="line">  something: 有料</span><br></pre></td></tr></table></figure>

<p>设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。</p>
<p>菜单图标配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure>

<p>在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用  作为图标。</p>
<p>请注意键值（如 home）的大小写要严格匹配</p>
<p>7）** 侧栏**</p>
<p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p>
<p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left - 靠左放置</span><br><span class="line">right - 靠右放置</span><br></pre></td></tr></table></figure>

<p>目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  position: left</span><br></pre></td></tr></table></figure>

<p>设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post - 默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">always - 在所有页面中都显示</span><br><span class="line">hide - 在所有页面中都隐藏（可以手动展开）</span><br><span class="line">remove - 完全移除</span><br><span class="line">sidebar:</span><br><span class="line">  display: post</span><br></pre></td></tr></table></figure>

<p>已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。</p>
<p>8）<strong>设置 头像</strong></p>
<p>编辑 站点配置文件， 新增字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>完整的互联网 URI</td>
<td><a href="http://example.com/avtar.png">http://example.com/avtar.png</a></td>
</tr>
<tr>
<td>站点内的地址</td>
<td>将头像放置主题目录下的 source/uploads/ （新建uploads目录若不存在） 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 , 配置为：avatar: /images/avatar.png</td>
</tr>
</tbody></table>
<p>头像设置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar: http:&#x2F;&#x2F;example.com&#x2F;avtar.png</span><br></pre></td></tr></table></figure>

<p>9)<strong>设置 作者昵称</strong></p>
<p>编辑 站点配置文件， 设置 author 为你的昵称。</p>
<p>10)<strong>站点描述</strong></p>
<p>编辑 站点配置文件， 设置 </p>
<p>字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</p>
<p><a href="http://theme-next.iissnan.com/getting-started.html">net主题的官方文档地址</a></p>
<hr>
<h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>添加sitemap和feed插件</p>
<p>切换到你本地的hexo 目录CIA，在命令行窗口，属兔以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed -save</span><br><span class="line">npm install hexo-generator-sitemap -save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml，增加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">Plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure>


<p>再执行以下命令，部署服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>


<p>配完之后，就可以访问 <a href="https://gdutxiaoxu.github.io/atom.xml">https://gdutxiaoxu.github.io/atom.xml</a> 和 <a href="https://gdutxiaoxu.github.io/sitemap.xml">https://gdutxiaoxu.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p>
<hr>
<h2 id="添加404-页面"><a href="#添加404-页面" class="headerlink" title="添加404 页面"></a>添加404 页面</h2><p>GitHub Pages有提供制作404页面的指引：<a href="https://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site/">Custom 404 Pages</a><br>直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</p>
<p>推荐使用<a href="http://www.qq.com/404/">腾讯公益404</a></p>
<p>我的404页面配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot;</span><br><span class="line">        charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;gdutxiaoxu.github.io&quot;</span><br><span class="line">        homePageName&#x3D;&quot;回到我的主页&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://hexo.io/">Hexo主页</a></p>
<p><a href="https://xuanwo.org/2015/03/26/hexo-intor/">史上最详细的Hexo博客搭建图文教程</a></p>
<p>我的git系列参考教程</p>
<ul>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573339">Git 命令行教程及实例教程</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573426"> git ssh 配置多个账户</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/79253737">Git config 使用说明</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/79254607">Git 配置别名 —— 让命令变得更简单</a></li>
<li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/80455810">git 设置  mergetool，difftool 为 BeyondCompare </a></li>
<li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/89606676">git 补丁 - diff 和 patch 使用详解</a></li>
</ul>
<p>转载请注明原博客地址：<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">手把手教你用Hexo+Github 搭建属于自己的博客</a></p>
<p>欢迎关注我的微信公众号<strong>程序员徐公</strong>，即可关注。 目前专注于 Android 开发，主要分享 Android开发相关知识和一些相关的优秀文章，包括个人总结，职场经验等。<br><img src="https://img-blog.csdnimg.cn/20210406233329415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>搭建个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git ssh 配置多个账户</title>
    <url>/2016/12/11/git-ssh-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<p><strong>前言：前几天在写博客  <a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">手把手教你用Hexo + github 搭建自己博客</a><br>的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下</strong></p>
<ul>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573339">Git 命令行教程及实例教程</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573426"> git ssh 配置多个账户</a></li>
</ul>
<hr>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>这篇教程是在电脑上已经安装好git的前提之上的，要进行以下配置，请先确保你的电脑已经安装好git。以下配置步骤是在git bash里面进行配置的，可以通过 右键》 git bash here 打开</p>
<p><img src="http://ww3.sinaimg.cn/mw690/9fe4afa0gw1famnawriudj211y0lc4ar.jpg"></p>
<p>在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。</p>
<p>这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。</p>
<p>而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例，</p>
<p>今天主要是讲述如何配置使用ssh方式来提交和克隆代码。</p>
<p>大概可以分为一下几个步骤</p>
<ul>
<li>设置Git的user name和email：(如果是第一次的话)</li>
<li> 检查是否已经有SSH Key。</li>
<li>生成密钥</li>
<li>添加密钥到ssh-agent</li>
<li>登陆Github, 添加 ssh </li>
<li>测试：</li>
</ul>
<h2 id="1、设置Git的user-name和email：-如果是第一次的话"><a href="#1、设置Git的user-name和email：-如果是第一次的话" class="headerlink" title="1、设置Git的user name和email：(如果是第一次的话)"></a>1、设置Git的user name和email：(如果是第一次的话)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的“xujun&quot; 可以替换成自己的用户名</span><br><span class="line">git config --global user.name &quot;xujun&quot;</span><br><span class="line"># 这里的邮箱 gdutxiaoxu@163.com  替换成自己的邮箱</span><br><span class="line">git config --global user.email  &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="检查是否已经有SSH-Key。"><a href="#检查是否已经有SSH-Key。" class="headerlink" title="检查是否已经有SSH Key。"></a>检查是否已经有SSH Key。</h2><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">　　<span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>接着输入ls，</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure>

<p>列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 <em>生成密钥</em> 这一步骤，</p>
<p>下图是存在的情况下</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famro8k282j20d3026jrq.jpg"></p>
<h2 id="3、生成密钥"><a href="#3、生成密钥" class="headerlink" title="3、生成密钥"></a>3、生成密钥</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的邮箱 gdutxiaoxu@163.com  替换成自己的邮箱</span><br><span class="line">ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>连续3个回车。如果不需要密码的话。<br>最后得到了两个文件：id_rsa和id_rsa.pub。</p>
<p>默认的存储路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.ssh</span><br></pre></td></tr></table></figure>



<h2 id="4、添加密钥到ssh-agent"><a href="#4、添加密钥到ssh-agent" class="headerlink" title="4、添加密钥到ssh-agent"></a>4、添加密钥到ssh-agent</h2><p>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># start the ssh-agent in the background</span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>


<p><img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1fammrmpcbfj20as02eaad.jpg"></p>
<p>添加生成的 SSH key 到 ssh-agent。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>


<h2 id="5、登陆Github-添加-ssh-。"><a href="#5、登陆Github-添加-ssh-。" class="headerlink" title="5、登陆Github, 添加 ssh 。"></a>5、登陆Github, 添加 ssh 。</h2><p>把id_rsa.pub文件里的内容复制到这里</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1fammt1ixqwj20h209k3yx.jpg"></p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1fammth6gk9j20ir035t8v.jpg"></p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1fammtr9flrj20iq0aywgp.jpg"></p>
<h2 id="6、测试："><a href="#6、测试：" class="headerlink" title="6、测试："></a>6、测试：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>你将会看到：</p>
<blockquote>
<p>Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>如果看到Hi后面是你的用户名，就说明成功了。</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1fammv8uf98j20j502udgk.jpg"></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p> 如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。</p>
<p> 这里同样以我本机目录下的G://test 仓库为例子，</p>
<p> 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"> [core]</span><br><span class="line">	<span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line">	<span class="attr">filemode</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">symlinks</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">ignorecase</span> = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	<span class="attr">url</span> = https://github.com/gdutxiaoxu/test.git</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">[branch &quot;master&quot;]</span></span><br><span class="line"><span class="comment">	remote = origin</span></span><br><span class="line"><span class="comment">	merge = refs/heads/master</span></span><br></pre></td></tr></table></figure>
<p> 将文件中的 url = <a href="https://github.com/gdutxiaoxu/test.git">https://github.com/gdutxiaoxu/test.git</a> 更改为 url = <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:gdutxiaoxu/test.git 即可。</p>
<p>修改后的文件如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[core]</span></span><br><span class="line">	repositoryformatversion = <span class="number">0</span></span><br><span class="line">	filemode = false</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">	symlinks = false</span><br><span class="line">	ignorecase = true</span><br><span class="line"><span class="selector-attr">[remote <span class="string">&quot;origin&quot;</span>]</span></span><br><span class="line">	url = git@github<span class="selector-class">.com</span>:gdutxiaoxu/test.git</span><br><span class="line">	fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">[branch &quot;master&quot;]</span></span><br><span class="line"><span class="comment">	remote = origin</span></span><br><span class="line"><span class="comment">	merge = refs/heads/master</span></span><br></pre></td></tr></table></figure>




<p>进入本地仓库 ，增加 xujun.txt 文件，提交，你会看到不需要再提交密码了</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famsfk3xzoj20dy0b5ab6.jpg"></p>
<p>远程仓库</p>
<p><img src="http://ww4.sinaimg.cn/mw690/9fe4afa0gw1famw6htumvj20cw08ugm3.jpg"></p>
<p>  到此本篇博客为止，下一篇博客将讲解电脑怎样配置多个ssh key。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git ssh 配置及使用</title>
    <url>/2016/12/11/Git-ssh-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>前言：前几天在写博客  <a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">手把手教你用Hexo + github 搭建自己博客</a><br>的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下</strong></p>
<ul>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573339">Git 命令行教程及实例教程</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573426"> git ssh 配置多个账户</a></li>
</ul>
<hr>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>这篇教程是在电脑上已经安装好git的前提之上的，要进行以下配置，请先确保你的电脑已经安装好git。以下配置步骤是在git bash里面进行配置的，可以通过 右键》 git bash here 打开</p>
<p><img src="http://ww3.sinaimg.cn/mw690/9fe4afa0gw1famnawriudj211y0lc4ar.jpg"></p>
<p>在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。</p>
<p>这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。</p>
<p>而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例，</p>
<p>今天主要是讲述如何配置使用ssh方式来提交和克隆代码。</p>
<p>大概可以分为一下几个步骤</p>
<ul>
<li>设置Git的user name和email：(如果是第一次的话)</li>
<li> 检查是否已经有SSH Key。</li>
<li>生成密钥</li>
<li>添加密钥到ssh-agent</li>
<li>登陆Github, 添加 ssh </li>
<li>测试：</li>
</ul>
<h2 id="1、设置Git的user-name和email：-如果是第一次的话"><a href="#1、设置Git的user-name和email：-如果是第一次的话" class="headerlink" title="1、设置Git的user name和email：(如果是第一次的话)"></a>1、设置Git的user name和email：(如果是第一次的话)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的“xujun&quot; 可以替换成自己的用户名</span><br><span class="line">git config --global user.name &quot;xujun&quot;</span><br><span class="line"># 这里的邮箱 gdutxiaoxu@163.com  替换成自己的邮箱</span><br><span class="line">git config --global user.email  &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="检查是否已经有SSH-Key。"><a href="#检查是否已经有SSH-Key。" class="headerlink" title="检查是否已经有SSH Key。"></a>检查是否已经有SSH Key。</h2><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">　　<span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>接着输入ls，</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure>

<p>列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 <em>生成密钥</em> 这一步骤，</p>
<p>下图是存在的情况下</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famro8k282j20d3026jrq.jpg"></p>
<h2 id="3、生成密钥"><a href="#3、生成密钥" class="headerlink" title="3、生成密钥"></a>3、生成密钥</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的邮箱 gdutxiaoxu@163.com  替换成自己的邮箱</span><br><span class="line">ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot;</span><br></pre></td></tr></table></figure>

<p>连续3个回车。如果不需要密码的话。<br>最后得到了两个文件：id_rsa和id_rsa.pub。</p>
<p>默认的存储路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.ssh</span><br></pre></td></tr></table></figure>



<h2 id="4、添加密钥到ssh-agent"><a href="#4、添加密钥到ssh-agent" class="headerlink" title="4、添加密钥到ssh-agent"></a>4、添加密钥到ssh-agent</h2><p>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># start the ssh-agent in the background</span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>


<p><img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1fammrmpcbfj20as02eaad.jpg"></p>
<p>添加生成的 SSH key 到 ssh-agent。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>


<h2 id="5、登陆Github-添加-ssh-。"><a href="#5、登陆Github-添加-ssh-。" class="headerlink" title="5、登陆Github, 添加 ssh 。"></a>5、登陆Github, 添加 ssh 。</h2><p>把id_rsa.pub文件里的内容复制到这里</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1fammt1ixqwj20h209k3yx.jpg"></p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1fammth6gk9j20ir035t8v.jpg"></p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1fammtr9flrj20iq0aywgp.jpg"></p>
<h2 id="6、测试："><a href="#6、测试：" class="headerlink" title="6、测试："></a>6、测试：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>你将会看到：</p>
<blockquote>
<p>Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>如果看到Hi后面是你的用户名，就说明成功了。</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1fammv8uf98j20j502udgk.jpg"></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p> 如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。</p>
<p> 这里同样以我本机目录下的G://test 仓库为例子，</p>
<p> 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"> [core]</span><br><span class="line">	<span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line">	<span class="attr">filemode</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line">	<span class="attr">symlinks</span> = <span class="literal">false</span></span><br><span class="line">	<span class="attr">ignorecase</span> = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line">	<span class="attr">url</span> = https://github.com/gdutxiaoxu/test.git</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">[branch &quot;master&quot;]</span></span><br><span class="line"><span class="comment">	remote = origin</span></span><br><span class="line"><span class="comment">	merge = refs/heads/master</span></span><br></pre></td></tr></table></figure>
<p> 将文件中的 url = <a href="https://github.com/gdutxiaoxu/test.git">https://github.com/gdutxiaoxu/test.git</a> 更改为 url = <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:gdutxiaoxu/test.git 即可。</p>
<p>修改后的文件如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[core]</span></span><br><span class="line">	repositoryformatversion = <span class="number">0</span></span><br><span class="line">	filemode = false</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">	symlinks = false</span><br><span class="line">	ignorecase = true</span><br><span class="line"><span class="selector-attr">[remote <span class="string">&quot;origin&quot;</span>]</span></span><br><span class="line">	url = git@github<span class="selector-class">.com</span>:gdutxiaoxu/test.git</span><br><span class="line">	fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">[branch &quot;master&quot;]</span></span><br><span class="line"><span class="comment">	remote = origin</span></span><br><span class="line"><span class="comment">	merge = refs/heads/master</span></span><br></pre></td></tr></table></figure>




<p>进入本地仓库 ，增加 xujun.txt 文件，提交，你会看到不需要再提交密码了</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famsfk3xzoj20dy0b5ab6.jpg"></p>
<p>远程仓库</p>
<p><img src="http://ww4.sinaimg.cn/mw690/9fe4afa0gw1famw6htumvj20cw08ugm3.jpg"></p>
<p>  到此本篇博客为止，下一篇博客将讲解电脑怎样配置多个ssh key。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 命令行教程及实例教程</title>
    <url>/2016/12/11/Git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>前言：前几天在写博客  手把手教你用Hexo + github 搭建自己博客的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下</strong></p>
<ul>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573339">Git 命令行教程及实例教程</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573426"> git ssh 配置多个账户</a></li>
</ul>
<hr>
<p>本篇博客主要讲解以下问题：</p>
<ul>
<li>Git 常用命令<ul>
<li>创建新仓库</li>
<li> 检出仓库</li>
<li> 添加与提交</li>
<li> 推送改动</li>
<li> 分支</li>
<li> 更新与合并</li>
<li> 标签</li>
<li> 替换本地改动</li>
</ul>
</li>
<li>Git实例教程</li>
<li>操作小技巧</li>
</ul>
<h2 id="Git-常用命令常用命令"><a href="#Git-常用命令常用命令" class="headerlink" title="Git 常用命令常用命令"></a><strong>Git 常用命令常用命令</strong></h2><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p>创建新文件夹，打开，然后执行 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>以创建新的 git 仓库。</p>
<h3 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h3><p>执行如下命令以创建一个本地仓库的克隆版本：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">git clone /path/<span class="keyword">to</span>/repository </span><br></pre></td></tr></table></figure>


<p>如果是远端服务器上的仓库，你的命令会是这个样子：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git clone username<span class="variable">@host</span><span class="symbol">:/path/to/repository</span></span><br></pre></td></tr></table></figure>

<p>工作流<br>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1famnvghkwrj20p008wgmd.jpg"></p>
<h3 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h3><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> &lt;filename&gt;</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> *</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件</span></span><br><span class="line">git  <span class="keyword">add</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure>


<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="operator">-</span>m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure>


<p>现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。</p>
<h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span> origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以把 master 换成你想要推送的任何分支。 </p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight vbscript-html"><table><tr><td class="code"><pre><span class="line"><span class="xml"># 注意 server必须是存在的仓库</span></span><br><span class="line"><span class="xml">git remote add origin <span class="tag">&lt;<span class="name">server</span>&gt;</span></span></span><br><span class="line"><span class="xml">git remote add origin https://github.com/gdutxiaoxu/test2.git</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>该命令是移除本地缓存已有的remote信息</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">remove</span> origin </span><br></pre></td></tr></table></figure>


<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>创建一个叫做“feature_x”的分支，并切换过去：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> feature_x</span><br></pre></td></tr></table></figure>


<p>切换回主分支：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout master</span><br></pre></td></tr></table></figure>

<p>切换回分支：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout &lt;branch&gt;</span><br><span class="line">git checkout  feature_x</span><br></pre></td></tr></table></figure>


<p>再把新建的分支删掉：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git branch -<span class="keyword">d</span> feature_x</span><br></pre></td></tr></table></figure>


<p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p>
<figure class="highlight vbscript-html"><table><tr><td class="code"><pre><span class="line"><span class="xml">git push origin <span class="tag">&lt;<span class="name">branch</span>&gt;</span></span></span><br><span class="line"><span class="xml">git push origin  feature_x</span></span><br></pre></td></tr></table></figure>


<h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动，执行：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> pull</span><br></pre></td></tr></table></figure>


<p>以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">merge</span> <span class="operator">&lt;</span>branch<span class="operator">&gt;</span></span><br><span class="line">git <span class="keyword">merge</span> feature_x</span><br></pre></td></tr></table></figure>


<p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>
<figure class="highlight vbscript-html"><table><tr><td class="code"><pre><span class="line"><span class="xml">git add <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<p>在合并改动之前，也可以使用如下命令查看：</p>
<figure class="highlight vbscript-html"><table><tr><td class="code"><pre><span class="line"><span class="xml">git diff <span class="tag">&lt;<span class="name">source_branch</span>&gt;</span> <span class="tag">&lt;<span class="name">target_branch</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="number">1.0</span>.<span class="number">0</span> <span class="number">1</span>b2e1d63ff</span><br></pre></td></tr></table></figure>


<p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span></span><br></pre></td></tr></table></figure>


<p>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p>
<h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>


<p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p>
<p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">fetch</span> origin</span><br><span class="line">git reset <span class="comment">--hard origin/master</span></span><br></pre></td></tr></table></figure>


<h2 id="有用的贴士"><a href="#有用的贴士" class="headerlink" title="有用的贴士"></a>有用的贴士</h2><p>内建的图形化 git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure>


<p>彩色的 git 输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">git config color.ui true</span><br></pre></td></tr></table></figure>


<p>显示历史记录时，只显示一行注释信息：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git config format<span class="selector-class">.pretty</span> oneline</span><br></pre></td></tr></table></figure>


<p>交互地添加文件至缓存区：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">git add -<span class="built_in">i</span></span><br></pre></td></tr></table></figure>
<p>到此 git常用的命令已经 讲解完毕，下面开始讲解Git  实例教程</p>
<hr>
<h2 id="Git实例教程"><a href="#Git实例教程" class="headerlink" title="Git实例教程"></a><strong>Git实例教程</strong></h2><p>大概分为以下两步</p>
<ul>
<li> github账号的注册与Repo的创建</li>
<li>实例教程</li>
</ul>
<h3 id="github账号的注册与Repo的创建"><a href="#github账号的注册与Repo的创建" class="headerlink" title="github账号的注册与Repo的创建"></a>github账号的注册与Repo的创建</h3><ol>
<li>Github注册</li>
</ol>
<p>打开<a href="https://github.com/%EF%BC%8C%E5%9C%A8%E4%B8%8B%E5%9B%BE%E7%9A%84%E6%A1%86%E4%B8%AD%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%85%A5%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%8C%E9%82%AE%E7%AE%B1%EF%BC%8C%E5%AF%86%E7%A0%81%E3%80%82">https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。</a></p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljxemku5j20bo0as0tv.jpg"></p>
<p>然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。</p>
<p>一定要确认注册，否则无法使用gh-pages！</p>
<ol start="2">
<li>创建代码库</li>
</ol>
<p>登陆之后，点击页面右上角的加号，选择New repository：</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faljww56v8j20ci0a975c.jpg"></p>
<p>新建代码库</p>
<p>进入代码库创建页面：</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1famqd6t7bzj20my0gfdjm.jpg"></p>
<p>到此我们就创建好了repo，地址 为：<a href="https://github.com/gdutxiaoxu/test.git">https://github.com/gdutxiaoxu/test.git</a></p>
<h3 id="实例教程"><a href="#实例教程" class="headerlink" title="实例教程"></a>实例教程</h3><p>这里我们把仓库建在 G://test  目录下</p>
<ol>
<li> 首先打开命令行，进入G 盘，输入以下命令</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 test目录下创建 README.md 文件</span></span><br><span class="line"> echo <span class="string">&quot;# test&quot;</span> &gt;&gt; README.md</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接着初始化仓库</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>  可以看到如下图片的效果</p>
<p><img src="http://ww1.sinaimg.cn/large/9fe4afa0jw1famryzlcksj20bt04a74b.jpg"></p>
<ol start="3">
<li><p>将 README.md 文件添加到版本控制</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> README.md</span></span><br></pre></td></tr></table></figure></li>
<li><p>提交文件到本地缓存，并添加说明</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="operator">-</span>m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>


<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0jw1fams0l7v6jj20by04nwel.jpg"></p>
<ol start="5">
<li>将本地仓库与远程仓库 <a href="https://github.com/gdutxiaoxu/test.git">https://github.com/gdutxiaoxu/test.git</a> 联系起来</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gdutxiaoxu/test.git</span><br></pre></td></tr></table></figure>


<ol start="6">
<li>将本地仓库缓存的文件提交到远程仓库中</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span> -u origin master</span><br></pre></td></tr></table></figure>

<p>如果你没有配置ssh ，那么在这里需要输入你的github 账户的用户名和密码</p>
<p><img src="http://ww1.sinaimg.cn/large/9fe4afa0jw1famqv57c2cj20cd02k74d.jpg"></p>
<p>正确输入你的用户名和密码后，可以看到</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0jw1famqx437x6j20f703kglx.jpg"></p>
<p>同时我们登陆我们的github 仓库 ：  <a href="https://github.com/gdutxiaoxu/test.git">https://github.com/gdutxiaoxu/test.git</a>  ，可以看到：</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0jw1famqxkom1hj20sh09o3zu.jpg"></p>
<p>说明已经提交成功了。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>如果我们本地已经存在仓库了，那我们只需要执行以下命令就可以将我们本地仓库与远程绑定起来</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gdutxiaoxu/test.git</span><br><span class="line">git push -<span class="keyword">u</span> origin master</span><br><span class="line"></span><br><span class="line">git pull  http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gdutxiaoxu/test.git master</span><br></pre></td></tr></table></figure>

<ul>
<li>如果本地仓库已经绑定别的远程仓库，我们可以用以下命令将其删除相应的仓库信息</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># 该命令是移除本地缓存已有的remote信息</span><br><span class="line">git remote <span class="built_in">remove</span> origin </span><br></pre></td></tr></table></figure>

<ul>
<li>如果我们remote repo （即远端仓库已经存在了），那么我们只需要执行以下命令就OK了</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/gdutxiaoxu/test.git  &quot;you path&quot;</span></span><br></pre></td></tr></table></figure>

<p>比如我们想储存在 G://test 目录下，那么我们可以输入一下命令</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/gdutxiaoxu/test.git  G://test</span></span><br></pre></td></tr></table></figure>
<p> 效果图如下</p>
<p>  <img src="http://ww3.sinaimg.cn/large/9fe4afa0gw1famx238wqpj20j504bq3j.jpg"></p>
<hr>
<hr>
<h2 id="操作小技巧"><a href="#操作小技巧" class="headerlink" title="操作小技巧"></a>操作小技巧</h2><p>有时候在cmd 窗口中，你会发现复制，粘贴的快捷键失效了，对我们开发者来说很不方便，拿我们有什么解决方法你？  哈哈，就是开启快速插入模式。</p>
<p>右键点击，点击cmd  窗口</p>
<p><img src="http://ww1.sinaimg.cn/mw690/9fe4afa0jw1famvugz6enj211y0lcju0.jpg"></p>
<p>选择快速插入模式，在Cmd 窗口，按右键，就能实现粘贴了。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/9fe4afa0jw1famvwicxhuj20c20gpdhr.jpg"></p>
<p>同理，在git bash 窗口也是这样，这样就不在阐述了。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git下载及配置环境变量</title>
    <url>/2016/12/11/Git%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>前言：前几天在写博客  <a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">手把手教你用Hexo + github 搭建自己博客</a><br>的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下</strong></p>
<ul>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573286">Git下载及配置环境变量</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573339">Git 命令行教程及实例教程</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置及使用</a></li>
<li><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573426"> git ssh 配置多个账户</a></li>
</ul>
<hr>
<p>下载Git安装文件：</p>
<p><a href="https://git-scm.com/downloads">GIt官网下载地址：</a></p>
<p><a href="https://github-cloud.s3.amazonaws.com/releases/23216272/84b33b96-87f5-11e5-8f91-32080286239e.exe?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAISTNZFOVBIJMK3TQ/20161210/us-east-1/s3/aws4_request&X-Amz-Date=20161210T033734Z&X-Amz-Expires=300&X-Amz-Signature=912c155bbe0fe970ca7b948f5f0d5e8c68c712b7fb8006062f53c8638c62c7b6&X-Amz-SignedHeaders=host&actor_id=14971673&response-content-disposition=attachment;%20filename=Git-2.6.3-64-bit.exe&response-content-type=application/octet-stream">Git-2.6.3-64-bit.exe</a></p>
<p>然后就进入了Git的安装界面，如图：</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1fampzoik7ej20e70b1q5o.jpg"></p>
<p>Git安装界面</p>
<p><img src="http://ww1.sinaimg.cn/large/9fe4afa0gw1faljmdsfd9j20dv0atq4u.jpg"></p>
<p>和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：</p>
<p>Git PATH设置</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljmop0mbj20dz0atwhi.jpg"></p>
<p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。<br>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faljp87tpkj20it0cbdgo.jpg"></p>
<p><img src="http://ww1.sinaimg.cn/large/9fe4afa0gw1faljm42qvnj20dz0atwh2.jpg"></p>
<p>Git安装界面</p>
<p><img src="http://ww1.sinaimg.cn/large/9fe4afa0gw1faljmdsfd9j20dv0atq4u.jpg"></p>
<p>大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择：</p>
<p>Git PATH设置</p>
<p><img src="http://ww4.sinaimg.cn/large/9fe4afa0gw1faljmop0mbj20dz0atwhi.jpg"></p>
<p>这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。<br>一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<p>如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。</p>
<p><img src="http://ww2.sinaimg.cn/large/9fe4afa0gw1faljp87tpkj20it0cbdgo.jpg"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 启动系统相机，相册，裁剪图片及6.0权限管理</title>
    <url>/2016/12/08/Android-%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%EF%BC%8C%E7%9B%B8%E5%86%8C%EF%BC%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E5%8F%8A6-0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在日常开发中，我们经常需要用到上传图片的 功能，这个时候通常有两种做法，第一种，从相机获取，第二种，从相册获取。今天这篇博客主要讲解利用系统的Intent怎样获取？</p>
<p>主要内容如下</p>
<ul>
<li>怎样通过相机获取我们的图片</li>
<li>怎样启动相册获取我们想要的图片</li>
<li>在Android 6.0中的动态权限处理】</li>
<li>调用系统Intent和自定义相册的优缺点对比</li>
</ul>
<h2 id="怎样通过相机获取我们的图片"><a href="#怎样通过相机获取我们的图片" class="headerlink" title="怎样通过相机获取我们的图片"></a>怎样通过相机获取我们的图片</h2><p>总共有两种方式，</p>
<h3 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h3><p>第一步，通过 MediaStore.ACTION_IMAGE_CAPTURE 启动我们的相机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent pIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);<span class="comment">//调用摄像头action</span></span><br><span class="line">startActivityForResult(pIntent, INTENT_CODE_IMAGE_CAPTURE1);<span class="comment">//requestcode</span></span><br></pre></td></tr></table></figure>

<p>第二步，在onActivityResult进行处理，，核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTENT_CODE_IMAGE_CAPTURE1:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                Bundle pBundle = data.getExtras(); <span class="comment">//从intent对象中获取数据，</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pBundle != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Bitmap pBitmap = (Bitmap) pBundle.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mIv.setImageBitmap(pBitmap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="第二种-方式"><a href="#第二种-方式" class="headerlink" title="第二种 方式"></a>第二种 方式</h3><p>第一步，通过 MediaStore.ACTION_IMAGE_CAPTURE 启动相机，并指定 MediaStore.EXTRA_OUTPUT ，intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile)); 传入我们的URI，这样，最终返回的信息会存储在我们的mFile中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCameraWithHighBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确定存储拍照得到的图片文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">        mFile = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(),</span><br><span class="line">                getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;请插入sd卡&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFile.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">//加载Uri型的文件路径</span></span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile));</span><br><span class="line">    <span class="comment">//向onActivityResult发送intent，requestCode为INTENT_CODE_IMAGE_CAPTURE2</span></span><br><span class="line">    startActivityForResult(intent, INTENT_CODE_IMAGE_CAPTURE2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>第二步：在onActivityResult进行处理，并对图片进行相应的压缩，防止在大图片的情况下发生OOM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> INTENT_CODE_IMAGE_CAPTURE2:</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">        Bitmap bitmap = ImageZip.decodeSampledBitmapFromFile(mFile.getAbsolutePath(),</span><br><span class="line">                mWidth, mHeight);</span><br><span class="line">        mIv.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromFile</span><span class="params">(String pathName, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeFile(pathName, options);</span><br><span class="line">        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        Bitmap src = BitmapFactory.decodeFile(pathName, options);</span><br><span class="line"><span class="comment">//        return createScaleBitmap(src, reqWidth, reqHeight, options.inSampleSize);</span></span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 源图片的高度和宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="两种方法的区别"><a href="#两种方法的区别" class="headerlink" title="两种方法的区别"></a>两种方法的区别</h3><p>第一种方法获取的bitmap是被缩放的bitmap，第二种方法获取的bitmap是完整的bitmap，实际使用中根据需求情况决定使用哪一种方法。</p>
<p><a href="https://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">官网参考地址</a></p>
<hr>
<h2 id="怎样启动相册获取我们想要的图片"><a href="#怎样启动相册获取我们想要的图片" class="headerlink" title="怎样启动相册获取我们想要的图片"></a>怎样启动相册获取我们想要的图片</h2><p>第一步，通过 Intent.ACTION_GET_CONTENT 这个Intent，并设置相应的type，启动相册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT, <span class="keyword">null</span>);</span><br><span class="line">i.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">startActivityForResult(i, INTENT_CODE_IMAGE_GALLERY1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 第二步，在onActivityResult中对返回的uri数据进行处理</p>
<ul>
<li>需要注意的是：这里我们需要注意是不是MIUI系统，如果不是MIUI系统，我们只需要进行一下处理，就OK了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPhotoForNormalSystem</span><span class="params">(Intent data)</span> </span>&#123;</span><br><span class="line">    String filePath = getRealPathFromURI(data.getData());</span><br><span class="line">    Bitmap bitmap = ImageZip.decodeSampledBitmapFromFile(filePath, mWidth, mHeight);</span><br><span class="line">    mIv.setImageBitmap(bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析Intent.getdata()得到的uri为String型的filePath</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> contentUri</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRealPathFromURI</span><span class="params">(Uri contentUri)</span> </span>&#123;</span><br><span class="line">    String[] proj = &#123;MediaStore.Audio.Media.DATA&#125;;</span><br><span class="line">    Cursor cursor = managedQuery(contentUri, proj, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA);</span><br><span class="line">    cursor.moveToFirst();</span><br><span class="line">    <span class="keyword">return</span> cursor.getString(column_index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是MIUI系统，我们需要进行一下处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setPhotoForMiuiSystem(Intent data) &#123;</span><br><span class="line">    Uri localUri &#x3D; data.getData();</span><br><span class="line">    String scheme &#x3D; localUri.getScheme();</span><br><span class="line">    String imagePath &#x3D; &quot;&quot;;</span><br><span class="line">    if (&quot;content&quot;.equals(scheme)) &#123;</span><br><span class="line">        String[] filePathColumns &#x3D; &#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class="line">        Cursor c &#x3D; getContentResolver().query(localUri, filePathColumns, null, null, null);</span><br><span class="line">        c.moveToFirst();</span><br><span class="line">        int columnIndex &#x3D; c.getColumnIndex(filePathColumns[0]);</span><br><span class="line">        imagePath &#x3D; c.getString(columnIndex);</span><br><span class="line">        c.close();</span><br><span class="line">    &#125; else if (&quot;file&quot;.equals(scheme)) &#123;&#x2F;&#x2F;小米4选择云相册中的图片是根据此方法获得路径</span><br><span class="line">        imagePath &#x3D; localUri.getPath();</span><br><span class="line">    &#125;</span><br><span class="line">    Bitmap bitmap &#x3D; ImageZip.decodeSampledBitmapFromFile(imagePath, mWidth, mHeight);</span><br><span class="line">    mIv.setImageBitmap(bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在代码中的体现如下，即判断是否是MIUI系统，对于不同的系统采用不同的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span> (resultCode != RESULT_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTENT_CODE_IMAGE_GALLERY1:</span><br><span class="line">            <span class="keyword">if</span> (SystemUtils.isMIUI()) &#123;</span><br><span class="line">                setPhotoForMiuiSystem(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setPhotoForNormalSystem(data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Android6-0动态权限管理"><a href="#Android6-0动态权限管理" class="headerlink" title="Android6.0动态权限管理"></a>Android6.0动态权限管理</h2><p>我们知道在Android6.0以上的系统，有一些权限需要动态授予 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">group:android.permission-group.CONTACTS</span><br><span class="line">  permission:android.permission.WRITE_CONTACTS</span><br><span class="line">  permission:android.permission.GET_ACCOUNTS</span><br><span class="line">  permission:android.permission.READ_CONTACTS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.PHONE</span><br><span class="line">  permission:android.permission.READ_CALL_LOG</span><br><span class="line">  permission:android.permission.READ_PHONE_STATE</span><br><span class="line">  permission:android.permission.CALL_PHONE</span><br><span class="line">  permission:android.permission.WRITE_CALL_LOG</span><br><span class="line">  permission:android.permission.USE_SIP</span><br><span class="line">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class="line">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALENDAR</span><br><span class="line">  permission:android.permission.READ_CALENDAR</span><br><span class="line">  permission:android.permission.WRITE_CALENDAR</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CAMERA</span><br><span class="line">  permission:android.permission.CAMERA</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SENSORS</span><br><span class="line">  permission:android.permission.BODY_SENSORS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class="line"></span><br><span class="line">group:android.permission-group.STORAGE</span><br><span class="line">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">group:android.permission-group.MICROPHONE</span><br><span class="line">  permission:android.permission.RECORD_AUDIO</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SMS</span><br><span class="line">  permission:android.permission.READ_SMS</span><br><span class="line">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class="line">  permission:android.permission.RECEIVE_MMS</span><br><span class="line">  permission:android.permission.RECEIVE_SMS</span><br><span class="line">  permission:android.permission.SEND_SMS</span><br><span class="line">  permission:android.permission.READ_CELL_BROADCASTS</span><br></pre></td></tr></table></figure>

<p>我们这里容易 得知读取相机需要的权限有，写sd卡权限，读取camera权限，这两个权限都需要动态授予。</p>
<h3 id="这里我们以检查是否授予camera权限为例子讲解"><a href="#这里我们以检查是否授予camera权限为例子讲解" class="headerlink" title="这里我们以检查是否授予camera权限为例子讲解"></a>这里我们以检查是否授予camera权限为例子讲解</h3><p>第一步，在启动相机的时候检查时候已经授予camera权限，没有的话 ，请求camera权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ContextCompat.checkSelfPermission(this, permission)</span><br><span class="line">        !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;&#x2F;&#x2F;还没有授予权限</span><br><span class="line">    if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#123;</span><br><span class="line">        Toast.makeText(this, &quot;您已禁止该权限，需要重新开启。&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ActivityCompat.requestPermissions(this, new String[]&#123;permission&#125;,</span><br><span class="line">                request_camera2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;&#x2F;&#x2F; 已经授予权限</span><br><span class="line">    startCameraWithHighBitmap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void startCameraWithHighBitmap() &#123;</span><br><span class="line">    &#x2F;&#x2F;确定存储拍照得到的图片文件路径</span><br><span class="line">    if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">        mFile &#x3D; new File(Environment.getExternalStorageDirectory(),</span><br><span class="line">                getName());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Toast.makeText(this, &quot;请插入sd卡&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        mFile.createNewFile();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intent intent &#x3D; new Intent();</span><br><span class="line">    intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    &#x2F;&#x2F;加载Uri型的文件路径</span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile));</span><br><span class="line">    &#x2F;&#x2F;向onActivityResult发送intent，requestCode为INTENT_CODE_IMAGE_CAPTURE2</span><br><span class="line">    startActivityForResult(intent, INTENT_CODE_IMAGE_CAPTURE2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步:重写onRequestPermissionsResult方法，判断是否授权成功，成功的话启动相机，核心代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,</span><br><span class="line">                                       @NonNull int[] grantResults) &#123;</span><br><span class="line">    super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        case request_camera2:</span><br><span class="line">            if (grantResults[0] &#x3D;&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                startCameraWithHighBitmap();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Permission Denied</span><br><span class="line">                Toast.makeText(this, &quot;Permission Denied&quot;, Toast</span><br><span class="line">                        .LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于检查sd卡写权限的，这里不再阐述，有兴趣的话，可以下载源码看一下。</p>
<p>关于Android6.0动态获取权限的，可以参考这一篇博客<a href="http://gudong.name/%E6%8A%80%E6%9C%AF/2015/11/10/android_m_permission.html">在Android 6.0 设备上动态获取权限</a></p>
<hr>
<h2 id="调用系统Intent和自定义相册的优缺点对比"><a href="#调用系统Intent和自定义相册的优缺点对比" class="headerlink" title="调用系统Intent和自定义相册的优缺点对比"></a>调用系统Intent和自定义相册的优缺点对比</h2><h3 id="调用系统Intent启动相册"><a href="#调用系统Intent启动相册" class="headerlink" title="调用系统Intent启动相册"></a>调用系统Intent启动相册</h3><p>优点： 代码简洁</p>
<p>缺点：对于不同的手机厂商，room往往被修改了，有时候调用系统的Intent，会有一些一项不到的bug， 不能实现多张图片的选择</p>
<h3 id="自定义相册"><a href="#自定义相册" class="headerlink" title="自定义相册"></a>自定义相册</h3><p>优点： 实现的样式可以自己定制，可以实现多张图片的选择等</p>
<p>缺点： 代码量稍微多一些</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>综上所述，对于本地相册的功能，本人还是强烈推荐自己实现，因为采用系统的，灵活性差，更重要的是，经常会有一些 莫名其妙的bug</p>
<p>这里给大家推荐两种实现方式，一个是鸿洋大神以前写的，一个是GitHub的开源库。</p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/39943731">Android 超高仿微信图片选择器 图片该这么加载</a></p>
<p>Android仿微信图片上传，可以选择多张图片，缩放预览，拍照上传等</p>
<p><a href="https://github.com/zfdang/android-multiple-images-selector">android-multiple-images-selector</a></p>
<hr>
<h2 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h2><p>关于裁剪图片的Intent，网上的大多数做法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">cropPic</span><span class="params">(Uri imageUri)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.android.camera.action.CROP&quot;</span>);</span><br><span class="line"></span><br><span class="line">    intent.putExtra(<span class="string">&quot;crop&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置x,y的比例，截图方框就按照这个比例来截 若设置为0,0，或者不设置 则自由比例截图</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;aspectX&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    intent.putExtra(<span class="string">&quot;aspectY&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪区的宽和高 其实就是裁剪后的显示区域 若裁剪的比例不是显示的比例，</span></span><br><span class="line">    <span class="comment">// 则自动压缩图片填满显示区域。若设置为0,0 就不显示。若不设置，则按原始大小显示</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;outputX&quot;</span>, <span class="number">200</span>);</span><br><span class="line">    intent.putExtra(<span class="string">&quot;outputY&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不知道有啥用。。可能会保存一个比例值 需要相关文档啊</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;scale&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true的话直接返回bitmap，可能会很占内存 不建议</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;return-data&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 上面设为false的时候将MediaStore.EXTRA_OUTPUT即&quot;output&quot;关联一个Uri</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;output&quot;</span>, imageUri);</span><br><span class="line">    <span class="comment">// 看参数即可知道是输出格式</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;outputFormat&quot;</span>, Bitmap.CompressFormat.JPEG.toString());</span><br><span class="line">    <span class="comment">// 面部识别 这里用不上</span></span><br><span class="line">    intent.putExtra(<span class="string">&quot;noFaceDetection&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你运行代码的时候，部分设备会报错，大致的意思是：com.android.camera.action.CROP 的Activity  not found</p>
<p>解决方法，我们可以捕获一下异常，防止发生崩溃，并弹出吐司提醒用户不支持裁剪功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Intent intent = IntentUtils.cropPic(Uri.fromFile(mF));</span><br><span class="line">    startActivityForResult(intent,req_crop);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ActivityNotFoundException a)&#123;</span><br><span class="line">    String errorMessage = <span class="string">&quot;Your device doesn&#x27;t support the crop action!&quot;</span>;</span><br><span class="line">    Toast toast = Toast.makeText(<span class="keyword">this</span>, errorMessage, Toast.LENGTH_SHORT);</span><br><span class="line">    toast.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，github上面有两个比较好的开源库</p>
<p><a href="https://github.com/jdamcd/android-crop">android-crop</a></p>
<p><a href="https://github.com/edmodo/cropper">cropper</a></p>
<hr>
<p><strong><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53411790">文章首发地址CSDN：</a><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53411790">http://blog.csdn.net/gdutxiaoxu/article/details/53411790</a></strong></p>
<p><strong><a href="http://download.csdn.net/detail/gdutxiaoxu/9698246">源码下载地址：</a><a href="http://download.csdn.net/detail/gdutxiaoxu/9698246">http://download.csdn.net/detail/gdutxiaoxu/9698246</a></strong></p>
]]></content>
      <tags>
        <tag>启动系统相机</tag>
        <tag>启动相册</tag>
        <tag>6.0权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title> Retrofit使用教程（一）- Retrofit入门详解</title>
    <url>/2016/12/08/Retrofit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89-Retrofit%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Retrofit使用教程（一）-Retrofit入门详解"><a href="#Retrofit使用教程（一）-Retrofit入门详解" class="headerlink" title="Retrofit使用教程（一）- Retrofit入门详解"></a>Retrofit使用教程（一）- Retrofit入门详解</h1><hr>
<p><strong><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52745491">转载请注明博客地址：</a><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52745491">http://blog.csdn.net/gdutxiaoxu/article/details/52745491</a></strong></p>
<p><strong><a href="https://github.com/gdutxiaoxu/RetrofitDemo.git">源码下载地址：</a><a href="https://github.com/gdutxiaoxu/RetrofitDemo.git">https://github.com/gdutxiaoxu/RetrofitDemo.git</a></strong></p>
<p><strong>本人已经好久没有更新 博客了，这次更新博客打算写一下retrofit的使用教程系列的 博客，写作思路大概如下</strong></p>
<ul>
<li>先从retrofit的基本使用讲起;</li>
<li>接着将retrofit结合RxJava的使用;</li>
<li>接着讲Retrofit的封装使用，（包括错误统一处理）;</li>
<li>有时间和能力的话会尝试研究一下retrofit的 源码.</li>
</ul>
<h2 id="本篇博客主要讲解以下问题"><a href="#本篇博客主要讲解以下问题" class="headerlink" title="本篇博客主要讲解以下问题"></a>本篇博客主要讲解以下问题</h2><ul>
<li>Retrofit简介</li>
<li>Retrofit的简单使用例子</li>
<li>Retrofit的get请求</li>
<li>Retrofit的put请求（提交表单数据）</li>
<li>如何为 retrofit添加header</li>
<li>如何提交json数据</li>
</ul>
<h2 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h2><p>Retrofit是square开源的网络请求库，底层是使用OKHttp封装的，网络请求速度很快.</p>
<h3 id="主要有一下几种请求方法"><a href="#主要有一下几种请求方法" class="headerlink" title="主要有一下几种请求方法"></a>主要有一下几种请求方法</h3><table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>@GET</td>
<td>表示这是一个GET请求</td>
</tr>
<tr>
<td>@POST</td>
<td>表示这个一个POST请求</td>
</tr>
<tr>
<td>@PUT</td>
<td>表示这是一个PUT请求</td>
</tr>
<tr>
<td>@DELETE</td>
<td>表示这是一个DELETE请求</td>
</tr>
<tr>
<td>@HEAD</td>
<td>表示这是一个HEAD请求</td>
</tr>
<tr>
<td>@OPTIONS</td>
<td>表示这是一个OPTION请求</td>
</tr>
<tr>
<td>@PATCH</td>
<td>表示这是一个PAT请求</td>
</tr>
</tbody></table>
<h3 id="各种请求注解的意思"><a href="#各种请求注解的意思" class="headerlink" title="各种请求注解的意思"></a>各种请求注解的意思</h3><table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>@Headers</td>
<td>添加请求头</td>
</tr>
<tr>
<td>@Path</td>
<td>替换路径</td>
</tr>
<tr>
<td>@Query</td>
<td>替代参数值，通常是结合get请求的</td>
</tr>
<tr>
<td>@FormUrlEncoded</td>
<td>用表单数据提交</td>
</tr>
<tr>
<td>@Field</td>
<td>替换参数值，是结合post请求的</td>
</tr>
</tbody></table>
<h2 id="Retrofit的简单使用例子"><a href="#Retrofit的简单使用例子" class="headerlink" title="Retrofit的简单使用例子"></a>Retrofit的简单使用例子</h2><p>要使用retrofit请求网络数据，大概可以分为以下几步</p>
<ul>
<li>1)添加依赖，这里以AndroidStudio为例：在build.grale添加如下依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> compile <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.1.0&#x27;</span></span><br><span class="line">compile <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2） 创建Retrofit对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        <span class="comment">//使用自定义的mGsonConverterFactory</span></span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .baseUrl(<span class="string">&quot;http://apis.baidu.com/txapi/&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">mApi = retrofit.create(APi.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3）发起网络请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mApi = retrofit.create(APi.class);</span><br><span class="line">Call&lt;News&gt; news = mApi.getNews(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">news.enqueue(<span class="keyword">new</span> Callback&lt;News&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;News&gt; call, Response&lt;News&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;News&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">APi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Headers(&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;)</span></span><br><span class="line">    <span class="meta">@GET(&quot;word/word&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;News&gt; <span class="title">getNews</span><span class="params">(<span class="meta">@Query(&quot;num&quot;)</span> String num,<span class="meta">@Query(&quot;page&quot;)</span>String page)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>到此一个简单的使用retrofit的网络请求就完成了。</strong>接下来我们来了解retrofit的各种请求方式。</p>
<hr>
<h2 id="Retrofit的get请求"><a href="#Retrofit的get请求" class="headerlink" title="Retrofit的get请求"></a>Retrofit的get请求</h2><p>加入我们想请求这样的网址：<a href="http://apis.baidu.com/txapi/world/world?num=10&amp;page=1%EF%BC%8Cheader%E4%B8%BA&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;,%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B7%E6%B1%82%EF%BC%9A">http://apis.baidu.com/txapi/world/world?num=10&amp;page=1，header为&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;,我们可以这样请求：</a></p>
<p>第一步，在interface Api中 增加如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Headers(&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;)</span></span><br><span class="line"><span class="meta">@GET(&quot;word/word&quot;)</span></span><br><span class="line"><span class="function">Call&lt;News&gt; <span class="title">getNews</span><span class="params">(<span class="meta">@Query(&quot;num&quot;)</span> String num,<span class="meta">@Query(&quot;page&quot;)</span>String page)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二部，在代码里面请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建retrofit对象</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        <span class="comment">//使用自定义的mGsonConverterFactory</span></span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .baseUrl(<span class="string">&quot;http://apis.baidu.com/txapi/&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 实例化我们的mApi对象</span></span><br><span class="line">mApi = retrofit.create(APi.class); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用我们的响应的方法</span></span><br><span class="line">Call&lt;News&gt; news = mApi.getNews(number, page);</span><br><span class="line">news.enqueue(<span class="keyword">new</span> Callback&lt;News&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;News&gt; call, Response&lt;News&gt; response)</span> </span>&#123;</span><br><span class="line">        News body = response.body();</span><br><span class="line">        Logger.i(<span class="string">&quot;onResponse:   =&quot;</span>+body.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;News&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        Logger.i(<span class="string">&quot;onResponse:   =&quot;</span>+t.getMessage());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h3><p>假设BaseUrl是<a href="http://apis.baidu.com/txapi/%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B">http://apis.baidu.com/txapi/的前提下</a></p>
<ul>
<li>1）其中 @GET(“word/word”)会追加到baseUrl ：<a href="http://apis.baidu.com/txapi/%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E5%8D%B3%E5%8F%98%E6%88%90%EF%BC%9Ahttp://apis.baidu.com/txapi/world/world">http://apis.baidu.com/txapi/的后面，即变成：http://apis.baidu.com/txapi/world/world</a></li>
<li>2）@Query(“num”) String num,@Query(“page”)String page；分别对应键值的名称与值。会追加到<a href="http://apis.baidu.com/txapi/world/world%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E8%AF%B7%E6%B1%82%E7%BD%91%E5%9D%80%E5%8D%B3%E5%8F%98%E6%88%90:http://apis.baidu.com/txapi/world/world?num=10&amp;page=1">http://apis.baidu.com/txapi/world/world的后面，请求网址即变成:http://apis.baidu.com/txapi/world/world?num=10&amp;page=1</a></li>
<li>3）  @Headers(“apikey:81bf9da930c7f9825a3c3383f1d8d766”)是 在基础之上为 其添加响应头</li>
<li>4）如果想继续增加参数，只需要在方法参数追加这样的形式就OK了：<br>,@Query(“page”)String page</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers(&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;)</span></span><br><span class="line"><span class="meta">@GET(&quot;word/word&quot;)</span></span><br><span class="line"><span class="function">Call&lt;News&gt; <span class="title">getNews</span><span class="params">(<span class="meta">@Query(&quot;num&quot;)</span> String num,<span class="meta">@Query(&quot;page&quot;)</span>String page，<span class="meta">@Query(&quot;type&quot;)</span> String type)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>5)加入我们想要请求这样的网址<a href="http://apis.baidu.com/txapi/tiyu/tiyu?num=10&amp;page=1%EF%BC%8C,%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99">http://apis.baidu.com/txapi/tiyu/tiyu?num=10&amp;page=1，,我们可以这样写</a></li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Headers(&#123;&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot; ,&quot;Content-Type:application/json&quot;&#125;)</span></span><br><span class="line"><span class="meta">@GET(&quot;&#123;type&#125;/&#123;type&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;News&gt; <span class="title">tiYu</span><span class="params">(<span class="meta">@Path(&quot;type&quot;)</span> String type, <span class="meta">@Query(&quot;num&quot;)</span> String num,<span class="meta">@Query(&quot;page&quot;)</span>String page)</span></span>;</span><br><span class="line">String type=<span class="string">&quot;tiyu&quot;</span>;</span><br><span class="line">Call&lt;News&gt; news = api.tiYu(type,number, page);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="retrofit的post请求"><a href="#retrofit的post请求" class="headerlink" title="retrofit的post请求"></a>retrofit的post请求</h2><p>假如我们想要 请求这样的网址<a href="http://apis.baidu.com/txapi/world/world?%E4%BB%A5post%E7%9A%84">http://apis.baidu.com/txapi/world/world?以post的</a> 方式提交这样的 数据：num=10&amp;page=1，我们可以写成 如下的 样子，注意post的时候必须使用@Field这种形式的注解，而不是使用@Query这种形式的注解，其他的 与get请求一样，这样只给出核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line"><span class="meta">@Headers(&#123;&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot; ,&quot;Content-Type:application/json&quot;&#125;)</span></span><br><span class="line"><span class="meta">@POST(&quot;world/world&quot;)</span></span><br><span class="line"><span class="function">Call&lt;News&gt; <span class="title">postNews</span><span class="params">(<span class="meta">@Field(&quot;num&quot;)</span> String num, <span class="meta">@Field(&quot;page&quot;)</span>String page)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何为retrofit添加请求头head"><a href="#如何为retrofit添加请求头head" class="headerlink" title="如何为retrofit添加请求头head"></a>如何为retrofit添加请求头head</h2><p>总共有以下几种方式</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>在OKHttpClient interceptors里面进行处理，这样添加的headKey不会覆盖掉 前面的 headKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">okHttpClient.interceptors().add(<span class="keyword">new</span> Interceptor() &#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request original = chain.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Request customization: add request headers</span></span><br><span class="line">        Request.Builder requestBuilder = original.newBuilder()</span><br><span class="line">                    .addHeader(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">                    .addHeader(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Request request = requestBuilder.build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>同样在在OKHttpClient interceptors里面进行处理，这样添加的headKey会覆盖掉 前面的 headKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">okHttpClient.interceptors().add(<span class="keyword">new</span> Interceptor() &#123;  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request original = chain.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Request customization: add request headers</span></span><br><span class="line">        Request.Builder requestBuilder = original.newBuilder()</span><br><span class="line">                .header(<span class="string">&quot;headerkey&quot;</span>, <span class="string">&quot;header-value&quot;</span>); <span class="comment">// &lt;-- this is the important line</span></span><br><span class="line"></span><br><span class="line">        Request request = requestBuilder.build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>利用 retrofit自带的注解，比如我们想要添加这样的请求头：”apikey:81bf9da930c7f9825a3c3383f1d8d766” ,”Content-Type:application/json”；则可以写成如下的 样式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers(&#123;&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot; ,&quot;Content-Type:application/json&quot;&#125;)</span></span><br><span class="line"><span class="meta">@GET(&quot;world/world&quot;)</span></span><br><span class="line"><span class="function">Call&lt;News&gt; <span class="title">getNews</span><span class="params">(<span class="meta">@Query(&quot;num&quot;)</span> String num,<span class="meta">@Query(&quot;page&quot;)</span>String page)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过post提交json数据"><a href="#通过post提交json数据" class="headerlink" title="通过post提交json数据"></a>通过post提交json数据</h2><p>Post 提交JSON数据</p>
<p>有时提交的数据量比较大时，用键值对的方式提交参数不太方便，Retrofit可以通过@Body注释，直接传递一个对象给请求主体，Retrofit通过JSON转化器，把对象映射成JSON数据。</p>
<p>假设我们需要提交的数据为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;my task title&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口定义：</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Headers(&#123;&quot;Content-Type: application/json&quot;,&quot;Accept:  application/json&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@POST(&quot;/tasks&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Task&gt; <span class="title">createTask</span><span class="params">(<span class="meta">@Body</span> Task task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传递实体需要有Model：</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">long</span> id, String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端调用：</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Task task = <span class="keyword">new</span> Task(<span class="number">1</span>, <span class="string">&quot;my task title&quot;</span>);  </span><br><span class="line">Call&lt;Task&gt; call = taskService.createTask(task);  </span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;Task&gt;() &#123;&#125;); </span><br></pre></td></tr></table></figure>

<ul>
<li>这样，服务端得到的是JOSN数据：</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;my task title&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>到此，这篇博客为止</p>
<h2 id="题外话："><a href="#题外话：" class="headerlink" title="题外话："></a>题外话：</h2><p>其实retrofit在5月份实习的时候就接触了，之前为什么不写 博客了，因为网上的 使用教程很多，觉得没有必要。到后面学习的时候，发现retrofit的使用时 比较灵活的，并且使用方法也是相对较多的，于是，就写了retrofit这系列的使用博客。</p>
<p><strong><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52745491">转载请注明博客地址：</a><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52745491">http://blog.csdn.net/gdutxiaoxu/article/details/52745491</a></strong></p>
<p><strong><a href="https://github.com/gdutxiaoxu/RetrofitDemo.git">源码下载地址：</a><a href="https://github.com/gdutxiaoxu/RetrofitDemo.git">https://github.com/gdutxiaoxu/RetrofitDemo.git</a></strong></p>
<p><strong><a href="http://square.github.io/retrofit/">参考官网地址</a><a href="http://square.github.io/retrofit/">http://square.github.io/retrofit/</a></strong></p>
]]></content>
      <tags>
        <tag>Retrofit</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的自定义View例子一(FlowLayout)</title>
    <url>/2016/12/08/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%BE%8B%E5%AD%90%E4%B8%80-FlowLayout/</url>
    <content><![CDATA[<p>﻿</p>
<h1 id="常用的自定义View例子一（-FlowLayout）"><a href="#常用的自定义View例子一（-FlowLayout）" class="headerlink" title="常用的自定义View例子一（ FlowLayout）"></a>常用的自定义View例子一（ FlowLayout）</h1><p><strong>在Android开发中，我们经常会遇到流布式的布局，经常会用来一些标签的显示，比如qq中个人便签，搜索框下方提示的词语，这些是指都是流布式的布局，今天我就我们日常开放中遇到的流布式布局坐一些总结</strong></p>
<p><strong><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51765428">转载请注明博客地址：</a><a href="http://blog.csdn.net/gdutxiaoxu/article/details/51765428">http://blog.csdn.net/gdutxiaoxu/article/details/51765428</a></strong></p>
<p>**<a href="https://github.com/gdutxiaoxu/CustomViewDemo.git">源码下载地址：</a><a href="https://github.com/gdutxiaoxu/CustomViewDemo.git">https://github.com/gdutxiaoxu/CustomViewDemo.git</a> **</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-5c7ec8613c260711?imageMogr2/auto-orient/strip" alt="效果图"></p>
<h2 id="1-先给大家看一下效果"><a href="#1-先给大家看一下效果" class="headerlink" title="1. 先给大家看一下效果"></a>1. 先给大家看一下效果</h2><ul>
<li>图一</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-853e808198e625ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<ul>
<li>图二</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-29a7127ebbcc1d0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<hr>
<p><strong>仔细观察，我们可以知道图二其实是图一效果的升级版，图一当我们控件的宽度超过这一行的时候，剩余的宽度它不会自动分布到每个控件中，而图二的效果当我们换行的时候，如控件还没有占满这一行的时候，它会自动把剩余的宽度分布到每个控件中</strong></p>
<h2 id="2-废话不多说了，大家来直接看来看一下图一的源码"><a href="#2-废话不多说了，大家来直接看来看一下图一的源码" class="headerlink" title="2.废话不多说了，大家来直接看来看一下图一的源码"></a>2.废话不多说了，大家来直接看来看一下图一的源码</h2><h3 id="1）代码如下"><a href="#1）代码如下" class="headerlink" title="1）代码如下"></a>1）代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 博客地址：http://blog.csdn.net/gdutxiaoxu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xujun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2016/6/20 23:49.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFlowLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  verticalSpacing = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFlowLayout</span><span class="params">(Context context )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写onMeasure方法是为了确定最终的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthMeasureSpec</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heightMeasureSpec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">        <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">        <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">        <span class="keyword">int</span> paddingBottom = getPaddingBottom();</span><br><span class="line"><span class="comment">//处理Padding属性，让当前的ViewGroup支持Padding</span></span><br><span class="line">        <span class="keyword">int</span> widthUsed = paddingLeft + paddingRight;</span><br><span class="line">        <span class="keyword">int</span> heightUsed = paddingTop + paddingBottom;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> childMaxHeightOfThisLine = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line"><span class="comment">//       已用的宽度</span></span><br><span class="line">                <span class="keyword">int</span> childUsedWidth = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//      已用的高度</span></span><br><span class="line">                <span class="keyword">int</span> childUsedHeight = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  调用ViewGroup自身的方法测量孩子的宽度和高度，我们也可以自己根据MeasureMode来测量</span></span><br><span class="line">                measureChild(child,widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">                childUsedWidth += child.getMeasuredWidth();</span><br><span class="line">                childUsedHeight += child.getMeasuredHeight();</span><br><span class="line"><span class="comment">//处理Margin，支持孩子的Margin属性</span></span><br><span class="line">                Rect marginRect = getMarginRect(child);</span><br><span class="line">                <span class="keyword">int</span> leftMargin=marginRect.left;</span><br><span class="line">                <span class="keyword">int</span> rightMargin=marginRect.right;</span><br><span class="line">                <span class="keyword">int</span> topMargin=marginRect.top;</span><br><span class="line">                <span class="keyword">int</span> bottomMargin=marginRect.bottom;</span><br><span class="line"></span><br><span class="line">                childUsedWidth += leftMargin + rightMargin;</span><br><span class="line">                childUsedHeight += topMargin + bottomMargin;</span><br><span class="line"><span class="comment">//总宽度没有超过本行</span></span><br><span class="line">                <span class="keyword">if</span> (widthUsed + childUsedWidth &lt; widthSpecSize) &#123;</span><br><span class="line">                    widthUsed += childUsedWidth;</span><br><span class="line">                    <span class="keyword">if</span> (childUsedHeight &gt; childMaxHeightOfThisLine) &#123;</span><br><span class="line">                        childMaxHeightOfThisLine = childUsedHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//总宽度已经超过本行</span></span><br><span class="line">                    heightUsed += childMaxHeightOfThisLine + verticalSpacing;</span><br><span class="line">                    widthUsed = paddingLeft + paddingRight + childUsedWidth;</span><br><span class="line">                    childMaxHeightOfThisLine = childUsedHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//加上最后一行的最大高度</span></span><br><span class="line">        heightUsed += childMaxHeightOfThisLine;</span><br><span class="line">        setMeasuredDimension(widthSpecSize, heightUsed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">        <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">        <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">        <span class="keyword">int</span> paddingBottom = getPaddingBottom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了 支持Padding属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> childStartLayoutX = paddingLeft;</span><br><span class="line">        <span class="keyword">int</span> childStartLayoutY = paddingTop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> widthUsed = paddingLeft + paddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> childMaxHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line"><span class="comment">//摆放每一个孩子的高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">int</span> childNeededWidth, childNeedHeight;</span><br><span class="line">                <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> childMeasuredWidth = child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> childMeasuredHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                Rect marginRect = getMarginRect(child);</span><br><span class="line">                <span class="keyword">int</span> leftMargin=marginRect.left;</span><br><span class="line">                <span class="keyword">int</span> rightMargin=marginRect.right;</span><br><span class="line">                <span class="keyword">int</span> topMargin=marginRect.top;</span><br><span class="line">                <span class="keyword">int</span> bottomMargin=marginRect.bottom;</span><br><span class="line">                childNeededWidth = leftMargin + rightMargin + childMeasuredWidth;</span><br><span class="line">                childNeedHeight = topMargin + topMargin + childMeasuredHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                没有超过本行</span></span><br><span class="line">                <span class="keyword">if</span> (widthUsed + childNeededWidth &lt;= r - l) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childNeedHeight &gt; childMaxHeight) &#123;</span><br><span class="line">                        childMaxHeight = childNeedHeight;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left = childStartLayoutX + leftMargin;</span><br><span class="line">                    top = childStartLayoutY + topMargin;</span><br><span class="line">                    right = left + childMeasuredWidth;</span><br><span class="line">                    bottom = top + childMeasuredHeight;</span><br><span class="line">                    widthUsed += childNeededWidth;</span><br><span class="line">                    childStartLayoutX += childNeededWidth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    childStartLayoutY += childMaxHeight + verticalSpacing;</span><br><span class="line">                    childStartLayoutX = paddingLeft;</span><br><span class="line">                    widthUsed = paddingLeft + paddingRight;</span><br><span class="line">                    left = childStartLayoutX + leftMargin;</span><br><span class="line">                    top = childStartLayoutY + topMargin;</span><br><span class="line">                    right = left + childMeasuredWidth;</span><br><span class="line">                    bottom = top + childMeasuredHeight;</span><br><span class="line">                    widthUsed += childNeededWidth;</span><br><span class="line">                    childStartLayoutX += childNeededWidth;</span><br><span class="line">                    childMaxHeight = childNeedHeight;</span><br><span class="line">                &#125;</span><br><span class="line">                child.layout(left, top, right, bottom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Rect <span class="title">getMarginRect</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        LayoutParams layoutParams = child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> leftMargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> topMargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottomMargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> MarginLayoutParams) &#123;</span><br><span class="line">            MarginLayoutParams marginLayoutParams = (MarginLayoutParams) layoutParams;</span><br><span class="line">            leftMargin = marginLayoutParams.leftMargin;</span><br><span class="line">            rightMargin = marginLayoutParams.rightMargin;</span><br><span class="line">            topMargin = marginLayoutParams.topMargin;</span><br><span class="line">            bottomMargin = marginLayoutParams.bottomMargin;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rect(leftMargin, topMargin, rightMargin, bottomMargin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）思路解析"><a href="#2）思路解析" class="headerlink" title="2）思路解析"></a>2）思路解析</h3><ol>
<li><p>首先我们重写onMeasure方法，在OnMeasure方法里面我们调用measureChild（）这个方法去获取每个孩子的宽度和高度，每次增加一个孩子我们执行 widthUsed += childUsedWidth;</p>
</li>
<li><p>添加完一个孩子以后我们判断widthUsed是够超出控件本身的最大宽度widthSpecSize，<br>若没有超过执行 </p>
<pre><code>    widthUsed += childUsedWidth;
    if (childUsedHeight &gt; childMaxHeightOfThisLine) &#123;
     childMaxHeightOfThisLine = childUsedHeight;
     &#125;  
</code></pre>
<p>超过控件的宽度执行</p>
<pre><code>     heightUsed += childMaxHeightOfThisLine + verticalSpacing;
     widthUsed = paddingLeft + paddingRight + childUsedWidth;
     childMaxHeightOfThisLine = childUsedHeight;  
</code></pre>
<p>最后调用 setMeasuredDimension(widthSpecSize, heightUsed);这个方法去设置它的大小</p>
</li>
<li><p>在OnLayout方法里面，所做的工作就是去摆放每一个孩子的位置  ，判断需不需要换行，不需要更改left值，需要换行，更改top值</p>
</li>
</ol>
<h3 id="3）注意事项"><a href="#3）注意事项" class="headerlink" title="3）注意事项"></a>3）注意事项</h3><p>讲解之前，我们先来了解一下一个基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://upload-images.jianshu.io/upload_images/2050203-41f01da256c4c30c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></h2><p><strong>从这张图片里面我们可以得出这样结论</strong></p>
<ol>
<li>Width=控件真正的宽度（realWidth）+PaddingLeft+PaddingRight</li>
<li>margin是子控件相对于父控件的距离</li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li>为了支持控件本身的padding属性，我们做了处理，主要代码如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int widthUsed &#x3D; paddingLeft + paddingRight;</span><br><span class="line">int heightUsed &#x3D; paddingTop + paddingBottom;</span><br><span class="line">     ----------</span><br><span class="line">    if (widthUsed + childUsedWidth &lt; widthSpecSize) &#123;</span><br><span class="line">            widthUsed +&#x3D; childUsedWidth;</span><br><span class="line">            if (childUsedHeight &gt; childMaxHeightOfThisLine) &#123;</span><br><span class="line">                  childMaxHeightOfThisLine &#x3D; childUsedHeight;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; </span><br></pre></td></tr></table></figure></li>
<li>为了支持子控件的margin属性，我们同样也做了处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rect marginRect &#x3D; getMarginRect(child);</span><br><span class="line">int leftMargin&#x3D;marginRect.left;</span><br><span class="line">int rightMargin&#x3D;marginRect.right;</span><br><span class="line">int topMargin&#x3D;marginRect.top;</span><br><span class="line">int bottomMargin&#x3D;marginRect.bottom;</span><br><span class="line">	</span><br><span class="line">childUsedWidth +&#x3D; leftMargin + rightMargin;</span><br><span class="line">childUsedHeight +&#x3D; topMargin + bottomMargin;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>即我们在计算孩子所占用的宽度和高度的时候加上margin属性的高度，接着在计算需要孩子总共用的宽高度的时候加上每个孩子的margin属性的宽高度，这样自然就支持了孩子的margin属性了</p>
<h3 id="4-缺陷"><a href="#4-缺陷" class="headerlink" title="4.缺陷"></a>4.缺陷</h3><p>如下图所见，在控件宽度参差不齐的情况下，控件换行会留下一些剩余的宽度，作为想写出鲁棒性的代码的我们会觉得别扭，于是我们相处了解决办法。<br><img src="http://upload-images.jianshu.io/upload_images/2050203-6cf16ca4cb7c2302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决方法见下面    </p>
<h2 id="图二源码解析"><a href="#图二源码解析" class="headerlink" title="图二源码解析"></a>图二源码解析</h2><p><img src="http://upload-images.jianshu.io/upload_images/2050203-29a7127ebbcc1d0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="废话不多说，先看源码"><a href="#废话不多说，先看源码" class="headerlink" title="废话不多说，先看源码"></a>废话不多说，先看源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 博客地址：http://blog.csdn.net/gdutxiaoxu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xujun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2016/6/26 22:54.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefectFlowLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrefectFlowLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrefectFlowLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrefectFlowLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父容器宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> parentWidthSize;</span><br><span class="line">    <span class="comment">//水平间距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> horizontalSpacing = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//垂直间距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> verticalSpacing = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//当前行</span></span><br><span class="line">    <span class="keyword">private</span> Line currentLine;</span><br><span class="line">    <span class="comment">//所有行的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Line&gt; mLines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//当前行已使用宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userWidth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 行对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一行里面所添加的子View集合</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;View&gt; children;</span><br><span class="line">        <span class="comment">//当前行高度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">        <span class="comment">//当前行已使用宽度</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> lineWidth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加一个子控件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            children.add(child);</span><br><span class="line">            <span class="keyword">if</span> (child.getMeasuredHeight() &gt; height) &#123;</span><br><span class="line">                <span class="comment">//当前行高度以子控件最大高度为准</span></span><br><span class="line">                height = child.getMeasuredHeight();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将每个子控件宽度进行累加，记录使用的宽度</span></span><br><span class="line">            lineWidth += child.getMeasuredWidth();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取行的高度</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取子控件的数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getChildCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> children.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 放置每一行里面的子控件的位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> l 距离最左边的距离</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 距离最顶端的距离</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当前行使用的宽度，等于每个子控件宽度之和+子控件之间的水平距离</span></span><br><span class="line">            lineWidth += horizontalSpacing * (children.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> surplusChild = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> surplus = parentWidthSize - lineWidth;<span class="comment">//剩余宽度</span></span><br><span class="line">            <span class="keyword">if</span> (surplus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有剩余宽度，则将剩余宽度平分给每一个子控件</span></span><br><span class="line">                surplusChild = (<span class="keyword">int</span>) (surplus / children.size()+<span class="number">0.5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.size(); i++) &#123;</span><br><span class="line">                View child = children.get(i);</span><br><span class="line">                child.getLayoutParams().width=child.getMeasuredWidth()+surplusChild;</span><br><span class="line">                <span class="keyword">if</span> (surplusChild&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果长度改变了后，需要重新测量，否则布局中的属性大小还会是原来的大小</span></span><br><span class="line">                    child.measure(MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            child.getMeasuredWidth()+surplusChild,MeasureSpec.EXACTLY)</span><br><span class="line">                            ,MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">                child.layout(l, t, l + child.getMeasuredWidth(), t + child.getMeasuredHeight());</span><br><span class="line">                l += child.getMeasuredWidth() + horizontalSpacing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  getMeasuredWidth()   控件实际的大小</span></span><br><span class="line">    <span class="comment">// getWidth()  控件显示的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将之前测量的数据进行清空，以防复用时影响下次测量</span></span><br><span class="line">        mLines.clear();</span><br><span class="line">        currentLine = <span class="keyword">null</span>;</span><br><span class="line">        userWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取父容器的宽度和模式</span></span><br><span class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        parentWidthSize = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">                - getPaddingLeft() - getPaddingRight();</span><br><span class="line">        <span class="comment">//获取父容器的高度和模式</span></span><br><span class="line">        <span class="keyword">int</span> heigthMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">                - getPaddingTop() - getPaddingBottom();</span><br><span class="line">        <span class="keyword">int</span> childWidthMode, childHeightMode;</span><br><span class="line">        <span class="comment">//为了测量每个子控件，需要指定每个子控件的测量规则</span></span><br><span class="line">        <span class="comment">//子控件设置为WRAP_CONTENT，具体测量规则详见，ViewGroup的getChildMeasureSpec()方法</span></span><br><span class="line">        <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            childWidthMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childWidthMode = widthMode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heigthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            childHeightMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childHeightMode = heigthMode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到子控件高和宽的测量规则</span></span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(parentWidthSize, childWidthMode);</span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(heightSize, childHeightMode);</span><br><span class="line">        currentLine = <span class="keyword">new</span> Line();<span class="comment">//创建第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            <span class="comment">//测量每一个孩子</span></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="comment">//获取当前子控件的实际宽度</span></span><br><span class="line">            <span class="keyword">int</span> childMeasuredWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="comment">//让当前行使用宽度加上当前子控件宽度</span></span><br><span class="line">            userWidth += childMeasuredWidth;</span><br><span class="line">            <span class="keyword">if</span> (userWidth &lt;= parentWidthSize) &#123;</span><br><span class="line">                <span class="comment">//如果当前行使用宽度小于父控件的宽度，则加入该行</span></span><br><span class="line">                currentLine.addChild(child);</span><br><span class="line">                <span class="comment">//当前行使用宽度加上子控件之间的水平距离</span></span><br><span class="line">                userWidth += horizontalSpacing;</span><br><span class="line">                <span class="comment">//如果当前行加上水平距离后超出父控件宽度,则换行</span></span><br><span class="line">                <span class="keyword">if</span> (userWidth &gt; parentWidthSize) &#123;</span><br><span class="line">                    newLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//以防出现一个子控件宽度超过父控件的情况出现</span></span><br><span class="line">                <span class="keyword">if</span> (currentLine.getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                    currentLine.addChild(child);</span><br><span class="line">                &#125;</span><br><span class="line">                newLine();</span><br><span class="line">                <span class="comment">//并将超出范围的当前的子控件加入新的行中</span></span><br><span class="line">                currentLine.addChild(child);</span><br><span class="line">                <span class="comment">//并将使用宽度加上子控件的宽度;</span></span><br><span class="line">                userWidth = child.getMeasuredWidth()+horizontalSpacing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入最后一行，因为如果最后一行宽度不足父控件宽度时，就未换行</span></span><br><span class="line">        <span class="keyword">if</span> (!mLines.contains(currentLine)) &#123;</span><br><span class="line">            mLines.add(currentLine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalHeight = <span class="number">0</span>;<span class="comment">//总高度</span></span><br><span class="line">        <span class="keyword">for</span> (Line line : mLines) &#123;</span><br><span class="line">            <span class="comment">//总高度等于每一行的高度+垂直间距</span></span><br><span class="line">            totalHeight += line.getHeight() + verticalSpacing;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//resolveSize(),将实际高度与父控件高度进行比较，选取最合适的</span></span><br><span class="line">        setMeasuredDimension(parentWidthSize + getPaddingLeft() + getPaddingRight(),</span><br><span class="line">                resolveSize(totalHeight + getPaddingTop() + getPaddingBottom(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 换行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mLines.add(currentLine);<span class="comment">//记录之前行</span></span><br><span class="line">        currentLine = <span class="keyword">new</span> Line();<span class="comment">//重新创建新的行</span></span><br><span class="line">        userWidth = <span class="number">0</span>;<span class="comment">//将使用宽度初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置每个子控件的位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> changed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        l += getPaddingLeft();</span><br><span class="line">        t += getPaddingTop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mLines.size(); i++) &#123;</span><br><span class="line">            Line line = mLines.get(i);</span><br><span class="line">            <span class="comment">//设置每一行的位置，每一行的子控件由其自己去分配</span></span><br><span class="line">            line.onLayout(l, t);</span><br><span class="line">            <span class="comment">//距离最顶端的距离，即每一行高度和垂直间距的累加</span></span><br><span class="line">            t += line.getHeight() + verticalSpacing;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子控件的测量规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 父控件的测量规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子控件设置为WRAP_CONTENT，具体测量规则详见，ViewGroup的getChildMeasureSpec()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            childMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childMode = mode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> childMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-思路解析"><a href="#2-思路解析" class="headerlink" title="2.思路解析"></a>2.思路解析</h3><ol>
<li><p>对比图一的实现思路，我们封装了Line这个内部类，看到这个名字，相信大家都猜到是什么意思了，其实就是一个Line实例对象代表一行，Line里面的List<View> children用来存放孩子</p>
<pre><code> private List&lt;View&gt; children;//一行里面所添加的子View集合
</code></pre>
</li>
<li><p>Line里面还封装了void onLayout(int l, int t)方法，即自己去拜访每个孩子的位置，<br>实现剩余的宽度平均分配，主要体现在这几行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> if (surplus &gt; 0) &#123;</span><br><span class="line"> &#x2F;&#x2F;如果有剩余宽度，则将剩余宽度平分给每一个子控件</span><br><span class="line">      surplusChild &#x3D; (int) (surplus &#x2F; children.size()+0.5);</span><br><span class="line">  &#125;</span><br><span class="line">             -------</span><br><span class="line">&#x2F;&#x2F;重新分配每个孩子的大小</span><br><span class="line"></span><br><span class="line">   child.measure(MeasureSpec.makeMeasureSpec(</span><br><span class="line">   child.getMeasuredWidth()+surplusChild,MeasureSpec.EXACTLY)</span><br><span class="line">           ,MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY));</span><br></pre></td></tr></table></figure>
<h3 id="今天就写到这里了，有时间再来补充，最近考试比较忙，已经好久没有更新博客了。"><a href="#今天就写到这里了，有时间再来补充，最近考试比较忙，已经好久没有更新博客了。" class="headerlink" title="今天就写到这里了，有时间再来补充，最近考试比较忙，已经好久没有更新博客了。"></a>今天就写到这里了，有时间再来补充，最近考试比较忙，已经好久没有更新博客了。</h3></li>
</ol>
<p><a href="https://github.com/gdutxiaoxu/CustomViewDemo.git"><strong>源码下载地址：</strong></a><a href="https://github.com/gdutxiaoxu/CustomViewDemo.git">https://github.com/gdutxiaoxu/CustomViewDemo.git</a></p>
]]></content>
      <tags>
        <tag>FlowLayout</tag>
        <tag>自定义控件</tag>
        <tag>流布式布局</tag>
      </tags>
  </entry>
  <entry>
    <title>360面试心得（Android)</title>
    <url>/2016/12/08/360%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97%EF%BC%88Android/</url>
    <content><![CDATA[<h1 id="360面试心得（Android）"><a href="#360面试心得（Android）" class="headerlink" title="360面试心得（Android）"></a>360面试心得（Android）</h1><hr>
<p>这次360面试，总共面试了两轮，都是视频面试。</p>
<p>时间:2016-08-23</p>
<p><strong>转载请注明<a href="http://blog.csdn.net/gdutxiaoxu/article/details/52371834">原博客地址：</a></strong> </p>
<p><strong>闲谈：</strong></p>
<p>从大二暑假的时候开始，一直想进腾讯或者阿里，在招实习生的时候，最终遗憾落选。暑假的时候为了好好准备校招，我放弃了去步步高实习的机会，继续在原来的一家公司实习。在暑假的时候找师兄师姐内推了腾讯，阿里，最终都没有通过简历筛选，没有面试。说实话，刚开始内心是挺失落的，挺难受的，但经过一两天的调整，我也意识到自己的错误，以前那种强烈想进bat的欲望渐渐淡了下来，当然并不是说不想进bat，只是不再那么注重结果，更注重这奋斗过程中个人的成长。</p>
<h2 id="360一面"><a href="#360一面" class="headerlink" title="360一面"></a>360一面</h2><p>差不多三十五分钟</p>
<ul>
<li>介绍你做过的项目</li>
<li>手写单例模式</li>
<li>布局优化</li>
<li>有没有用过什么开源框架？</li>
<li>ImagLoader的实现原理</li>
<li>OnTouchEvent事件中 down事件 和up事件的传递</li>
<li>hashMap的实现 原理</li>
<li>LinkedHashMap的实现原理</li>
<li>内存管理及优化</li>
<li>点九图</li>
</ul>
<h3 id="点九图"><a href="#点九图" class="headerlink" title="点九图"></a>点九图</h3><p><a href="https://isux.tencent.com/android-ui-9-png.html">https://isux.tencent.com/android-ui-9-png.html</a></p>
<p><img src="https://isux.tencent.com/wp-content/uploads/2013/08/20130808100935745.png"></p>
<p>放大后可以比较明显的看到上下左右分别有一个像素的黑色线段，这里分别标注了序号。简单来说，</p>
<p>序号1和2标识了可以拉伸的区域，</p>
<p>序号3和4标识了内容区域。当设定了按钮实际应用的宽和高之后，横向会拉伸1区域的像素，纵向会拉伸2区域的像素。如下图：</p>
<p><img src="https://isux.tencent.com/wp-content/uploads/2013/08/20130808105705727-590x223.png"></p>
<p>这里程序设置的文字垂直居中，水平居左的对齐方式。对齐方式是没有问题的，但是对于这种大圆角同时又有些不规则边框的的图形来说，错误的标注方式会让排版看起来很混乱。所以我们需要修正内容区域的线段位置和长度。</p>
<p><img src="https://isux.tencent.com/wp-content/uploads/2013/08/20130808105728711-590x200.png"></p>
<h4 id="有两点需要特别注意下："><a href="#有两点需要特别注意下：" class="headerlink" title="有两点需要特别注意下："></a>有两点需要特别注意下：</h4><p>1.最外围的一圈像素必须要么是纯黑色，要么是透明，一点点的半透明的像素都不可以有，比如说99%的黑色或者是1%的投影都不可以有;</p>
<p>2.文件的后缀名必须是.9.png，不能是.png或者是.9.png.png，这样的命名都会导致编译失败。</p>
<h3 id="内存管理及优化"><a href="#内存管理及优化" class="headerlink" title="内存管理及优化"></a>内存管理及优化</h3><p>我这里答的是内存泄漏和oom<br>少用static静态变量</p>
<ol>
<li>珍惜Services资源</li>
</ol>
<p>我们知道service所在的Activity级别相对后台Activity的级别是比较 高的，一般不易被回收。<br>在service不再使用的时候，及时退出。最好的方法是使用IntentService</p>
<p>2）在UI不可见的时候释放资源</p>
<p>当用户切换到其它应用并且你的应用 UI不再可见时，你应该释放你的应用UI上所占用的所有内存资源。在这个时候释放UI资源可以显著的增加系统缓存进程的能力，它会对用户体验有着很直接的影响。</p>
<p>为了能够接收到用户离开你的UI时的通知，你需要实现Activtiy类里面的onTrimMemory()回调方法。你应该使用这个方法来监听到TRIM_MEMORY_UI_HIDDEN级别的回调，此时意味着你的UI已经隐藏，你应该释放那些仅仅被你的UI使用的资源。</p>
<p>请注意：你的应用仅仅会在所有UI组件的被隐藏的时候接收到onTrimMemory()的回调并带有参数TRIM_MEMORY_UI_HIDDEN。这与onStop()的回调是不同的，onStop会在activity的实例隐藏时会执行，例如当用户从你的app的某个activity跳转到另外一个activity时前面activity的onStop()会被执行。因此你应该实现onStop回调，并且在此回调里面释放activity的资源，例如释放网络连接，注销监听广播接收者。除非接收到onTrimMemory(TRIM_MEMORY_UI_HIDDEN))的回调，否者你不应该释放你的UI资源。这确保了用户从其他activity切回来时，你的UI资源仍然可用，并且可以迅速恢复activity。</p>
<ol start="3">
<li>当内存紧张时释放部分内存</li>
</ol>
<p><a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html#TRIM_MEMORY_COMPLETE">关于onTrimMemory的介绍</a></p>
<p>在你的app生命周期的任何阶段，onTrimMemory的回调方法同样可以告诉你整个设备的内存资源已经开始紧张。你应该根据onTrimMemory回调中的内存级别来进一步决定释放哪些资源。</p>
<p>TRIM_MEMORY_RUNNING_MODERATE：你的app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。<br>TRIM_MEMORY_RUNNING_LOW：你的app正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能（但是这也会直接影响到你的app的性能）。<br>TRIM_MEMORY_RUNNING_CRITICAL：你的app仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。<br>同样，当你的app进程正在被cached时，你可能会接受到从onTrimMemory()中返回的下面的值之一:</p>
<p>TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。<br>TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。<br>TRIM_MEMORY_COMPLETE: 系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源。<br>因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。</p>
<p>Note: 当系统开始清除LRU缓存中的进程时，尽管它首先按照LRU的顺序来操作，但是它同样会考虑进程的内存使用量。因此消耗越少的进程则越容易被留下来。</p>
<ol start="4">
<li>避免bitmaps的浪费</li>
</ol>
<p>当你加载一个bitmap时，仅仅需要保留适配当前屏幕设备分辨率的数据即可，如果原图高于你的设备分辨率，需要做缩小的动作。请记住，增加bitmap的尺寸会对内存呈现出2次方的增加，因为X与Y都在增加。</p>
<p>Note:在Android 2.3.x (API level 10)及其以下, bitmap对象的pixel data是存放在native内存中的，它不便于调试。然而，从Android 3.0(API level 11)开始，bitmap pixel data是分配在你的app的Dalvik heap中, 这提升了GC的工作效率并且更加容易Debug。因此如果你的app使用bitmap并在旧的机器上引发了一些内存问题，切换到3.0以上的机器上进行Debug。</p>
<ol start="5">
<li>使用优化的数据容器</li>
</ol>
<p>利用Android Framework里面优化过的容器类，例如SparseArray, SparseBooleanArray, 与 LongSparseArray。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>
<ol start="6">
<li>请注意内存开销</li>
</ol>
<p>对你所使用的语言与库的成本与开销有所了解，从开始到结束，在设计你的app时谨记这些信息。通常，表面上看起来无关痛痒(innocuous)的事情也许实际上会导致大量的开销。例如：</p>
<p>Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。<br>在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。<br>每一个类的实例花销是12-16 bytes。<br>往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。<br>7) 请注意代码“抽象”</p>
<p>通常，开发者使用抽象作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的开销：通常他们需要同等量的代码用于可执行。那些代码会被map到内存中。因此如果你的抽象没有显著的提升效率，应该尽量避免他们。</p>
<ol start="8">
<li>使用ProGuard来剔除不需要的代码</li>
</ol>
<p>ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。</p>
<ol start="9">
<li>对最终的APK使用zipalign</li>
</ol>
<p>在编写完所有代码，并通过编译系统生成APK之后，你需要使用zipalign对APK进行重新校准。如果你不做这个步骤，会导致你的APK需要更多的RAM，因为一些类似图片资源的东西不能被mapped。</p>
<p>Notes: Google Play不接受没有经过zipalign的APK。</p>
<h2 id="360二面"><a href="#360二面" class="headerlink" title="360二面"></a>360二面</h2><p>一面过了十多分钟以后，接着就进行二面，都是视频面试，差不多二十分钟左右</p>
<ul>
<li>AsyncTak的原理及常用方法</li>
<li>APK从安装到启动的过程</li>
<li>平时是怎样学习的？</li>
<li>学习和实习是在怎样协调的 ？</li>
<li>有360手机助手有什么想了解的吗？</li>
</ul>
<h3 id="对360手机助手有什么想了解的？"><a href="#对360手机助手有什么想了解的？" class="headerlink" title="对360手机助手有什么想了解的？"></a>对360手机助手有什么想了解的？</h3><p>这里我提问的是省流量升级是怎样实现的？<br>后面追问是不是利用动态加载技术。面试官解释的是不是你，是对比版本之间的二进制文件差异。</p>
<h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>两轮面试面试官人都挺好的，都面带笑容个，感觉很好说话，当天晚上我加了面试官的微信，问他多久会出结果，面试官问我说后面有没有接到电话，我说没有，然后面试官说应该被刷了。</p>
<h3 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h3><p>可能是第一次视频面试，感觉个人太紧张了，有好多原理性的东西讲着讲着就忘记讲了，面试的时候真的是太紧张了，发挥不太好，平时一定要多总结，不然面试的时候一下子总结地不太好，发挥不出应有的水平。</p>
<p><strong>转载请注明<a href="http://blog.csdn.net/gdutxiaoxu/article/details/52371834">原博客地址：</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示</title>
    <url>/2016/12/08/%E8%87%AA%E5%AE%9A%E4%B9%89Behavior-%E2%80%94%E2%80%94-%E4%BB%BF%E7%9F%A5%E4%B9%8E%EF%BC%8CFloatActionButton%E9%9A%90%E8%97%8F%E4%B8%8E%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示</a></p>
<p>前段时间写了一篇博客<a href="http://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a>,主要介绍了APPBarLayout和CollapsingToolbarLayout的基本用法，AppBarLayout主要用来实现在滚动的时候ToolBar的 隐藏于展示，CollapsingToolbarLayout主要用来实现parallax和pin等效果。如果你对CoordinatorLayout还不了解的话，请先阅读这篇文章。</p>
<p><strong>写作思路</strong></p>
<ul>
<li>CoordinatorLayout Behavior 简介</li>
<li>怎样自定义 Behavior</li>
<li>仿知乎效果 自定义 Behavior 的实现</li>
<li>自定义 Behavior 两种方法的 对比</li>
<li>FloatActionButton 自定义 Behavior 效果的实现</li>
<li>题外话</li>
</ul>
<p>今天就来讲解怎样通过自定义behavior来实现各种炫酷的效果 ，效果图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-f12821aa91a41c79.jpg?imageMogr2/auto-orient/strip"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-afd17ba4e0ffde71.jpg?imageMogr2/auto-orient/strip"></p>
<h2 id="下面让我们一起来看一下怎样实现仿知乎的效果"><a href="#下面让我们一起来看一下怎样实现仿知乎的效果" class="headerlink" title="下面让我们一起来看一下怎样实现仿知乎的效果"></a>下面让我们一起来看一下怎样实现仿知乎的效果</h2><p>老规矩，先看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    android:id=<span class="string">&quot;@+id/coordinatorLayout&quot;</span></span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line"></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/index_app_bar&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;@style/AppTheme.AppBarOverlay&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;@color/colorPrimary&quot;</span></span><br><span class="line">            app:layout_scrollFlags=<span class="string">&quot;scroll|enterAlways&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:id=<span class="string">&quot;@+id/search&quot;</span></span><br><span class="line">                android:layout_width=<span class="string">&quot;24dp&quot;</span></span><br><span class="line">                android:layout_height=<span class="string">&quot;24dp&quot;</span></span><br><span class="line">                android:layout_centerVertical=<span class="string">&quot;true&quot;</span></span><br><span class="line">                android:layout_marginLeft=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">                android:src=<span class="string">&quot;@drawable/search&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">                android:layout_centerVertical=<span class="string">&quot;true&quot;</span></span><br><span class="line">                android:layout_marginLeft=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">                android:layout_toRightOf=<span class="string">&quot;@id/search&quot;</span></span><br><span class="line">                android:text=<span class="string">&quot;搜索话题、问题或人&quot;</span></span><br><span class="line">                android:textSize=<span class="string">&quot;16sp&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/recyclerView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        app:layout_behavior=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--使用RadioGroup来实现tab的切换--&gt;</span><br><span class="line">    &lt;RadioGroup</span><br><span class="line">        android:id=<span class="string">&quot;@+id/rg&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;bottom&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@color/bg_tab&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">        app:layout_behavior=<span class="string">&quot;@string/behavior_footer&quot;</span></span><br><span class="line">        &gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/rb_home&quot;</span></span><br><span class="line">            style=<span class="string">&quot;@style/bottom_tab&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/sel_home&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;Home&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/rb_course&quot;</span></span><br><span class="line">            style=<span class="string">&quot;@style/bottom_tab&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/sel_course&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;course&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/rb_direct_seeding&quot;</span></span><br><span class="line">            style=<span class="string">&quot;@style/bottom_tab&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/sel_direct_seeding&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;direct&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/rb_me&quot;</span></span><br><span class="line">            style=<span class="string">&quot;@style/bottom_tab&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/sel_me&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;me&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RadioGroup&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name&#x3D;&quot;bottom_tab&quot;&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_width&quot;&gt;0dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_height&quot;&gt;60dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_weight&quot;&gt;1&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:text&quot;&gt;0dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:gravity&quot;&gt;center&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:textColor&quot;&gt;@drawable&#x2F;sel_bottom_tab_text&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:padding&quot;&gt;10dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:button&quot;&gt;@null&lt;&#x2F;item&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;style name&#x3D;&quot;bottom_tab&quot;&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_width&quot;&gt;0dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_height&quot;&gt;60dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:layout_weight&quot;&gt;1&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:text&quot;&gt;0dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:gravity&quot;&gt;center&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:textColor&quot;&gt;@drawable&#x2F;sel_bottom_tab_text&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:padding&quot;&gt;10dp&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;android:button&quot;&gt;@null&lt;&#x2F;item&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a><strong>思路分析</strong></h3><p>根据动态如可以看到，主要有两个效果</p>
<ul>
<li>上面的AppBarLayout 向上滑动的时候会隐藏，向下滑动的时候会展示，说白了就是给APPLayout的子View Relativelayout 设置   app:layout_scrollFlags=”scroll|enterAlways”，核心代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;index_app_bar&quot;</span><br><span class="line">    theme&#x3D;&quot;@style&#x2F;AppTheme.AppBarOverlay&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;?attr&#x2F;actionBarSize&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;colorPrimary&quot;</span><br><span class="line">        app:layout_scrollFlags&#x3D;&quot;scroll|enterAlways&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      ----</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;RelativeLayout&gt;</span><br><span class="line"> &lt;&#x2F;android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面的 RadioGroup ，我们可以看到，向上 滑动的时候会隐藏，向下滑动的时候会显示，其实我们只是给其设置了 behavior 而已 app:layout_behavior=”@string/behavior_footer”，那这个behavior_footer是什么东西，别急 ，下面就是介绍了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name&#x3D;&quot;behavior_footer&quot;&gt;com.xujun.contralayout.behavior.FooterBehavior&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Behavior简介"><a href="#Behavior简介" class="headerlink" title="Behavior简介"></a>Behavior简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/2050203-29feb55fbedd7f2e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Behavior是CoordinatorLayout里面的一个内部类，通过它我们可以与 CoordinatorLayout的一个或者多个子View进行交互，包括 drag，swipes, flings等手势动作。</p>
<p>今天 我们主要着重介绍里面的几个方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>boolean    layoutDependsOn(CoordinatorLayout parent, V child, View dependency)</td>
<td>确定child View 是否有一个特定的兄弟View作为布局的依赖（即dependency）</td>
</tr>
<tr>
<td>boolean    onDependentViewChanged(CoordinatorLayout parent, V child, View dependency)</td>
<td>当child View 的 dependent view 发生变化的时候，这个方法会调用</td>
</tr>
<tr>
<td>boolean    onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes)</td>
<td>当CoordinatorLayout 的直接或者非直接子View开始准备嵌套滑动的时候会调用</td>
</tr>
<tr>
<td>void    onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)</td>
<td>当嵌套滑动的 时候，target尝试滑动或者正在滑动的 时候会调用</td>
</tr>
</tbody></table>
<p>关于更多方法，请参考官<a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html">网文档说明</a></p>
<h2 id="怎样自定义Behavior"><a href="#怎样自定义Behavior" class="headerlink" title="怎样自定义Behavior"></a>怎样自定义Behavior</h2><p>前面已经说到，今天主要介绍四个方法，这里我们把它分为两组。</p>
<p>第一组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 决定child 依赖于把一个 dependency</span><br><span class="line">boolean	layoutDependsOn(CoordinatorLayout parent, V child, View dependency)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当 dependency View 改变的时候 child 要做出怎样的响应</span><br><span class="line">boolean	onDependentViewChanged(CoordinatorLayout parent, V child, View dependency)</span><br></pre></td></tr></table></figure>


<p>第二组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当CoordinatorLayout的直接或者非直接子View开始嵌套滑动的时候，会调用这个方法</span><br><span class="line">boolean	onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当嵌套滑动的时候，target 尝试滑动或者正在滑动会调用这个方法</span><br><span class="line">onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)</span><br></pre></td></tr></table></figure>


<h3 id="首先我们先看第一组是怎样实现的？"><a href="#首先我们先看第一组是怎样实现的？" class="headerlink" title="首先我们先看第一组是怎样实现的？"></a>首先我们先看第一组是怎样实现的？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知乎效果底部behavior 依赖于 AppBarLayout</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xujun  on 2016/11/30.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> gdutxiaoxu@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterBehaviorDependAppBar</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span>&lt;<span class="title">View</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;xujun&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooterBehaviorDependAppBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当 dependency instanceof AppBarLayout 返回TRUE，将会调用onDependentViewChanged（）方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>   dependency <span class="keyword">instanceof</span> AppBarLayout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据dependency top值的变化改变 child 的 translationY</span></span><br><span class="line">        <span class="keyword">float</span> translationY = Math.abs(dependency.getTop());</span><br><span class="line">        child.setTranslationY(translationY);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onDependentViewChanged: &quot;</span> + translationY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>思路分析</em></p>
<p>这里我们要分清两个概念，child  和  dependency ，child 是我们要改变的坐标的view，而 dependency 是child 的 附属 ，即child 会随着 dependency 坐标的改变而改变。</p>
<p>比如上面的例子：当我们把 app:layout_behavior=”com.xujun.contralayout.behavior.FooterBehaviorDependAppBar” 设置给 RadioGroup 的时候，这时候 child 就是 RadioGroup ，而 dependency 就是 APPBarLayout ，因为我们在 layoutDependsOn 方法里面 ，返回 dependency instanceof AppBarLayout ，即当 dependency 是 AppBarLayout 或者 AppBarLayout的子类的时候返回TRUE。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当 dependency instanceof AppBarLayout 返回TRUE，将会调用onDependentViewChanged（）方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        return   dependency instanceof AppBarLayout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而之所以 RadioGroup 在向上滑动的时候会隐藏，向下滑动的时候会显示，是因为我们在 onDependentViewChanged 方法的时候 动态地根据 dependency 的 top 值改变 RadioGroup 的 translationY 值，核心 代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">    &#x2F;&#x2F;根据dependency top值的变化改变 child 的 translationY</span><br><span class="line">    float translationY &#x3D; Math.abs(dependency.getTop());</span><br><span class="line">    child.setTranslationY(translationY);</span><br><span class="line">    Log.i(TAG, &quot;onDependentViewChanged: &quot; + translationY);</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到此第一种思路分析为止</p>
<h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><p>主要是根据 onStartNestedScroll（） 和 onNestedPreScroll()方法 来实现的，</p>
<ul>
<li>当我们开始滑动的时候，我们判断是否是垂直滑动，如果是返回TRUE，否则返回 FALSE，返回TRUE，会接着调用onNestedPreScroll（）等一系列方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.判断滑动的方向 我们需要垂直滑动</span><br><span class="line">@Override</span><br><span class="line">public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child,</span><br><span class="line">                                   View directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">    return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 onNestedPreScroll（） 方法里面，我们根据我们的逻辑来决定是否显示 target ， 在这里我们是向上上滑动的时候，如果我们滑动的距离超过 target 的高度 并且 当前是可见的状态下，我们执行动画，隐藏 target，当我们向下滑动的时候，并且 View 是不可见的情况下，我们执行动画 ，显示target</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;2.根据滑动的距离显示和隐藏footer view</span><br><span class="line">  @Override</span><br><span class="line">  public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child,</span><br><span class="line">                                View target, int dx, int dy, int[] consumed) &#123;</span><br><span class="line">      if (dy &gt; 0 &amp;&amp; sinceDirectionChange &lt; 0 || dy &lt; 0 &amp;&amp; sinceDirectionChange &gt; 0) &#123;</span><br><span class="line">          child.animate().cancel();</span><br><span class="line">          sinceDirectionChange &#x3D; 0;</span><br><span class="line">      &#125;</span><br><span class="line">      sinceDirectionChange +&#x3D; dy;</span><br><span class="line">      int visibility &#x3D; child.getVisibility();</span><br><span class="line">      if (sinceDirectionChange &gt; child.getHeight() &amp;&amp; visibility &#x3D;&#x3D; View.VISIBLE) &#123;</span><br><span class="line">          hide(child);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          if (sinceDirectionChange &lt; 0 &amp;&amp; (visibility &#x3D;&#x3D; View.GONE || visibility &#x3D;&#x3D; View</span><br><span class="line">                  .INVISIBLE)) &#123;</span><br><span class="line">              show(child);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p> 全部代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知乎效果底部 behavior</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xujun  on 2016/11/30.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> gdutxiaoxu@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterBehavior</span> <span class="keyword">extends</span> <span class="title">CoordinatorLayout</span>.<span class="title">Behavior</span>&lt;<span class="title">View</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator INTERPOLATOR = <span class="keyword">new</span> FastOutSlowInInterpolator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sinceDirectionChange;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooterBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.判断滑动的方向 我们需要垂直滑动</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据滑动的距离显示和隐藏footer view</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(CoordinatorLayout coordinatorLayout, View child,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dy &gt; <span class="number">0</span> &amp;&amp; sinceDirectionChange &lt; <span class="number">0</span> || dy &lt; <span class="number">0</span> &amp;&amp; sinceDirectionChange &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            child.animate().cancel();</span><br><span class="line">            sinceDirectionChange = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sinceDirectionChange += dy;</span><br><span class="line">        <span class="keyword">int</span> visibility = child.getVisibility();</span><br><span class="line">        <span class="keyword">if</span> (sinceDirectionChange &gt; child.getHeight() &amp;&amp; visibility == View.VISIBLE) &#123;</span><br><span class="line">            hide(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sinceDirectionChange &lt; <span class="number">0</span> &amp;&amp; (visibility == View.GONE || visibility == View</span><br><span class="line">                    .INVISIBLE)) &#123;</span><br><span class="line">                show(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">        ViewPropertyAnimator animator = view.animate().translationY(view.getHeight()).</span><br><span class="line">                setInterpolator(INTERPOLATOR).setDuration(<span class="number">200</span>);</span><br><span class="line">        animator.setListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                view.setVisibility(View.GONE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                show(view);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">        ViewPropertyAnimator animator = view.animate().translationY(<span class="number">0</span>).</span><br><span class="line">                setInterpolator(INTERPOLATOR).</span><br><span class="line">                setDuration(<span class="number">200</span>);</span><br><span class="line">        animator.setListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                view.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                hide(view);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="两种实现方法的对比和总结"><a href="#两种实现方法的对比和总结" class="headerlink" title="两种实现方法的对比和总结"></a>两种实现方法的对比和总结</h2><ul>
<li><p>我们知道第一种方法我们主要是重写layoutDependsOn 和 onDependentViewChanged 这两个方法，这个方法在 layoutDependsOn 判断 dependency 是否是 APpBarLayout 的实现类，所以 会导致 child 依赖于 AppBarLayout，灵活性不是太强</p>
</li>
<li><p>而第二种方法，我们主要是重写 onStartNestedScroll 和 onNestedPreScroll 这两个方法，判断是否是垂直滑动，是的话就进行处理，灵活性大大增强，推荐使用这一种方法</p>
</li>
<li><p>需要注意的是不管是第一种方法，还是第二种方法，我们都需要重写带两个构造方法的函数，因为底层机制会采用反射的形式获得该对象</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FooterBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义-Behavior-实现-FloatingActionButton-的显示与隐藏"><a href="#自定义-Behavior-实现-FloatingActionButton-的显示与隐藏" class="headerlink" title="自定义 Behavior 实现 FloatingActionButton 的显示与隐藏"></a>自定义 Behavior 实现 FloatingActionButton 的显示与隐藏</h2><p><strong>效果图如下</strong></p>
<p>缩放隐藏的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-455f05edf132a3d9.jpg?imageMogr2/auto-orient/strip"></p>
<p>向上向下隐藏的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2050203-f50b9c3d22a393f8.jpg?imageMogr2/auto-orient/strip"></p>
<h3 id="布局代码"><a href="#布局代码" class="headerlink" title="布局代码"></a>布局代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;activity_floating_action_button&quot;</span><br><span class="line">    xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    tools:context&#x3D;&quot;com.xujun.contralayout.UI.FloatingActionButtonActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;index_app_bar&quot;</span><br><span class="line">        theme&#x3D;&quot;@style&#x2F;AppTheme.AppBarOverlay&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;?attr&#x2F;actionBarSize&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;colorPrimary&quot;</span><br><span class="line">            app:layout_scrollFlags&#x3D;&quot;scroll|enterAlways&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;search&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;24dp&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;24dp&quot;</span><br><span class="line">                android:layout_centerVertical&#x3D;&quot;true&quot;</span><br><span class="line">                android:layout_marginLeft&#x3D;&quot;10dp&quot;</span><br><span class="line">                android:src&#x3D;&quot;@drawable&#x2F;search&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_centerVertical&#x3D;&quot;true&quot;</span><br><span class="line">                android:layout_marginLeft&#x3D;&quot;10dp&quot;</span><br><span class="line">                android:layout_toRightOf&#x3D;&quot;@id&#x2F;search&quot;</span><br><span class="line">                android:text&#x3D;&quot;搜索话题、问题或人&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;recyclerView&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">        app:layout_behavior&#x3D;&quot;@string&#x2F;appbar_scrolling_view_behavior&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;android.support.v7.widget.RecyclerView&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;bottom|right|end&quot;</span><br><span class="line">        android:layout_marginBottom&#x3D;&quot;40dp&quot;</span><br><span class="line">        android:layout_marginRight&#x3D;&quot;25dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@android:color&#x2F;holo_green_light&quot;</span><br><span class="line">        android:src&#x3D;&quot;@drawable&#x2F;add&quot;</span><br><span class="line">        app:layout_behavior&#x3D;&quot;@string&#x2F;behavior_my_fab_scale&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure>


<p>如果想使用不同的效果，只需要给 FloatingActionButton 制定不同的 bevaior 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app:layout_behavior&#x3D;&quot;com.xujun.contralayout.behavior.MyFabBehavior&quot;</span><br></pre></td></tr></table></figure>



<h3 id="自定义behavior-代码"><a href="#自定义behavior-代码" class="headerlink" title="自定义behavior 代码"></a>自定义behavior 代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  FloatingActionButton behavior 向上向下隐藏的</span><br><span class="line"> * @author xujun  on 2016&#x2F;12&#x2F;1.</span><br><span class="line"> * @email gdutxiaoxu@163.com</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class MyFabBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final Interpolator INTERPOLATOR &#x3D; new FastOutSlowInInterpolator();</span><br><span class="line"></span><br><span class="line">    private float viewY;&#x2F;&#x2F;控件距离coordinatorLayout底部距离</span><br><span class="line">    private boolean isAnimate;&#x2F;&#x2F;动画是否在进行</span><br><span class="line"></span><br><span class="line">    public MyFabBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在嵌套滑动开始前回调</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line"></span><br><span class="line">        if(child.getVisibility() &#x3D;&#x3D; View.VISIBLE&amp;&amp;viewY&#x3D;&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;获取控件距离父布局（coordinatorLayout）底部距离</span><br><span class="line">            viewY&#x3D;coordinatorLayout.getHeight()-child.getY();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0;&#x2F;&#x2F;判断是否竖直滚动</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在嵌套滑动进行时，对象消费滚动距离前回调</span><br><span class="line">    @Override</span><br><span class="line">    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123;</span><br><span class="line">        &#x2F;&#x2F;dy大于0是向上滚动 小于0是向下滚动</span><br><span class="line"></span><br><span class="line">        if (dy &gt;&#x3D;0&amp;&amp;!isAnimate&amp;&amp;child.getVisibility()&#x3D;&#x3D;View.VISIBLE) &#123;</span><br><span class="line">            hide(child);</span><br><span class="line">        &#125; else if (dy &lt;0&amp;&amp;!isAnimate&amp;&amp;child.getVisibility()&#x3D;&#x3D;View.GONE) &#123;</span><br><span class="line">            show(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;隐藏时的动画</span><br><span class="line">    private void hide(final View view) &#123;</span><br><span class="line">        ViewPropertyAnimator animator &#x3D; view.animate().translationY(viewY).setInterpolator(INTERPOLATOR).setDuration(200);</span><br><span class="line"></span><br><span class="line">        animator.setListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animator) &#123;</span><br><span class="line">                isAnimate&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animator) &#123;</span><br><span class="line">                view.setVisibility(View.GONE);</span><br><span class="line">                isAnimate&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animator) &#123;</span><br><span class="line">                show(view);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animator) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示时的动画</span><br><span class="line">    private void show(final View view) &#123;</span><br><span class="line">        ViewPropertyAnimator animator &#x3D; view.animate().translationY(0).setInterpolator(INTERPOLATOR).setDuration(200);</span><br><span class="line">        animator.setListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animator) &#123;</span><br><span class="line">                view.setVisibility(View.VISIBLE);</span><br><span class="line">                isAnimate&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animator) &#123;</span><br><span class="line">                isAnimate&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animator) &#123;</span><br><span class="line">                hide(view);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animator) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;下拉时显示FAB，上拉隐藏，留出更多位置给用户。&lt;&#x2F;p&gt;</span><br><span class="line"> * Created on 2016&#x2F;12&#x2F;1.</span><br><span class="line"> *</span><br><span class="line"> * @author xujun</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ScaleDownShowBehavior extends FloatingActionButton.Behavior &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 退出动画是否正在执行。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean isAnimatingOut &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private OnStateChangedListener mOnStateChangedListener;</span><br><span class="line"></span><br><span class="line">    public ScaleDownShowBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">        return nestedScrollAxes &#x3D;&#x3D; ViewCompat.SCROLL_AXIS_VERTICAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123;</span><br><span class="line">        if ((dyConsumed &gt; 0 || dyUnconsumed &gt; 0) &amp;&amp; !isAnimatingOut &amp;&amp; child.getVisibility() &#x3D;&#x3D; View.VISIBLE) &#123;&#x2F;&#x2F;往下滑</span><br><span class="line">            AnimatorUtil.scaleHide(child, viewPropertyAnimatorListener);</span><br><span class="line">            if (mOnStateChangedListener !&#x3D; null) &#123;</span><br><span class="line">                mOnStateChangedListener.onChanged(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ((dyConsumed &lt; 0 || dyUnconsumed &lt; 0) &amp;&amp; child.getVisibility() !&#x3D; View.VISIBLE) &#123;</span><br><span class="line">            AnimatorUtil.scaleShow(child, null);</span><br><span class="line">            if (mOnStateChangedListener !&#x3D; null) &#123;</span><br><span class="line">                mOnStateChangedListener.onChanged(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnStateChangedListener(OnStateChangedListener mOnStateChangedListener) &#123;</span><br><span class="line">        this.mOnStateChangedListener &#x3D; mOnStateChangedListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 外部监听显示和隐藏。</span><br><span class="line">    public interface OnStateChangedListener &#123;</span><br><span class="line">        void onChanged(boolean isShow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;V extends View&gt; ScaleDownShowBehavior from(V view) &#123;</span><br><span class="line">        ViewGroup.LayoutParams params &#x3D; view.getLayoutParams();</span><br><span class="line">        if (!(params instanceof CoordinatorLayout.LayoutParams)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;The view is not a child of CoordinatorLayout&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        CoordinatorLayout.Behavior behavior &#x3D; ((CoordinatorLayout.LayoutParams) params).getBehavior();</span><br><span class="line">        if (!(behavior instanceof ScaleDownShowBehavior)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;The view is not associated with ScaleDownShowBehavior&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return (ScaleDownShowBehavior) behavior;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ViewPropertyAnimatorListener viewPropertyAnimatorListener &#x3D; new ViewPropertyAnimatorListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationStart(View view) &#123;</span><br><span class="line">            isAnimatingOut &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationEnd(View view) &#123;</span><br><span class="line">            isAnimatingOut &#x3D; false;</span><br><span class="line">            view.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationCancel(View arg0) &#123;</span><br><span class="line">            isAnimatingOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>思路这里就不详细展开了，因为前面在讲解 仿知乎效果的时候已经讲过了，大概就是根据不同的滑动行为执行不同的动画 而已</p>
<hr>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul>
<li>通过这篇博客，熟悉 CoordinatorLayout 的 各种用法，同时也初步理解了自定义Behavior的思路</li>
<li>同时复习了动画的相关知识</li>
<li>如果你觉得效果还不错，欢迎到我的github上面star，<a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git">github地址</a></li>
</ul>
<p><strong><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">文章首发地址CSDN：</a><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">http://blog.csdn.net/gdutxiaoxu/article/details/53453958</a></strong></p>
<p><strong><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git">源码下载地址：</a><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git">https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>使用CoordinatorLayout打造各种炫酷的效果</title>
    <url>/2016/12/08/%E4%BD%BF%E7%94%A8CoordinatorLayout%E6%89%93%E9%80%A0%E5%90%84%E7%A7%8D%E7%82%AB%E9%85%B7%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71553411">NestedScrolling 机制深入解析</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71616547"> 一步步带你读懂 CoordinatorLayout 源码</a></p>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71732642">自定义 Behavior -仿新浪微博发现页的实现</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/52939127">ViewPager，ScrollView 嵌套ViewPager滑动冲突解决</a></p>
<p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/88383135">自定义 behavior - 完美仿 QQ 浏览器首页，美团商家详情页</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6feca452620f4c3231c99bc90ca6f88b.png"></p>
<hr>
<h2 id="CoordinatorLayout简介"><a href="#CoordinatorLayout简介" class="headerlink" title="CoordinatorLayout简介"></a>CoordinatorLayout简介</h2><p>CoordinatorLayout是在 Google IO/15 大会发布的，遵循Material 风格，包含在 support Library中，结合AppbarLayout, CollapsingToolbarLayout等 可 产生各种炫酷的效果</p>
<h2 id="CoordinatorLayout简介通常用来-干什么"><a href="#CoordinatorLayout简介通常用来-干什么" class="headerlink" title="CoordinatorLayout简介通常用来 干什么"></a>CoordinatorLayout简介通常用来 干什么</h2><p><a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html">Google官方地址</a></p>
<blockquote>
<p>CoordinatorLayout is intended for two primary use cases:</p>
</blockquote>
<blockquote>
<p>As a top-level application decor or chrome layout</p>
</blockquote>
<blockquote>
<p>As a container for a specific interaction with one or more child views</p>
</blockquote>
<p>简单来说就是</p>
<ul>
<li>作为最上层的View</li>
<li>作为一个 容器与一个或者多个子View进行交互</li>
</ul>
<h2 id="下面我们一起先来看一下我们实现的效果图"><a href="#下面我们一起先来看一下我们实现的效果图" class="headerlink" title="下面我们一起先来看一下我们实现的效果图"></a>下面我们一起先来看一下我们实现的效果图</h2><p>动态图</p>
<h3 id="结合ToolBar"><a href="#结合ToolBar" class="headerlink" title="结合ToolBar"></a>结合ToolBar</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtYzM1ZjA4ZGFiODQ3NjE3NC5naWY"></p>
<h3 id="结合ViewPager"><a href="#结合ViewPager" class="headerlink" title="结合ViewPager"></a>结合ViewPager</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtZTlhYjFkNzY1YzkyZjFhYi5qcGc" alt="ViewPager"></p>
<h3 id="结合ViewPager的视觉特差"><a href="#结合ViewPager的视觉特差" class="headerlink" title="结合ViewPager的视觉特差"></a>结合ViewPager的视觉特差</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtOWM2ZGVkYTAyZTY1NmYxYS5naWY"></p>
<hr>
<h2 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h2><p>它是继承与LinearLayout的，默认 的 方向 是Vertical</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtNDhlYzI5ODdlNzg5NjcxMi5qcGc"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int SCROLL_FLAG_ENTER_ALWAYS</td>
<td>When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling.</td>
</tr>
<tr>
<td>int SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED</td>
<td>An additional flag for ‘enterAlways’ which modifies the returning view to only initially scroll back to it’s collapsed height.</td>
</tr>
<tr>
<td>int SCROLL_FLAG_EXIT_UNTIL_COLLAPSED</td>
<td>When exiting (scrolling off screen) the view will be scrolled until it is ‘collapsed’.</td>
</tr>
<tr>
<td>int SCROLL_FLAG_SCROLL</td>
<td>The view will be scroll in direct relation to scroll events.</td>
</tr>
<tr>
<td>int SCROLL_FLAG_SNAP</td>
<td>Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it’s closest edge.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int SCROLL_FLAG_ENTER_ALWAYS</td>
<td>W((entering) / (scrolling on screen))下拉的时候，这个View也会跟着滑出。</td>
</tr>
<tr>
<td>int SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED</td>
<td>另一种enterAlways，但是只显示折叠后的高度。</td>
</tr>
<tr>
<td>int SCROLL_FLAG_EXIT_UNTIL_COLLAPSED</td>
<td>((exiting) / (scrolling off screen))上拉的时候，这个View会跟着滑动直到折叠。</td>
</tr>
<tr>
<td>int SCROLL_FLAG_SCROLL</td>
<td>这个View将会响应Scroll事件</td>
</tr>
<tr>
<td>int SCROLL_FLAG_SNAP</td>
<td>在Scroll滑动事件结束以前 ，如果这个View部分可见，那么这个View会停在最接近当前View的位置</td>
</tr>
</tbody></table>
<p>我们可以通过两种 方法设置这个Flag</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setScrollFlags(int) </span><br></pre></td></tr></table></figure>

<ul>
<li>方法二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app:layout_scrollFlags=<span class="string">&quot;scroll|enterAlways&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>AppBarLayout必须作为CoordinatorLayout的直接子View，否则它的大部分功能将不会生效，如layout_scrollFlags等。</p>
<h2 id="首先我们先来看一下我们-效果图一是怎样实现的"><a href="#首先我们先来看一下我们-效果图一是怎样实现的" class="headerlink" title="首先我们先来看一下我们 效果图一是怎样实现的"></a>首先我们先来看一下我们 效果图一是怎样实现的</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    android:id=<span class="string">&quot;@+id/main_content&quot;</span></span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/appbar&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:theme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.v7.widget.Toolbar</span><br><span class="line">            android:id=<span class="string">&quot;@+id/toolbar&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">            app:layout_scrollFlags=<span class="string">&quot;scroll|enterAlways&quot;</span></span><br><span class="line">            app:popupTheme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">       .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/recyclerView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        app:layout_behavior=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:id=<span class="string">&quot;@+id/fab&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;end|bottom&quot;</span></span><br><span class="line">        android:layout_margin=<span class="string">&quot;15dp&quot;</span></span><br><span class="line">        android:src=<span class="string">&quot;@drawable/add_2&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="思路-分析"><a href="#思路-分析" class="headerlink" title="思路 分析"></a>思路 分析</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtOWU2Nzc1ZjJkNThjMGE2Ni5qcGc"></p>
<p>从图中我们可以知道 layout_scrollFlags=”scroll|enterAlways，<br>前面已经说到layout_scrollFlags=scroll的时候，这个View会 跟着 滚动 事件响应，<br>layout_scrollFlags=“enterAlways”的时候 这个View会响应下拉事件<br>所以呈现出来的结果应该是我们在上拉的时候toolBar 会隐藏，下拉的时候toolBar会出来</p>
<p>那如果当我们的toolBar 等于  app:layout_scrollFlags=”scroll|snap”的时候 ，<br>layout_scrollFlags=scroll的时候，这个View会 跟着 滚动 事件响应，<br>layout_scrollFlags=“snap”的时候 在Scroll滑动事件结束以前 ，如果这个View部分可见，那么这个View会停在最接近当前View的位置。<br><em>综上呈现的效果如下</em>，代码见ToolBarSampleSnar的布局文件</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtNDhlMjAzMjU0ZDVmYmRiZC5naWY"></p>
<h2 id="结合ViewPager-1"><a href="#结合ViewPager-1" class="headerlink" title="结合ViewPager"></a>结合ViewPager</h2><h3 id="布局代码如下"><a href="#布局代码如下" class="headerlink" title="布局代码如下"></a>布局代码如下</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    android:id=<span class="string">&quot;@+id/main_content&quot;</span></span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;250dp&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;ImageView android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                   android:layout_height=<span class="string">&quot;200dp&quot;</span></span><br><span class="line">                   android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">                   android:scaleType=<span class="string">&quot;fitXY&quot;</span></span><br><span class="line">                   android:src=<span class="string">&quot;@drawable/tangyan&quot;</span></span><br><span class="line">                   app:layout_scrollFlags=<span class="string">&quot;scroll|enterAlways&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.TabLayout</span><br><span class="line">            android:id=<span class="string">&quot;@+id/tabs&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">            app:tabIndicatorColor=<span class="string">&quot;@color/colorAccent&quot;</span></span><br><span class="line">            app:tabIndicatorHeight=<span class="string">&quot;4dp&quot;</span></span><br><span class="line">            app:tabSelectedTextColor=<span class="string">&quot;#000&quot;</span></span><br><span class="line">            app:tabTextColor=<span class="string">&quot;#fff&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line"></span><br><span class="line">        android:id=<span class="string">&quot;@+id/viewpager&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        app:layout_behavior=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:id=<span class="string">&quot;@+id/fab&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;end|bottom&quot;</span></span><br><span class="line">        android:layout_margin=<span class="string">&quot;15dp&quot;</span></span><br><span class="line">        android:src=<span class="string">&quot;@drawable/add_2&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtNDFjY2JlNDQ5ZWY3MjA1MS5qcGc"></p>
<p>其实相对于前 一个例子，只是把 摆放RecyclerView 的位置替换成ViewPager而已，为了有页面导航器的效果，再使用 TabLayout而已，而TabLayout 在我们滑动的时候最终会停靠在 最顶部，是因为我们没有设置其layout_scrollFlags，即TabLayout是静态的</p>
<p>运行以后，即可看到以下的结果</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtZTlhYjFkNzY1YzkyZjFhYi5qcGc" alt="ViewPager"></p>
<h3 id="下面我们一起来看一下-TabLayout是怎样结合ViewPager直线-导航器的效果的"><a href="#下面我们一起来看一下-TabLayout是怎样结合ViewPager直线-导航器的效果的" class="headerlink" title="下面我们一起来看一下 TabLayout是怎样结合ViewPager直线 导航器的效果的"></a>下面我们一起来看一下 TabLayout是怎样结合ViewPager直线 导航器的效果的</h3><p>代码注释 里面已经解释地很清楚了 ，这里我就不解释了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPagerSample</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ViewPager mViewPager;</span><br><span class="line">    List&lt;Fragment&gt; mFragments;</span><br><span class="line"></span><br><span class="line">    String[] mTitles = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            <span class="string">&quot;主页&quot;</span>, <span class="string">&quot;微博&quot;</span>, <span class="string">&quot;相册&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> TabLayout mTabLayout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_third);</span><br><span class="line">        <span class="comment">// 第一步，初始化ViewPager和TabLayout</span></span><br><span class="line">        mViewPager = (ViewPager) findViewById(R.id.viewpager);</span><br><span class="line">        mTabLayout = (TabLayout) findViewById(R.id.tabs);</span><br><span class="line">        setupViewPager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViewPager</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mFragments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mTitles.length; i++) &#123;</span><br><span class="line">            ListFragment listFragment = ListFragment.newInstance(mTitles[i]);</span><br><span class="line">            mFragments.add(listFragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步：为ViewPager设置适配器</span></span><br><span class="line">        BaseFragmentAdapter adapter =</span><br><span class="line">                <span class="keyword">new</span> BaseFragmentAdapter(getSupportFragmentManager(), mFragments, mTitles);</span><br><span class="line"></span><br><span class="line">        mViewPager.setAdapter(adapter);</span><br><span class="line">        <span class="comment">//  第三步：将ViewPager与TableLayout 绑定在一起</span></span><br><span class="line">        mTabLayout.setupWithViewPager(mViewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们想更改Indicator的相关样式，我们可以在布局文件里面使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;android.support.design.widget.TabLayout</span><br><span class="line">    android:id=<span class="string">&quot;@+id/tabs&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">    app:tabIndicatorColor=<span class="string">&quot;@color/colorAccent&quot;</span></span><br><span class="line">    app:tabIndicatorHeight=<span class="string">&quot;4dp&quot;</span></span><br><span class="line">    app:tabSelectedTextColor=<span class="string">&quot;#000&quot;</span></span><br><span class="line">    app:tabTextColor=<span class="string">&quot;#fff&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果你不想使用Google 帮我们 封装好的控件的话，你也可以自己自定义一个控件，你可以参考我的这一篇博客<a href="http://blog.csdn.net/gdutxiaoxu/article/details/52081609">仿网易新闻的顶部导航指示器</a></strong></p>
<hr>
<p>在看例子结合ViewPager的视觉特差之前 ，我们需要先了解CollapsingToolbarLayout这个控件</p>
<h2 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a>CollapsingToolbarLayout</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtOWU0OTkzMTYxODUyOTBkMS5qcGc"></p>
<p>CollapsingToolbarLayout继承与FrameLayout，<a href="https://developer.android.com/reference/android/support/design/widget/CollapsingToolbarLayout.html">官网地址</a>,请自备梯子。</p>
<p>简单来说 ,CollapsingToolbarLayout是工具栏的包装器,它通常作为AppBarLayout的孩子。主要实现以下功能</p>
<ul>
<li>Collapsing title（可以折叠 的 标题 ）</li>
<li>Content scrim（内容装饰），当我们滑动的位置 到达一定阀值的时候，内容 装饰将会被显示或者隐藏</li>
<li>Status bar scrim（状态栏布）</li>
<li>Parallax scrolling children，滑动的时候孩子呈现视觉特差效果</li>
<li>Pinned position children，固定位置的 孩子</li>
</ul>
<p>下面我们一起来看一下几个常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>int COLLAPSE_MODE_OFF</td>
<td>The view will act as normal with no collapsing behavior.(这个 View将会 呈现正常的结果，不会表现出折叠效果）</td>
</tr>
<tr>
<td>int COLLAPSE_MODE_PARALLAX</td>
<td>The view will scroll in a parallax fashion. See setParallaxMultiplier(float) to change the multiplier used.（在滑动的时候这个View 会呈现 出 视觉特差效果 ）</td>
</tr>
<tr>
<td>int COLLAPSE_MODE_PIN</td>
<td>The view will pin in place until it reaches the bottom of the CollapsingToolbarLayout.（当这个View到达 CollapsingToolbarLayout的底部的时候，这个View 将会被放置，即代替整个CollapsingToolbarLayout）</td>
</tr>
</tbody></table>
<p>我们有两种方法可以设置这个常量,</p>
<p>方法一：在代码中使用这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setCollapseMode(int collapseMode)</span><br></pre></td></tr></table></figure>

<p>方法 二：在布局文件中使用自定义属性 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app:layout_collapseMode=<span class="string">&quot;pin&quot;</span></span><br></pre></td></tr></table></figure>

<p>到此 ，CollapsingToolbarLayout的一些重要属性已经讲解完毕，下面我们一起来看一下我们是怎样结合ViewPager实现视差效果的</p>
<hr>
<h2 id="结合ViewPager的视觉特差-1"><a href="#结合ViewPager的视觉特差-1" class="headerlink" title="结合ViewPager的视觉特差"></a>结合ViewPager的视觉特差</h2><h3 id="布局代码"><a href="#布局代码" class="headerlink" title="布局代码"></a>布局代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.design.widget.CoordinatorLayout</span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@android:color/background_light&quot;</span></span><br><span class="line">    android:fitsSystemWindows=<span class="string">&quot;true&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.AppBarLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/main.appbar&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;300dp&quot;</span></span><br><span class="line">        android:fitsSystemWindows=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:theme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.CollapsingToolbarLayout</span><br><span class="line">            android:id=<span class="string">&quot;@+id/main.collapsing&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;250dp&quot;</span></span><br><span class="line">            android:fitsSystemWindows=<span class="string">&quot;true&quot;</span></span><br><span class="line">            app:contentScrim=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">            app:expandedTitleMarginEnd=<span class="string">&quot;64dp&quot;</span></span><br><span class="line">            app:expandedTitleMarginStart=<span class="string">&quot;48dp&quot;</span></span><br><span class="line">            app:layout_scrollFlags=<span class="string">&quot;scroll|exitUntilCollapsed&quot;</span></span><br><span class="line">        &gt;</span><br><span class="line"></span><br><span class="line">            &lt;ImageView</span><br><span class="line">                android:id=<span class="string">&quot;@+id/main.backdrop&quot;</span></span><br><span class="line">                android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                android:fitsSystemWindows=<span class="string">&quot;true&quot;</span></span><br><span class="line">                android:scaleType=<span class="string">&quot;centerCrop&quot;</span></span><br><span class="line">                android:src=<span class="string">&quot;@drawable/tangyan&quot;</span></span><br><span class="line">                app:layout_collapseMode=<span class="string">&quot;parallax&quot;</span></span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;android.support.v7.widget.Toolbar</span><br><span class="line">                android:id=<span class="string">&quot;@+id/toolbar&quot;</span></span><br><span class="line">                android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">                android:layout_height=<span class="string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="line">                app:layout_collapseMode=<span class="string">&quot;pin&quot;</span></span><br><span class="line">                app:popupTheme=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span></span><br><span class="line">            /&gt;</span><br><span class="line">        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android.support.design.widget.TabLayout</span><br><span class="line">            android:id=<span class="string">&quot;@+id/tabs&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="line">            app:tabIndicatorColor=<span class="string">&quot;@color/colorAccent&quot;</span></span><br><span class="line">            app:tabIndicatorHeight=<span class="string">&quot;4dp&quot;</span></span><br><span class="line">            app:tabSelectedTextColor=<span class="string">&quot;#000&quot;</span></span><br><span class="line">            app:tabTextColor=<span class="string">&quot;#fff&quot;</span>/&gt;</span><br><span class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">            android:id=<span class="string">&quot;@+id/viewpager&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            app:layout_behavior=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.v4.view.ViewPager&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.FloatingActionButton</span><br><span class="line">        android:id=<span class="string">&quot;@+id/fab&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;end|bottom&quot;</span></span><br><span class="line">        android:layout_margin=<span class="string">&quot;15dp&quot;</span></span><br><span class="line">        android:src=<span class="string">&quot;@drawable/add_2&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.CoordinatorLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtOWM2ZGVkYTAyZTY1NmYxYS5naWY"></p>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtOWEyYzM3MGJkNDJmMzczZC5qcGc"></p>
<ul>
<li><p>结构图如图片所示，先说明CollapsingToolbarLayout的变化</p>
<p>CollapsingToolbarLayout里面 包含ImageView 和ToolBar，ImageView的app:layout_collapseMode=”parallax”，表示视差效果，ToolBar的 app:layout_collapseMode=”pin”，当这个TooBar到达 CollapsingToolbarLayout的底部的时候，会代替整个CollapsingToolbarLayout显示</p>
</li>
<li><p>接着说明TabLayout的变化</p>
<p>从前面的描述我们已经知道当 没有指定app:layout_scrollFlags的时候，最终TabLayout会静止，不会随着滑动的 时候消失不见</p>
</li>
</ul>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>如果我们仅仅 改变CollapsingToolbarLayout的app:layout_scrollFlags=”scroll|exitUntilCollapsed|snap”的时候，其它代码不变，运行以后，我们将可以看到如下效果图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzIwNTAyMDMtZjU5MzM0ZmRhYjZhMTE3NS5naWY"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客主要讲解了CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout的一些相关属性。</p>
<ul>
<li>对于AppBarLayout，我们主要 讲解了这个属性app:layout_scrollFlags，设置不同 的属性我们可以在滚动的时候显示不同 的效果</li>
<li>对于CollapsingToolbarLayout，我们主要讲解了app:layout_collapseMode这个属性，设置不同的值，我们可以让其子View呈现不同的 炫酷效果，如parallax和pin等</li>
</ul>
<p>CoordinatorLayout的相关用法还有很多，有兴趣 了解的请自行阅读: <a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html">官方文档地址</a></p>
<hr>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>CoordinatorLayout这个控件真的很强大，使用它可以实现各种炫酷的效果，简化了开发者的许多工作，有能力的话可以去研究一下源码 ，看是怎样实现的？</p>
<p>参考文章：<a href="http://www.jianshu.com/p/f418bf95db2d">android-[译]掌握CoordinatorLayout</a></p>
<p><strong><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git">源码下载地址：</a><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git">https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git</a></strong></p>
<h2 id="找到我"><a href="#找到我" class="headerlink" title="找到我"></a>找到我</h2><p>我是站在巨人的肩膀上成长起来的，同样，我也希望成为你们的巨人。觉得不错的话可以关注一下我的微信公众号程序员徐公，在此感谢各位大佬们。主要分享</p>
<p>1.Android 开发相关知识：包括 java，kotlin， Android 技术。<br>2.面试相关分享：包括常见的面试题目，大厂面试真题、面试经验套路分享。<br>3.算法相关学习笔记：比如怎么学习算法，leetcode 常见算法总结，跟大家一起学习算法。<br>4.时事点评：主要是关于互联网的，比如小米高管屌丝事件，拼多多女员工猝死事件等</p>
<p>希望我们可以成为朋友，成长路上的忠实伙伴！<br><img src="https://img-blog.csdnimg.cn/img_convert/6feca452620f4c3231c99bc90ca6f88b.png"></p>
]]></content>
  </entry>
</search>
