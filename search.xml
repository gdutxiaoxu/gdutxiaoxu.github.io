<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[自定义 Behavior -仿新浪微博发现页的实现]]></title>
      <url>%2F2017%2F05%2F12%2F%E8%87%AA%E5%AE%9A%E4%B9%89-Behavior-%E4%BB%BF%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%8F%91%E7%8E%B0%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[使用CoordinatorLayout打造各种炫酷的效果 自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示 NestedScrolling 机制深入解析 一步步带你读懂 CoordinatorLayout 源码 自定义 Behavior -仿新浪微博发现页的实现 效果图我们先来看一下新浪微博发现页的效果： 接下来我们在来看一下我们仿照新浪微博实现的效果 实现思路分析我们这里先定义两种状态，open 和 close 状态。 open 状态指 Tab+ViewPager 还没有滑动到顶部的时候，header 还 没有被完全移除屏幕的时候 close 状态指 Tab+ViewPager 滑动到顶部的时候，Header 被移除屏幕的时候 从效果图，我们可以看到 在 open 状态下，我们向上滑动 ViewPager 里面的 RecyclerView 的 时候，RecyclerView 并不会向上移动（RecyclerView 的滑动事件交给 外部的容器处理，被被全部消费掉了），而是整个布局（指 Header + Tab +ViewPager）会向上偏移 。当 Tab 滑动到顶部的时候，我们向上滑动 ViewPager 里面的 RecyclerView 的时候，RecyclerView 可以正常向上滑动，即此时外部容器没有拦截滑动事件。 同时我们可以看到在 open 状态的时候，我们是不支持下拉刷新的，这个比较容易实现，监听页面的状态，如果是 open 状态，我们设置 SwipeRefreshLayout setEnabled 为 false，这样不会 拦截事件，在页面 close 的时候，设置 SwipeRefreshLayout setEnabled 为 TRUE，这样就可以支持下拉刷新了。 基于上面的分析，我们这里可以把整个效果划分为两个部分，第一部分为 Header，第二部分为 Tab+ViewPager。下文统一把第一部分称为 Header，第二部分称为 Content 。 需要实现的效果为：在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView 的 滑动事件。 在上一篇博客 一步步带你读懂 CoordinatorLayout 源码 中，我们有提到在 CoordinatorLayout中，我们可以通过 给子 View 自定义 Behavior 来处理事件。它是一个容器，实现了 NestedScrollingParent 接口。它并不会直接处理事件，而是会尽可能地交给子 View 的 Behavior 进行处理。因此，为了减少依赖，我们把这两部分的关系定义为 Content 依赖于 Header。Header 移动的时候，Content 跟着 移动。所以，我们在处理滑动事件的时候，只需要处理好 Header 部分的 Behavior 就oK了，Content 部分的 Behavior 不需要处理滑动事件，只需依赖于 Header ，跟着做相应的移动即可。 Header 部分的实现Header 部分实现的两个关键点在于 在页面状态为 open 的时候，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView 的 滑动事件 在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。 第一个关键点的实现这里区分页面状态是 open 还是 close 状态是通过 Header 是否移除屏幕来区分的，即 child.getTranslationY() == getHeaderOffsetRange() 。 1234private boolean isClosed(View child) &#123; boolean isClosed = child.getTranslationY() == getHeaderOffsetRange(); return isClosed;&#125; 在NestedScrolling 机制深入解析博客中，我们对 NestedScrolling 机制做了如下的总结。 在 Action_Down 的时候，Scrolling child 会调用 startNestedScroll 方法，通过 childHelper 回调 Scrolling Parent 的 startNestedScroll 方法。 在 Action_move 的时候，Scrolling Child 要开始滑动的时候，会调用dispatchNestedPreScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否要先于 Child 进行 滑动，若需要的话，会调用 Parent 的 onNestedPreScroll 方法，协同 Child 一起进行滑动 当 ScrollingChild 滑动完成的时候，会调用 dispatchNestedScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否需要进行滑动，需要的话，会 调用 Parent 的 onNestedScroll 方法 在 Action_down,Action_move 的时候，会调用 Scrolling Child 的stopNestedScroll ，通过 ChildHelper 询问 Scrolling parent 的 stopNestedScroll 方法。 如果需要处理 Fling 动作，我们可以通过 VelocityTrackerCompat 获得相应的速度，并在 Action_up 的时候，调用 dispatchNestedPreFling 方法，通过 ChildHelper 询问 Parent 是否需要先于 child 进行 Fling 动作在 Child 处理完 Fling 动作时候，如果 Scrolling Parent 还需要处理 Fling 动作，我们可以调用 dispatchNestedFling 方法，通过 ChildHelper ，调用 Parent 的 onNestedFling 方法 而 RecyclerView 也是 Scrolling Child （实现了 NestedScrollingChild 接口），RecyclerView 在开始滑动的 时候会先调用 CoordinatorLayout 的 startNestedScroll 方法，而 CoordinatorLayout 会 调用子 View 的 Behavior 的 startNestedScroll 方法。并且只有 boolean startNestedScroll 返回 TRUE 的 时候，才会调用接下里 Behavior 中的 onNestedPreScroll 和 onNestedScroll 方法。 所以，我们在 WeiboHeaderPagerBehavior 的 onStartNestedScroll 方法可以这样写，可以确保 只拦截垂直方向上的滚动事件，且当前状态是打开的并且还可以继续向上收缩的时候还会拦截 12345678910111213@Overridepublic boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes=&quot; + nestedScrollAxes); &#125; boolean canScroll = canScroll(child, 0); //拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩 return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0 &amp;&amp; canScroll &amp;&amp; !isClosed(child);&#125; 拦截事件之后，我们需要在 RecyclerView 滑动之前消耗事件，并且移动 Header，让其向上偏移。 12345678910111213141516@Overridepublic void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); //dy&gt;0 scroll up;dy&lt;0,scroll down Log.i(TAG, &quot;onNestedPreScroll: dy=&quot; + dy); float halfOfDis = dy; // 不能滑动了，直接给 Header 设置 终值，防止出错 if (!canScroll(child, halfOfDis)) &#123; child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0); &#125; else &#123; child.setTranslationY(child.getTranslationY() - halfOfDis); &#125; //consumed all scroll behavior after we started Nested Scrolling consumed[1] = dy;&#125; 当然，我们也需要处理 Fling 事件，在页面没有完全关闭的 时候，消费所有 fling 事件。 123456@Overridepublic boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) &#123; // consumed the flinging behavior until Closed return !isClosed(child);&#125; 至于滑动到顶部的动画，我是通过 mOverScroller + FlingRunnable 来实现的 。完整代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290public class WeiboHeaderPagerBehavior extends ViewOffsetBehavior &#123; private static final String TAG = &quot;UcNewsHeaderPager&quot;; public static final int STATE_OPENED = 0; public static final int STATE_CLOSED = 1; public static final int DURATION_SHORT = 300; public static final int DURATION_LONG = 600; private int mCurState = STATE_OPENED; private OnPagerStateListener mPagerStateListener; private OverScroller mOverScroller; private WeakReference&lt;CoordinatorLayout&gt; mParent; private WeakReference&lt;View&gt; mChild; public void setPagerStateListener(OnPagerStateListener pagerStateListener) &#123; mPagerStateListener = pagerStateListener; &#125; public WeiboHeaderPagerBehavior() &#123; init(); &#125; public WeiboHeaderPagerBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private void init() &#123; mOverScroller = new OverScroller(BaseAPP.getAppContext()); &#125; @Override protected void layoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123; super.layoutChild(parent, child, layoutDirection); mParent = new WeakReference&lt;CoordinatorLayout&gt;(parent); mChild = new WeakReference&lt;View&gt;(child); &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes=&quot; + nestedScrollAxes); &#125; boolean canScroll = canScroll(child, 0); //拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩 return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0 &amp;&amp; canScroll &amp;&amp; !isClosed(child); &#125; @Override public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY) &#123; // consumed the flinging behavior until Closed boolean coumsed = !isClosed(child); Log.i(TAG, &quot;onNestedPreFling: coumsed=&quot; +coumsed); return coumsed; &#125; @Override public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY, boolean consumed) &#123; Log.i(TAG, &quot;onNestedFling: velocityY=&quot; +velocityY); return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed); &#125; private boolean isClosed(View child) &#123; boolean isClosed = child.getTranslationY() == getHeaderOffsetRange(); return isClosed; &#125; public boolean isClosed() &#123; return mCurState == STATE_CLOSED; &#125; private void changeState(int newState) &#123; if (mCurState != newState) &#123; mCurState = newState; if (mCurState == STATE_OPENED) &#123; if (mPagerStateListener != null) &#123; mPagerStateListener.onPagerOpened(); &#125; &#125; else &#123; if (mPagerStateListener != null) &#123; mPagerStateListener.onPagerClosed(); &#125; &#125; &#125; &#125; // 表示 Header TransLationY 的值是否达到我们指定的阀值， headerOffsetRange，到达了，返回 false， // 否则，返回 true。注意 TransLationY 是负数。 private boolean canScroll(View child, float pendingDy) &#123; int pendingTranslationY = (int) (child.getTranslationY() - pendingDy); int headerOffsetRange = getHeaderOffsetRange(); if (pendingTranslationY &gt;= headerOffsetRange &amp;&amp; pendingTranslationY &lt;= 0) &#123; return true; &#125; return false; &#125; @Override public boolean onInterceptTouchEvent(CoordinatorLayout parent, final View child, MotionEvent ev) &#123; boolean closed = isClosed(); Log.i(TAG, &quot;onInterceptTouchEvent: closed=&quot; + closed); if (ev.getAction() == MotionEvent.ACTION_UP &amp;&amp; !closed) &#123; handleActionUp(parent,child); &#125; return super.onInterceptTouchEvent(parent, child, ev); &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); //dy&gt;0 scroll up;dy&lt;0,scroll down Log.i(TAG, &quot;onNestedPreScroll: dy=&quot; + dy); float halfOfDis = dy; // 不能滑动了，直接给 Header 设置 终值，防止出错 if (!canScroll(child, halfOfDis)) &#123; child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0); &#125; else &#123; child.setTranslationY(child.getTranslationY() - halfOfDis); &#125; //consumed all scroll behavior after we started Nested Scrolling consumed[1] = dy; &#125; // 需要注意的是 Header 我们是通过 setTranslationY 来移出屏幕的，所以这个值是负数 private int getHeaderOffsetRange() &#123; return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen .weibo_header_offset); &#125; private void handleActionUp(CoordinatorLayout parent, final View child) &#123; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;handleActionUp: &quot;); &#125; if (mFlingRunnable != null) &#123; child.removeCallbacks(mFlingRunnable); mFlingRunnable = null; &#125; mFlingRunnable = new FlingRunnable(parent, child); if (child.getTranslationY() &lt; getHeaderOffsetRange() / 6.0f) &#123; mFlingRunnable.scrollToClosed(DURATION_SHORT); &#125; else &#123; mFlingRunnable.scrollToOpen(DURATION_SHORT); &#125; &#125; private void onFlingFinished(CoordinatorLayout coordinatorLayout, View layout) &#123; changeState(isClosed(layout) ? STATE_CLOSED : STATE_OPENED); &#125; public void openPager() &#123; openPager(DURATION_LONG); &#125; /** * @param duration open animation duration */ public void openPager(int duration) &#123; View child = mChild.get(); CoordinatorLayout parent = mParent.get(); if (isClosed() &amp;&amp; child != null) &#123; if (mFlingRunnable != null) &#123; child.removeCallbacks(mFlingRunnable); mFlingRunnable = null; &#125; mFlingRunnable = new FlingRunnable(parent, child); mFlingRunnable.scrollToOpen(duration); &#125; &#125; public void closePager() &#123; closePager(DURATION_LONG); &#125; /** * @param duration close animation duration */ public void closePager(int duration) &#123; View child = mChild.get(); CoordinatorLayout parent = mParent.get(); if (!isClosed()) &#123; if (mFlingRunnable != null) &#123; child.removeCallbacks(mFlingRunnable); mFlingRunnable = null; &#125; mFlingRunnable = new FlingRunnable(parent, child); mFlingRunnable.scrollToClosed(duration); &#125; &#125; private FlingRunnable mFlingRunnable; /** * For animation , Why not use &#123;@link android.view.ViewPropertyAnimator &#125; to play animation * is of the * other &#123;@link CoordinatorLayout.Behavior&#125; that depend on this could not receiving the * correct result of * &#123;@link View#getTranslationY()&#125; after animation finished for whatever reason that i don&apos;t know */ private class FlingRunnable implements Runnable &#123; private final CoordinatorLayout mParent; private final View mLayout; FlingRunnable(CoordinatorLayout parent, View layout) &#123; mParent = parent; mLayout = layout; &#125; public void scrollToClosed(int duration) &#123; float curTranslationY = ViewCompat.getTranslationY(mLayout); float dy = getHeaderOffsetRange() - curTranslationY; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;scrollToClosed:offest:&quot; + getHeaderOffsetRange()); Log.d(TAG, &quot;scrollToClosed: cur0:&quot; + curTranslationY + &quot;,end0:&quot; + dy); Log.d(TAG, &quot;scrollToClosed: cur:&quot; + Math.round(curTranslationY) + &quot;,end:&quot; + Math .round(dy)); Log.d(TAG, &quot;scrollToClosed: cur1:&quot; + (int) (curTranslationY) + &quot;,end:&quot; + (int) dy); &#125; mOverScroller.startScroll(0, Math.round(curTranslationY - 0.1f), 0, Math.round(dy + 0.1f), duration); start(); &#125; public void scrollToOpen(int duration) &#123; float curTranslationY = ViewCompat.getTranslationY(mLayout); mOverScroller.startScroll(0, (int) curTranslationY, 0, (int) -curTranslationY, duration); start(); &#125; private void start() &#123; if (mOverScroller.computeScrollOffset()) &#123; mFlingRunnable = new FlingRunnable(mParent, mLayout); ViewCompat.postOnAnimation(mLayout, mFlingRunnable); &#125; else &#123; onFlingFinished(mParent, mLayout); &#125; &#125; @Override public void run() &#123; if (mLayout != null &amp;&amp; mOverScroller != null) &#123; if (mOverScroller.computeScrollOffset()) &#123; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;run: &quot; + mOverScroller.getCurrY()); &#125; ViewCompat.setTranslationY(mLayout, mOverScroller.getCurrY()); ViewCompat.postOnAnimation(mLayout, this); &#125; else &#123; onFlingFinished(mParent, mLayout); &#125; &#125; &#125; &#125; /** * callback for HeaderPager &apos;s state */ public interface OnPagerStateListener &#123; /** * do callback when pager closed */ void onPagerClosed(); /** * do callback when pager opened */ void onPagerOpened(); &#125;&#125; 第二个关键点的实现在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。 在第一个关键点的实现上，我们是通过自定义 Behavior 来处理 ViewPager 里面 RecyclerView 的移动的，那我们要怎样监听整个 Header 的滑动了。 那就是重写 LinearLayout，将滑动事件交给 ScrollingParent（这里是CoordinatorLayout） 去处理，CoordinatorLayout 再交给子 View 的 behavior 去处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class NestedLinearLayout extends LinearLayout implements NestedScrollingChild &#123; private static final String TAG = &quot;NestedLinearLayout&quot;; private final int[] offset = new int[2]; private final int[] consumed = new int[2]; private NestedScrollingChildHelper mScrollingChildHelper; private int lastY; public NestedLinearLayout(Context context) &#123; this(context, null); &#125; public NestedLinearLayout(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NestedLinearLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initData(); &#125; private void initData() &#123; if (mScrollingChildHelper == null) &#123; mScrollingChildHelper = new NestedScrollingChildHelper(this); mScrollingChildHelper.setNestedScrollingEnabled(true); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: lastY = (int) event.getRawY(); // 当开始滑动的时候，告诉父view startNestedScroll(ViewCompat.SCROLL_AXIS_HORIZONTAL | ViewCompat.SCROLL_AXIS_VERTICAL); break; case MotionEvent.ACTION_MOVE: return true; &#125; return super.onInterceptTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_MOVE: Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE=&quot;); int y = (int) (event.getRawY()); int dy =lastY- y; lastY = y; Log.i(TAG, &quot;onTouchEvent: lastY=&quot; + lastY); Log.i(TAG, &quot;onTouchEvent: dy=&quot; + dy); // dy &lt; 0 下拉， dy&gt;0 赏花 if (dy &gt;0) &#123; // 上滑的时候才交给父类去处理 if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) // 如果找到了支持嵌套滚动的父类 &amp;&amp; dispatchNestedPreScroll(0, dy, consumed, offset)) &#123;// // 父类进行了一部分滚动 &#125; &#125;else&#123; if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) // 如果找到了支持嵌套滚动的父类 &amp;&amp; dispatchNestedScroll(0, 0, 0,dy, offset)) &#123;// // 父类进行了一部分滚动 &#125; &#125; break; &#125; return true; &#125; private NestedScrollingChildHelper getScrollingChildHelper() &#123; return mScrollingChildHelper; &#125; // 接口实现-------------------------------------------------- @Override public void setNestedScrollingEnabled(boolean enabled) &#123; getScrollingChildHelper().setNestedScrollingEnabled(enabled); &#125; @Override public boolean isNestedScrollingEnabled() &#123; return getScrollingChildHelper().isNestedScrollingEnabled(); &#125; @Override public boolean startNestedScroll(int axes) &#123; return getScrollingChildHelper().startNestedScroll(axes); &#125; @Override public void stopNestedScroll() &#123; getScrollingChildHelper().stopNestedScroll(); &#125; @Override public boolean hasNestedScrollingParent() &#123; return getScrollingChildHelper().hasNestedScrollingParent(); &#125; @Override public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) &#123; return getScrollingChildHelper().dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow); &#125; @Override public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow) &#123; return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow); &#125; @Override public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) &#123; return getScrollingChildHelper().dispatchNestedFling(velocityX, velocityY, consumed); &#125; @Override public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123; return getScrollingChildHelper().dispatchNestedPreFling(velocityX, velocityY); &#125;&#125; Content 部分的实现Content 部分的实现也主要有两个关键点 整体置于 Header 之下 Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。 第一个关键点的实现整体置于 Header 之下。这个我们可以参考 APPBarLayout 的 behavior，它是这样处理的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * Copy from Android design library * &lt;p/&gt; * Created by xujun */public abstract class HeaderScrollingViewBehavior extends ViewOffsetBehavior&lt;View&gt; &#123; private final Rect mTempRect1 = new Rect(); private final Rect mTempRect2 = new Rect(); private int mVerticalLayoutGap = 0; private int mOverlayTop; public HeaderScrollingViewBehavior() &#123; &#125; public HeaderScrollingViewBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final int childLpHeight = child.getLayoutParams().height; if (childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT || childLpHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; // If the menu&apos;s height is set to match_parent/wrap_content then measure it // with the maximum visible height final List&lt;View&gt; dependencies = parent.getDependencies(child); final View header = findFirstDependency(dependencies); if (header != null) &#123; if (ViewCompat.getFitsSystemWindows(header) &amp;&amp; !ViewCompat.getFitsSystemWindows(child)) &#123; // If the header is fitting system windows then we need to also, // otherwise we&apos;ll get CoL&apos;s compatible measuring ViewCompat.setFitsSystemWindows(child, true); if (ViewCompat.getFitsSystemWindows(child)) &#123; // If the set succeeded, trigger a new layout and return true child.requestLayout(); return true; &#125; &#125; if (ViewCompat.isLaidOut(header)) &#123; int availableHeight = View.MeasureSpec.getSize(parentHeightMeasureSpec); if (availableHeight == 0) &#123; // If the measure spec doesn&apos;t specify a size, use the current height availableHeight = parent.getHeight(); &#125; final int height = availableHeight - header.getMeasuredHeight() + getScrollRange(header); final int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height, childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT ? View.MeasureSpec.EXACTLY : View.MeasureSpec.AT_MOST); // Now measure the scrolling view with the correct height parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed); return true; &#125; &#125; &#125; return false; &#125; @Override protected void layoutChild(final CoordinatorLayout parent, final View child, final int layoutDirection) &#123; final List&lt;View&gt; dependencies = parent.getDependencies(child); final View header = findFirstDependency(dependencies); if (header != null) &#123; final CoordinatorLayout.LayoutParams lp = (CoordinatorLayout.LayoutParams) child.getLayoutParams(); final Rect available = mTempRect1; available.set(parent.getPaddingLeft() + lp.leftMargin, header.getBottom() + lp.topMargin, parent.getWidth() - parent.getPaddingRight() - lp.rightMargin, parent.getHeight() + header.getBottom() - parent.getPaddingBottom() - lp.bottomMargin); final Rect out = mTempRect2; GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(), child.getMeasuredHeight(), available, out, layoutDirection); final int overlap = getOverlapPixelsForOffset(header); child.layout(out.left, out.top - overlap, out.right, out.bottom - overlap); mVerticalLayoutGap = out.top - header.getBottom(); &#125; else &#123; // If we don&apos;t have a dependency, let super handle it super.layoutChild(parent, child, layoutDirection); mVerticalLayoutGap = 0; &#125; &#125; float getOverlapRatioForOffset(final View header) &#123; return 1f; &#125; final int getOverlapPixelsForOffset(final View header) &#123; return mOverlayTop == 0 ? 0 : MathUtils.constrain(Math.round(getOverlapRatioForOffset(header) * mOverlayTop), 0, mOverlayTop); &#125; private static int resolveGravity(int gravity) &#123; return gravity == Gravity.NO_GRAVITY ? GravityCompat.START | Gravity.TOP : gravity; &#125; protected abstract View findFirstDependency(List&lt;View&gt; views); protected int getScrollRange(View v) &#123; return v.getMeasuredHeight(); &#125; /** * The gap between the top of the scrolling view and the bottom of the header layout in pixels. */ final int getVerticalLayoutGap() &#123; return mVerticalLayoutGap; &#125; /** * Set the distance that this view should overlap any &#123;@link AppBarLayout&#125;. * * @param overlayTop the distance in px */ public final void setOverlayTop(int overlayTop) &#123; mOverlayTop = overlayTop; &#125; /** * Returns the distance that this view should overlap any &#123;@link AppBarLayout&#125;. */ public final int getOverlayTop() &#123; return mOverlayTop; &#125;&#125; 这个基类的代码还是很好理解的，因为之前就说过了，正常来说被依赖的 View 会优先于依赖它的 View 处理，所以需要依赖的 View 可以在 measure/layout 的时候，找到依赖的 View 并获取到它的测量/布局的信息，这里的处理就是依靠着这种关系来实现的. 我们的实现类，需要重写的除了抽象方法 findFirstDependency 外，还需要重写 getScrollRange，我们把 Header的 Id id_weibo_header 定义在 ids.xml 资源文件内，方便依赖的判断. 至于缩放的高度，根据 结果图 得知是 0，得出如下代码 1234567891011121314private int getFinalHeight() &#123; Resources resources = BaseAPP.getInstance().getResources(); return 0;&#125; @Override protected int getScrollRange(View v) &#123; if (isDependOn(v)) &#123; return Math.max(0, v.getMeasuredHeight() - getFinalHeight()); &#125; else &#123; return super.getScrollRange(v); &#125; &#125; 第二个关键点的实现：Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。 主要的逻辑就是 在 layoutDependsOn 方法里面，判断 dependcy 是不是 HeaderView ，是的话，返回TRUE，这样在 Header 位置发生变化的时候，会回调 onDependentViewChanged 方法，在该方法里面，做相应的偏移。TranslationY 是根据比例算出来的 translationY = (int) (-dependencyTranslationY / (getHeaderOffsetRange() 1.0f) getScrollRange(dependency)); 完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class WeiboContentBehavior extends HeaderScrollingViewBehavior &#123; private static final String TAG = &quot;WeiboContentBehavior&quot;; public WeiboContentBehavior() &#123; &#125; public WeiboContentBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return isDependOn(dependency); &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; if (BuildConfig.DEBUG) &#123; Log.d(TAG, &quot;onDependentViewChanged&quot;); &#125; offsetChildAsNeeded(parent, child, dependency); return false; &#125; private void offsetChildAsNeeded(CoordinatorLayout parent, View child, View dependency) &#123; float dependencyTranslationY = dependency.getTranslationY(); int translationY = (int) (-dependencyTranslationY / (getHeaderOffsetRange() * 1.0f) * getScrollRange(dependency)); Log.i(TAG, &quot;offsetChildAsNeeded: translationY=&quot; + translationY); child.setTranslationY(translationY); &#125; @Override protected View findFirstDependency(List&lt;View&gt; views) &#123; for (int i = 0, z = views.size(); i &lt; z; i++) &#123; View view = views.get(i); if (isDependOn(view)) return view; &#125; return null; &#125; @Override protected int getScrollRange(View v) &#123; if (isDependOn(v)) &#123; return Math.max(0, v.getMeasuredHeight() - getFinalHeight()); &#125; else &#123; return super.getScrollRange(v); &#125; &#125; private int getHeaderOffsetRange() &#123; return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen .weibo_header_offset); &#125; private int getFinalHeight() &#123; Resources resources = BaseAPP.getInstance().getResources(); return 0; &#125; private boolean isDependOn(View dependency) &#123; return dependency != null &amp;&amp; dependency.getId() == R.id.id_weibo_header; &#125;&#125; 题外话 NestedScrolling 机制，对比传统的事件分发机制真的很强大。这种仿新浪微博发现页效果， 如果用传统的事件分发机制来做，估计很难实现，处理起来会有一大堆坑。 看完了这种仿新浪微博发现页的效果，你是不是学到了什么?如果让你 模仿 仿 QQ 浏览器首页效果，你能实现话。 最后，特别感谢写这篇博客 自定义Behavior的艺术探索-仿UC浏览器主页 的开发者，没有这篇博客作为参考，这种效果我很大几率是实现 不了的。大家觉得效果还不错的话，顺手到 github 上面给我 star，谢谢。github 地址 参考文章： 自定义Behavior的艺术探索-仿UC浏览器主页 github 地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AsyncTask源码分析]]></title>
      <url>%2F2017%2F02%2F26%2FAsyncTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[前言IntentService使用及源码分析 HandlerThread源码分析 AsyncTask使用及封装实践 AsyncTask源码分析 上一篇博客，AsyncTask使用及封装实践 我们主要介绍了AsyncTask 的使用及封装实践，这一篇博客我们主要来讲解AsyncTask的源码 这篇博客主要讲解以下内容 AsyncTask的几个主要方法讲解 AsyncTask 的源码分析 AsyncTask怎样使用自定义的Executor AsyncTask的几个主要方法讲解讲解之前我们先来回顾一下AsyncTask的几个主要方法 Void onPreExecute() 在task 任务开始执行的时候调用，在doInBackground(Params… params)方法之前调用，在主线程中执行 Result doInBackground(Params… params) 主要用来执行耗时操作，在子线程中执行，Params为我们参数的类型。而Result这个泛型，是我们返回的类型（可以是Integer，Long，String等等类型，只要不是八种基本类型就OK），同时 Result 的类型将作为 onPostExecute(Result result)的参数。 Void onProgressUpdate(Progress… values) Runs on the UI thread after publishProgress(Progress…) is invoked. 当我们调用 publishProgress（）方法的时候，会调用 onProgressUpdate（）这个方法 Void onPostExecute(Result result)在doInBackground（）方法执行完毕之后，会调用这个方法，是在主线程中执行的。但如果我们手动调用了cancelled()方法，那么这个方法将不会被调用。 void onCancelled() 在Task execute(Params… params) Executes the task with the specified parameters.当我们调用这个方法的时候，会执行任务 executeOnExecutor(Executor exec, Params… params) 在指定的线程池里面执行Task 需要注意的是，Params，Progress，Result 并不是一种特定的类型，它其实是泛型，它支持除了八种基本类型之外的类型，跟普通的泛型一样。 AsyncTask 的源码分析执行流程 当我们调用 execute（）方法的时候，会紧接着调用我们的execeteOnExecutor（sDefaultExecutor, params）方法在这个方法里面，会首先判断执行的状态的合法性，如果是finish或者running，会抛出异常，这也就是为什么AsyncTak只能被调用执行一次。紧接着会调用onPreExecute()方法 123456789101112131415161718192021222324252627282930public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 接着会把当前的状态设置running状态，并把我们的params传递给我们的mWork。params=params； 那这个mWork是什么呢？ 123456789101112131415161718192021222324252627282930313233343536public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 我们先来分析一下mWorker; mWorker为AsyncTask的一个内部类，实现了Callable接口，在call方法里面会调用我们的doInBackground方法，这也就是为什么我们的doInBackground。方法是在子线程里面执行的，执行完doInBackground（）方法会把结构传递给我们的postResult（result）方法，在result方法，会调用handler发送消息，接着再handler的handleMessage里面处理，在handleMessage里面，又会调用我们的 finish()方法,finish()方法里面会判断任务是否取消，如果被取消，会调用onCancelled（），否则会调用onPostExecute（）方法。 1234567891011121314151617181920212223242526272829private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125;private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 接着我们来分析一下mFuture 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; postResultIfNotInvoked(get());get()表示获取mWorker的call的返回值，即Result。 然后看postResultIfNotInvoked方法。会判断是否已经将结果发送出去，即判断在mWork里面是否已经调用postResult(result)发送结果，没有的话调用再调用postResult(result)发送出去 123456private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; 还记得上面exec.execute()吗？exec为executeOnExecutor(sDefaultExecutor,params)中的sDefaultExecutor 下面看这个sDefaultExecutor12345678910111213141516171819202122232425private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 可以看到sDefaultExecutor其实为SerialExecutor的一个实例，其内部维持一个任务队列；直接看其execute（Runnable runnable）方法，将runnable放入mTasks队尾；判断当前mActive是否为空，为空则调用scheduleNext方法 scheduleNext方法里面，则直接取出任务队列中的队首任务，如果不为null则传入THREAD_POOL_EXECUTOR进行执行。 下面看THREAD_POOL_EXECUTOR为何方神圣： 123Public static final Executor THREAD_POOL_EXECUTOR =new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 可以看到就是一个自己设置参数的线程池，参数为： 1234567891011121314private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); 回顾一下sDefaultExecutor，真正在execute()中调用的为sDefaultExecutor.execute： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 可以看到，如果此时有10个任务同时调用execute（s synchronized）方法，第一个任务入队，然后在mActive = mTasks.poll()) != null被取出，并且赋值给mActivte，然后交给线程池去执行。然后第二个任务入队，但是此时mActive并不为null，并不会执行scheduleNext();所以如果第一个任务比较慢，10个任务都会进入队列等待； 真正执行下一个任务的时机是，线程池执行完成第一个任务以后，调用Runnable中的finally代码块中的scheduleNext，所以虽然内部有一个线程池，其实调用的过程还是线性的。一个接着一个的执行，相当于单线程。 publicProgress（）方法的分析这也就是我们在Result doInBackground(Params… params)方法里面调用 publishProgress（）方法，会回调onProgressUpdate的原因 12345678910111213141516171819protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125;public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125;&#125; AsyncTask怎样使用自定义的Executor常用的集中线程池介绍 newCachedThreadPool() 缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中。能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。缓存型池子通常用于执行一些生存期很短的异步型任务 。 newFixedThreadPool() fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程 其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。和cacheThreadPool不同：fixedThreadPool池线程数固定，但是0秒IDLE（无IDLE）。这也就意味着创建的线程会一直存在。所以fixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。 newScheduledThreadPool() 调度型线程池。这个池子里的线程可以按schedule依次delay执行，或周期执行 。0秒IDLE（无IDLE）。 SingleThreadExecutor 单例线程，任意时间池中只能有一个线程 。用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。 使用12// 调用 executeOnExecutor，传入相应的线程池即可。mDownloadTask.executeOnExecutor(Executors.newFixedThreadPool(4)); IntentService使用及源码分析 HandlerThread源码分析 AsyncTask使用及封装实践 AsyncTask源码分析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AsyncTask 使用及封装实践]]></title>
      <url>%2F2017%2F02%2F26%2FAsyncTask-%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%B0%81%E8%A3%85%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言IntentService使用及源码分析 HandlerThread源码分析 AsyncTask使用及封装实践 AsyncTask源码分析 这篇博客主要是讲解AsyncTask的使用及封装实践，对于新手们还是有很大的参考意义的，尤其是AsyncTask的封装实践这部分。对于老鸟们，你们可以跳过了。同时需要声明的一点是，下面下载的例子只是进行简单的下载而已，并没有支持断点续传下载。需要的话请自行到github上面找相应的库，因为这并不是本篇博客的重点。 这篇博客主要讲解以下问题： AsyncTask的简单使用 AsyncTask的封装使用 AsyncTask使用注意事项 AsyncTask的使用例子简介AsyncTask ，异步任务。没错，就想字面上理解的那样。它允许我们在子线程执行耗时任务，在UI 线程更新操作（如更新进度条等）。简单来说，就是帮我们做好了子线程与UI 线程的通讯，我们只需要调用响应的方法实现即可。底层是用Handler消息机制实现的。 在Android开发中，我们经常需要下载各种东西，为了给用户较好的体验，我们经常需要显示下载进度。今天我们用以这个为例子，来教大家怎样使用AsyncTak。当然，github上面有很多开源库，实现断点下载，文件重命名等。不过这些不是本篇博客的重点。 效果图 AsyncTask的主要几个方法 Void onPreExecute() 在task 任务开始执行的时候调用，在doInBackground(Params… params)方法之前调用，在主线程中执行 Result doInBackground(Params… params) 主要用来执行耗时操作，在子线程中执行，Params为我们参数的类型。而Result这个泛型，是我们返回的类型（可以是Integer，Long，String等等类型，只要不是八种基本类型就OK），同时 Result 的类型将作为 onPostExecute(Result result)的参数。 Void onProgressUpdate(Progress… values) Runs on the UI thread after publishProgress(Progress…) is invoked. 当我们调用 publishProgress（）方法的时候，会调用 onProgressUpdate（）这个方法 Void onPostExecute(Result result)在doInBackground（）方法执行完毕之后，会调用这个方法，是在主线程中执行的。但如果我们手动调用了cancelled()方法，那么这个方法将不会被调用。 void onCancelled() 在Task 任务取消的时候会调用 execute(Params… params) Executes the task with the specified parameters.当我们调用这个方法的时候，会执行任务 executeOnExecutor(Executor exec, Params… params) 在指定的线程池里面执行Task 需要注意的是，Params，Progress，Result 并不是一种特定的类型，它其实是泛型，它支持除了八种基本类型之外的类型，跟普通的泛型一样。 AsyncTask使用的几个步骤这里我们以下载一个apk为例讲解 写一个类继承AsyncTask，并传入Params，Progress，Result 。三个参数的类型。 比如我们传入的 Params，Progress，Result 的参数的类型分别为 Void, FileInfo, FileInfo，那我们可以这样写。 123private class MyDownloadTask extends AsyncTask&lt;Void, FileInfo, FileInfo&gt;&#123; &#125; 那Void, FileInfo, FileInfo，这几个参数的类型在哪里体现出来呢？ 请看下面注释 1234567891011121314151617181920212223242526private class MyDownloadTask extends AsyncTask&lt;Void, FileInfo, FileInfo&gt; &#123; --- // 方法参数的类型为Void，跟我们传入的Void一致，返回类型为 FileInfo ，跟我们传入Result的类型FileInfo一致 @Override protected FileInfo doInBackground(Void... params) &#123; &#125; // 方法参数类型为FileInfo，跟我们传入Progress的类型FileInfo一致 @Override protected void onProgressUpdate(FileInfo... values) &#123; &#125; // 方法参数FileInfo，跟我们传入Result的类型FileInfo一致 @Override protected void onPostExecute(FileInfo fileInfo) &#123; &#125; &#125; 如果我们更新进度的话，需要重写 onProgressUpdate（）方法，并在doInBackground（）方法里面调用publishProgress（）方法 123456789101112protected FileInfo doInBackground(Void... params) &#123; publishProgress(fileInfo); &#125;@Overrideprotected void onProgressUpdate(FileInfo... values) &#123; super.onProgressUpdate(values); refreshProgress(values[0]);&#125; 当我们调用execute(Params… params) 或者 executeOnExecutor(Executor exec, Params… params) 方法的时候，Task将被防盗相应的 Executor 执行。 12MyDownloadTask myDownloadTask = new MyDownloadTask(mDownloadUrl, mDstPath);myDownloadTask.execute(); 完整的Task代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135private class MyDownloadTask extends AsyncTask&lt;Void, FileInfo, FileInfo&gt; &#123; String mDownLoadUrl; String mDstPath; public MyDownloadTask(String downloadUrl, String dstPath) &#123; this.mDownLoadUrl = downloadUrl; this.mDstPath = dstPath; &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); start(); &#125; @Override protected FileInfo doInBackground(Void... params) &#123; //url字符串，检查网址是否已http:// 开头 mDownLoadUrl = (mDownLoadUrl.startsWith(&quot;http://&quot;)) ? mDownLoadUrl : &quot;http://&quot; + mDownLoadUrl; Log.d(TAG, &quot;doInBackground: mDownLoadUrl=&quot; + mDownLoadUrl); Log.d(TAG, &quot;doInBackground: mDstPath=&quot; + mDstPath); URL url = null; FileInfo fileInfo = null; int contentLength = -1; int downloadLength = 0; OutputStream output = null; InputStream istream = null; try &#123; url = new URL(mDownLoadUrl); //打开到url的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); contentLength = connection.getContentLength(); Log.i(TAG, &quot;doInBackground: contentLength=&quot; + contentLength); //O部分，大体来说就是先检查文件夹是否存在，不存在则创建 istream = connection.getInputStream(); String filename = mDownLoadUrl.substring(mDownLoadUrl.lastIndexOf(&quot;/&quot;) + 1); File dir = new File(mDstPath); if (!dir.exists()) &#123; dir.mkdir(); &#125; File file = new File(mDstPath + filename); // 如果存在同名文件，重命名 if (file.exists()) &#123; file = FileUtils.rename(file.getPath()); &#125; output = new FileOutputStream(file); byte[] buffer = new byte[1024 * 4]; int count = 0; int len = -1; while ((len = istream.read(buffer)) != -1) &#123; output.write(buffer, 0, len); downloadLength += len; if (count == 10) &#123; fileInfo = new FileInfo(contentLength, downloadLength, file, file.getPath (), file.getName()); publishProgress(fileInfo); count = 0; &#125; count++; &#125; // 有可能count还没有走到10 fileInfo = new FileInfo(contentLength, downloadLength, file, file.getPath(), file .getName()); publishProgress(fileInfo); output.flush(); output.close(); istream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; IOUtils.close(output); IOUtils.close(istream); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; finally &#123; try &#123; IOUtils.close(output); IOUtils.close(istream); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; return fileInfo; &#125; @Override protected void onProgressUpdate(FileInfo... values) &#123; super.onProgressUpdate(values); refreshProgress(values[0]); &#125; @Override protected void onPostExecute(FileInfo fileInfo) &#123; super.onPostExecute(fileInfo); downloadfinish(fileInfo); &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125;&#125;private void start() &#123; mTvDownloadText.setText(&quot;开始下载&quot;); mProgressBar.setMax(100); mProgressBar.setProgress(0);&#125;private void downloadfinish(FileInfo fileInfo) &#123; Log.i(TAG, &quot;onPostExecute: 下载完成=&quot; + fileInfo.mPath); Toast.makeText(MainActivity.this, &quot;下载完成&quot;, Toast.LENGTH_SHORT).show();&#125;private void refreshProgress(FileInfo value) &#123; FileInfo fileInfo = value; if (fileInfo != null) &#123; mProgressBar.setMax((int) fileInfo.mLength); mProgressBar.setProgress((int) fileInfo.mDownloadLength); mDownText = fileInfo.mFile.getName() + &quot;下载了&quot; + fileInfo.mDownloadLength + &quot;总长度是&quot; + fileInfo.mLength; mTvDownloadText.setText(mDownText); &#125;&#125; AsyncTask的封装使用前面我们讲完了AsyncTask的基本使用，不知道你有没有发现，其实代码耦合性是挺高的， 我们直接在 onProgressUpdata(),onPostExecute()方法里面更新我们的界面，即我们的AsyncTask访问了我们Activity里面的控件，那如果我们修改了Activity的控件，我们岂不是又要去阅读AsyncTask的代码，去做相应的修改。 下一次我们如果要下载别的东西，按照我们前面的代码，我们又要重新复制一份，这样无疑是做了很多重复的工作。 说到这样，我相信大多数人的第一感觉就是把AsyncTask提取为外部类，封装起来。是的，确实，我们就是要把AsyncTask提取为外部类。那提取为歪不累之后呢？我们要访问Activity里面的空间，要怎样访问呢？ 在Activity里面定义静态方法 把需要访问的View对象通过构造函数传递进来 采用接口回调机制 前面说到的三种方法，是可以做到AsyncTask与外界进行通讯的。但第一第二中方法明显不行。原因如下： 第一种方法定义静态方法，那View对象也必须定义为static变量，这static变量的级别比较高，不易被垃圾回收机制回收，易发生没存泄露。 第二种方法，把需要访问的View对象通过构造函数传递进来。如果需要访问的对象少的话，勉强可以接受，如果多的话，那岂不是要定义很多成员变量。不过最致命的还算是代码耦合性太高了。还不如AsyncTask直接作为内部类。 好了，说了这么多，下面我们一起来看怎样使用接口回调机制来进行解耦。 AsyncTask 使用接口回调机制来进行解耦 使用接口回调机制，首先我们必须有一个接口 12345678public interface DownloadListener &#123; void onStart(); void onProgress(FileInfo fileInfo); void onFinish(FileInfo FileInfo); void onPaused(FileInfo fileInfo); void onCancled();&#125; 将DownLoadTask提取为一个外部类，并将需要传递的参数传递进来 1234567891011121314public class DownloadTask extends AsyncTask&lt;Void,FileInfo,FileInfo&gt; &#123; private String mDownloadUrl; private final String mDstPath; private final String mFileName; private final DownloadListener mDownloadListener; public DownloadTask(String downloadUrl, String dstPath, String fileName, DownloadListener downloadListener)&#123; mDownloadUrl = downloadUrl; mDstPath = dstPath; mFileName = fileName; mDownloadListener = downloadListener; &#125;&#125; 在相应的地方调用我们接口的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class DownloadTask extends AsyncTask&lt;Void,FileInfo,FileInfo&gt; &#123; ---- @Override protected void onPreExecute() &#123; super.onPreExecute(); mDownloadListener.onStart(); &#125; @Override protected FileInfo doInBackground(Void... params) &#123; ---- int len = -1; while ((len = istream.read(buffer)) != -1) &#123; output.write(buffer, 0, len); downloadLength += len; if (count == 10) &#123; fileInfo = new FileInfo(contentLength, downloadLength, file, file.getPath (), file.getName()); publishProgress(fileInfo); count = 0; &#125; count++; &#125; // 有可能count还没有走到10 fileInfo = new FileInfo(contentLength, downloadLength, file, file.getPath(), file .getName()); publishProgress(fileInfo); output.flush(); output.close(); istream.close(); return fileInfo; &#125; @Override protected void onProgressUpdate(FileInfo... values) &#123; super.onProgressUpdate(values); mDownloadListener.onProgress(values[0]); &#125; @Override protected void onPostExecute(FileInfo fileInfo) &#123; super.onPostExecute(fileInfo); mDownloadListener.onFinish(fileInfo); &#125; @Override protected void onCancelled() &#123; super.onCancelled(); mDownloadListener.onCancled(); &#125;&#125; 使用以后我们要下载东西，只需要调用下面的方法即可。同时，如果产品再更改需求，比如，从显示一个进度条ProgressDialog对话框，改成显示一个ProgressBar，我们只需要在onProgress（）里面做相应的修改就好了，在也不用去阅读DownloadTask里面的代码呢？减少了代码的耦合性，是不是瞬间感觉世界很美好呢？ 12345678910111213141516171819202122232425262728mDownloadTask = new DownloadTask(mDownloadUrl, mDstPath, null, new DownloadListener() &#123; @Override public void onStart() &#123; start(); &#125; @Override public void onProgress(FileInfo fileInfo) &#123; refreshProgress(fileInfo); &#125; @Override public void onFinish(FileInfo fileInfo) &#123; downloadfinish(fileInfo); &#125; @Override public void onPaused(FileInfo fileInfo) &#123; &#125; @Override public void onCancled() &#123; &#125;&#125;);mDownloadTask.execute(); AsyncTask使用的注意事项 The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN. The task instance must be created on the UI thread.（AsyncTask必须在UI 线程里面初始化 execute(Params…) must be invoked on the UI thread. Do not call onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…) manually.（不要手动地调用 onPreExecute(), onPostExecute(Result), doInBackground(Params…), onProgressUpdate(Progress…) 这些方法） The task can be executed only once (an exception will be thrown if a second execution is attempted.) （Task任务只能被执行一次，否则会抛出异常） 相关知识点推荐： IntentService使用及源码分析 HandlerThread源码分析 AsyncTask使用及封装实践 AsyncTask源码分析 Demo下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用第三方框架解耦的一种思路——简单工厂模式的运用]]></title>
      <url>%2F2017%2F01%2F15%2F%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%80%A6%E7%9A%84%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
      <content type="text"><![CDATA[CSDN首发地址： 前言写在前头，这篇博客对于老司机们没什么多大的意义，老司机们就不用看了，对于新手还是有很大实用价值的。 平时在项目中，你们有没有遇到这样的情况，比如之前项目是使用开源框架ImageLoader，现在想使用Picasso或者Glide，这时候你会怎么办呢？是一行一行代码去改吗？ 当然可以，如果项目使用到ImageLoader相应的方法少的话，那还可以，但是一旦项目比较大型的话，这会是多大的工作量，估计至少得改个几天，累先不说，至少毫无意义，那怎么办呢？别急，下面就来讲解。 第一种方法这种方法大多数人都会使用，直接封装成为一个工具类，提取公共参数，以后想修改的话，直接修改工具类里面具体的实现 12345678910public class ImageLoaderUtils &#123; public static void loadImageView(Context mContext, String url, ImageView mImageView) &#123; Picasso.with(mContext).load(url).into(mImageView); &#125;&#125; 这个时候我们的项目中如果不想使用Picasso，这个时候我们想使用Glide，我们只需修改ImageLoaderUtils类中方法的具体实现即可，代码如下 123456789101112131415public class ImageLoaderUtils &#123; /** * 指定大小加载图片 * * @param mContext 上下文 * @param url 图片路径 * @param mImageView 控件 */ public static void loadImageView(Context mContext, String url, ImageView mImageView) &#123;// Picasso.with(mContext).load(url).into(mImageView); Glide.with(mContext).load(url).into(mImageView); &#125;&#125; 看了上面的代码，相信大多数人都知道，如果我们不封装，我们必须查找每个类文件里面使用到Picasso的相应方法的位置，然后再替换，这会是一个很大的工作量。而我们如果进行封装，只需更改工具类里面的方法的具体实现，这样是不是很方便呢？看到这里，你是不是觉得这篇文章结束呢，还没，下面介绍另外一种方法，这种方法将更加优雅。 那就是使用简单工厂模式。 简单工厂模式定义简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。简单点说就是用来创建具有相同基类的对象 类UML图 角色介绍从上面的UML图可以看到，总共有三个角色Factory，Product，ConcreteProuct，其中Factory依赖于Product Product：产品的基类，通常有抽象类或者接口来充当，用来统一接口，不关心细节的实现 ConcreteProduct：Product的具体实现类 Factory：工厂类，用来创建对象，可以根据参数的不同返回不同的Product对象，实现逻辑封装在其内部 使用步骤从上面的分析，我们知道，采用简单工厂模式，一般需要三个步骤 抽象Product的共同特点，定义成一个接口或者抽象类 ConcreteProduct的具体实现 实现Factory 下面我们一起来看一下怎样运用于替换图片框架上 简单工厂模式的运用——几行代码更换图片框架首先为了加深理解，我们一起先来看一下类UML图 接着按照上面的三部曲，第一步，我们先定义一个接口IimageListener，用来统一参数 123456789101112131415public interface IimageListener &#123; void display(Context context, ImageView imageView, String url, int progressId, int errorId, Object tag); void display(Context context, ImageView imageView, String url, int progressId, int errorId); void display(Context context, ImageView imageView, String url, int progressId); void display(Context context, ImageView imageView, String url); void display(Context context, ImageView imageView, Uri uri);&#125; 第二步，我们来写GlideRequest和PicassoRequest的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142public class GlideRequest implements IimageListener &#123; @Override public void display(Context context, ImageView imageView, String url, int progressId, int errorId, Object tag) &#123; DrawableTypeRequest&lt;String&gt; load = Glide.with(context).load(url); if (progressId != -1) &#123; load.placeholder(progressId).centerCrop(); &#125; else &#123; load.placeholder(new ColorDrawable(Color.GRAY)); &#125; if (errorId != -1) &#123; load.error(errorId); &#125;else&#123; load.error(R.drawable.ic_error); &#125; load.into(imageView); &#125; @Override public void display(Context context, ImageView imageView, String url, int progressId, int errorId) &#123; display(context, imageView, url, progressId, errorId, null); &#125; @Override public void display(Context context, ImageView imageView, String url, int progressId) &#123; display(context, imageView, url, progressId, -1, null); &#125; @Override public void display(Context context, ImageView imageView, String url) &#123; display(context, imageView, url, -1, -1, null); &#125; @Override public void display(Context context, ImageView imageView, Uri uri) &#123; DrawableTypeRequest&lt;Uri&gt; load = Glide.with(context).load(uri); load.into(imageView); &#125; } 1234567891011121314151617181920212223242526272829public class PicassoRequest implements IimageListener &#123; @Override public void display(Context context, ImageView imageView, String url, int progressId, int errorId, Object tag) &#123; Picasso.with(context).load(url).placeholder(progressId).error(errorId).tag(tag).into(imageView); &#125; @Override public void display(Context context, ImageView imageView, String url, int progressId, int errorId) &#123; Picasso.with(context).load(url).placeholder(progressId).error(errorId).into(imageView); &#125; @Override public void display(Context context, ImageView imageView, String url, int progressId) &#123; Picasso.with(context).load(url).placeholder(progressId).into(imageView); &#125; @Override public void display(Context context, ImageView imageView, String url) &#123; Picasso.with(context).load(url).into(imageView); &#125; @Override public void display(Context context, ImageView imageView, Uri uri) &#123; Picasso.with(context).load(uri).into(imageView); &#125;&#125; 第三步，我们来写工厂类ImageRequestManager的实现,可以看到我们可以根据不同的参数返回不同的实例，进而来决定使用Picasso或者是Glide 1234567891011121314151617181920212223242526272829public class ImageRequestManager &#123; public static final String type_Glide=&quot;Glide&quot;; public static final String type_Picasso=&quot;Picasso&quot;; public static final String type_default =type_Glide; private ImageRequestManager()&#123; &#125; public static IimageListener getRequest()&#123; return getRequest(type_default); &#125; public static IimageListener getRequest(String type)&#123; switch (type)&#123; case type_Glide: return new GlideRequest(); case type_Picasso: return new PicassoRequest(); default: return new GlideRequest(); &#125; &#125;&#125; 最后，以后我们想加载图片只需简单调用下面的方法就OK了，简单明了，再也不用怕替换框架了 1ImageRequestManager.getRequest().display(mContext, imageView, imageUrl); 讨论情景一：之前我是使用Glide框架，现在想使用Picasso框架，那要怎么办呢？ 只需将 ImageRequestManager 里面的 String type_default=type_Glide 更改为String type_default=type_Picasso 就ok了。 12//public static final String type_default =type_Glide;public static final String type_default =type_Picasso; 情景二：有人会说了，平时在项目中基本只会使用一种图片加载框架，要么使用Picasso，要么使用Glide，你这样做同时使用了两种框架，无疑增加了APK的大小，那要怎么办呢？其实很简单 如果你只想使用Picasso，去掉Glide的具体实现就OK了，同理你只想使用Glide，去掉Picasso的具体实现就好了，不过建议保留空方法，以后要修改就不必更改工厂类 ImageRequestManager 里面的逻辑呢。 简单工厂模式总结 将对象的创建工作与对象的业务逻辑分析，降低了系统的耦合度 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。为了调用者的方便，我们可以给工厂类添加一个默认参数，这样调用的时候不必每次传入参数 从上面知道的例子，我们知道，业务逻辑大部分在工厂类里面，如果工厂类需要创建的对象不多的话，简单工厂方法模式还是很有很大的优势的，而如果需要创建很多对象的话，那工厂里面无疑要增加很多case 语句，这样会导致工厂类的职责太重了，破坏了类的单一性。 综上所述： 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。 扩展看了上面的文章，对于于Volley，OKhttp等网络框架的简单封装，你是不是也想到了什么，应该懂得怎么封装了吧。 而对于Retrofit的封装，你有没有想到了什么呢？因为Retrofit的返回对象比较特殊，是 Observable&lt;&gt;,更其他的网络框架不太一样，其实还是可以大概处理一下的，这里暂时就不讨论了，大家有兴趣的可以自己先去尝试，相信你会收获到很多东西的。 题外话万丈高楼平地起，对于程序猿的我们，一定要多动手实践，我相信很多同学看到这里，都基本掌握了，但是很有很多同学不动手去实践一下，就这样，几天过去了，似懂非懂，最后忘记了，而这恰恰是分水岭。哈哈，就扯蛋这么多了。 最后给出github地址，上面的小项目是我平时没事写写玩玩的。 github地址 CSDN首发地址：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[16年，平凡而又收获的一年]]></title>
      <url>%2F2016%2F12%2F31%2F16%E5%B9%B4%EF%BC%8C%E5%B9%B3%E5%87%A1%E8%80%8C%E5%8F%88%E6%94%B6%E8%8E%B7%E7%9A%84%E4%B8%80%E5%B9%B4%2F</url>
      <content type="text"><![CDATA[文章首发地址CSDN: 岁月如水，时间飞逝，转眼间，已经到了年尾，即将引来新的一年，我要赶紧抓住16年的尾巴，写篇文章记录一下我16年的点点滴滴。篇章大概如下，学习&amp;工作室篇，实习篇，盛夏六月， 博客篇，秋招篇，情感篇，展望未来。 学习&amp;工作室篇 春节弹指一瞬间，转眼间已经到了正月18，迷恋着春节家人朋友团聚时候喜悦的气氛，我依依不舍地乘着大巴回到了学校，开始新的学期。在大学的时光里，没有想高三时光一样，三点一线。在大学里，多的是自由。每天，我往返于工作室和宿舍之间，那时每天只想着能争取多点时间 学习自己感兴趣的东西————也就是我现在所从事的职业Android开发。每天为了挤出一个多小时的时间来学习，尝试过中午不睡觉，坚持了两个多星期。结果是中午不睡，晚上崩溃———下午不睡觉，下午学习的时候还是精神蓬勃的，到了晚上，睡意就来了，经常打瞌睡。结果呢，相信你也猜到了，学习的东西反而少了，效率下降了好多。 原因，浅而明显，第一，一个人的精力是有限的，我们要注意劳逸结合；第二，以前我都是有午睡的习惯的，突然改变了习惯，肯定要有一段适应期。 至于说到劳逸结合，高中的时候就深有体会，大学写编程的时候更是深深刻在心里。有时候，写编程，在调bug的时候，在哪里捣鼓了几个小时，终究是被它折服了，被它弄得心浮气躁。这时候不烦放下手头的工作，出去走走，感受一下大自然，放松一下头脑，接着回来工作，许多时候你会发现bug一下子就解决了。这个时候你通常我会感慨，我擦，我是一个傻逼，这么简单的问题竟然弄了这么久，心里头不禁也涌上来一股满足感————那是一种付出辛苦努力而得到的满足。 有许多人说，写编程会让一个人性格变得烦躁。哈哈，有时候确实会，不过，有时候我更想说的是，写编程往往是我们变得更加耐心和细心。每一次我们在跟bug作斗争的时候，我们的耐心正在一点点培养。 许多人说程序员活像闷葫芦，钱多话少死得早。怎么说呢，这句话还是有一点道理的，首先钱多呢，这个就不必详讲了，相对大多数打工族来说，程序猿的工资相对来是还是比较高的。话少呢，确实也有一定的道理，因为我们整天面对的是电脑，比较少与人沟通交流，久而久之，语言表达能力肯定会退化不少的，有时候在与人交谈中，也不知道谁聊什么话题好，这就给了大家一种印象——话少。至于“死得早”，我们知道程序猿加班相对比较多，尤其是项目要上线的时候，经常会加班，而且工作强度相对来说有比较强。确实，如果你不注意锻炼的话，真的对身体伤害很大的。但只要你注意一下，每个星期坚持两三次锻炼，也是照样精神饱满的。 实习篇 说起实习的那段时间，那真的是一段艰辛岁月。每天实习完回到宿舍，有时候身心俱疲，根本就提不起精神来继续学习，我也因此颓废了一段时间，每天回到宿舍后，就开始看电影，看电视剧——后面我调整了自己的状态，在实习完回来的时候继续学习。 如果你问我那段时间累不累？我可以很肯定地告诉你，累成狗。但是我从未后悔过，因为一段岁月过得很充实，正如我们高三备考的那段岁月——只为心中的那一个目标。 盛夏六月 每天的五六月份，都是我们学校的毕业季。送走了一拨人，又即将引来新的一拨人，注入新的血液。在这段时间，对我感触最深的是，应该是我二哥和我社团的几个师兄和师姐牌毕业照的时候，他们说大学时光飞快，要好好珍惜接下来的大学时光。 有时候也在想，一年后的自己会是怎样的呢？ 真的很感谢他们，曾今他们在我大学最迷茫的时候引导了我，为我指点迷津。 博客篇 我正式写博客的时候应该是四月底五月初的时候，像大多数人一样，刚开始写博客的时候完全没有思路，写出来的文章条理性差，访问量也很少。我记忆比较深的一篇博客是我在写这篇博客的时候：二分查找的相关算法题 ，那时候些博客写到深夜12点多，就发布了出去，第二天醒来，访问量竟然超过一千了。一千的访问量对于经常写博客或者有一定知名度的博客来说，根本就是小菜一碟，算不了什么。但对于我之前几篇博客都是几十最多一百多的访问量的人来说，这无疑是意义非凡的。这意味着对我这篇博客质量的认可，正如我们付出的努力得到认可的喜悦一样。 为什么写博客呢（当然我不是在说我写博客有多了不起，我只是在分享一下自己的经历而已———— 一些人或许会这样想，坚持写博客有什么了不起的，网上一大堆人在写博客，怎么不见他们在说写博客辛苦，或者吹捧。有一些腹黑的人更恶劣的，甚至会骂你，谴责你，不懂得谦虚，骄傲自大。 对于第一类人，分情况讨论一下，如果是那种整天无所事事的人，那我会嗤之以鼻，如果是那种很努力的人，整天辛苦奋斗的人，那我们写博客确实算不了什么。 而对于那些动不动就站在道德制高点的那些人，我真的不知道说写什么说。这种人我们真的不必跟他们太较真，较真你就输了。 总之，说了这么久，只想表达这样的意思，坚持走自己认为正确的路，世界那么大，让别人说去吧。 这里分享一个故事，是几天前发生的，是Android开发者 StormhZhang 的故事，故事概要是这样的，StromZhang 在他的公众号推送了一篇广告，结果有一些人就说他作为一名技术总监，还发广告，差不差这点钱，进而有提升到道德方面，有一些人更过分，甚至流言谩骂。殊不知他做技术分享帮助了多少人？这里就不过多介绍了，欲知详情，请自行搜索。 哈哈，扯蛋了这么久，终于来说我能够坚持下来写博客的原因呢？原因其实很简单，对于经常写博客的人，我相信他们都有一个共同点，写着写着就爱上博客了。即使说没有写博客，也喜欢用笔记将自己认为有价值的东西记录下来，just sosimple。当然，写博客有几个好处，锻炼自己的写作能力，提高自己的思维，更难能可贵的是，你能够在写博客的时候遇到一些志同道合的朋友。目前我还没有遇到，期待img，说一下我的一个经历，之前有一个技术疑问一直解决不了，后面在写相关博客的时候，在博客的最后提了出来，后面有热心的网友帮忙解答了，那时候真的很感动。 秋招篇说起我的秋招之旅，可能对于身边的人来说，我相对是比较轻松的。可是对于许多大神来说，差的还不是一截半截。记得我经常说过一句话，比上不足，比下有余。 八月中旬的时候，秋招的号角正式吹响了。刚开始是一些BAT之类的公司内推，筛选简历或者笔试，很遗憾，我全部都没有通过。九月中旬的时候，BAT，网易，CVTE等这些知名企业开始校招了，很遗憾笔试也是全部没有通过。一方面是今年校招缩水了，招的人很少，一方面可能自己的笔试成绩也不是十分突出。那时候，心底是有点慌的，因为校招开始了半个多月，竟然一个笔试都没有通过，面试也没有。 于是，我自己独自一人来到腾讯面试的地方——喜来登大酒店，想去霸面。刚开始，想趁着他们在面试的时候跟着他们上去，可是还是被挡在电梯外面了。于是就去霸面区交了简历，后面想“趁水摸鱼” 坐上电梯，直接去找面试官，跟他说想霸面。可是还是被挡在第一外面了。于是就没有继续找机会坐上电梯去了。结果的最后，就是在里面空坐了一天，霸面fail，一天就这样 get over。其实，那时候如果真的下定决心要上去的话，机会还是很大的，等到有房可上去的时候，跟他们一起上去就好了。之所以当时没有那样做，可能自己还没有足够的信心。可是去之前是信心满满要去霸面的，可到现场遇到一点小阻碍却退却了，也许这就是我性格的一个弱点吧。 到了九月底的时候，也开始面试了，陆续收到了美图，久邦数码，步步高等公司的offer，最终签了美图公司，在十月初的时候也结束了我的秋招之旅。 在秋招，对于面试，我也没有一些很好的技巧。对于技术岗位的，我只能说三分口才，七分实力。对于搞技术的人，千万不要忽略语言表达能力方面的培养与提高，一方面在面试的时候你会吃很大亏，另一方面对你以后人生的发展也是很不利的。我在表达这方面就吃过挺多亏的，现在表达能力还是有待提高。 情感篇说了这么久，来稍微说一点轻松一点的东西呢？那就是说情感方面的呢，其实我的情感篇真的没什么可说的，大学到现在也没谈过恋爱，可能是一直没有遇到合适的人吧，或者是我的情商有点低吧。谁说得清楚呢？ 至于亲情方面，我想说的是，有空就多回家看看吧。对于父母来说，子女经常回家就是最好的礼物呢，比得多钱财万贯。 展望未来 旧的一年即将过去了，新的一年即将到来。在新的一年，大概有以下计划 在毕业前来一次说走你就走的旅行（不过到时候实习不知道有没有时间，尽量争取吧） CSDN争取申请到博客专家号，现在是准博客专家 截张图记录一下我现在博客的访问量 17年，即将到来的新的一年，希望家人朋友身体健康，实习，工作顺利。最后的最后，为了青春和热血，再次拼搏加油，致我的青春，青春万岁。 文章首发地址CSDN:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你真的了解View的坐标吗？]]></title>
      <url>%2F2016%2F12%2F12%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3View%E7%9A%84%E5%9D%90%E6%A0%87%E5%90%97%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[文章首发CSDN地址 : 闲聊View，对我们来说在熟悉不过了，从接触Android开始，我们就一直在接触View，界面当中到处都是 View，比如我们经常用到的TextView，Button，LinearLayout等等，但是我们真的了解View吗？尤其是View的坐标。mLeft,mRight,mY,mX,mTranslationY,mScoollY,相对于屏幕的坐标等等这些概念你真的清楚了吗？如果真的清楚了，那你没有必要读这篇博客，如果你还是有一些模糊，建议花上几分钟的时间读一下。 为什么要写这一篇博客呢？ 因为掌握View的坐标很重要，尤其是对于自定义View，学习动画有重大的意义。 这篇博客主要讲解一下问题 View 的 getLeft（）和get Right（）和 getTop（） 和getBottom（） View 的 getＹ（）， getTranslationY() 和 getTop（） 之间的联系 View 的 getScroolY 和 View 的 scrollTo() 和 scrollBy（） event.getY 和 event.getRawY() 扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度 基本概念 简单说明一下（上图Activity采用默认Style，状态栏和标题栏都会显示）：最大的草绿色区域是屏幕界面，红色次大区域我们称之为“应用界面区域”，最小紫色的区域我们称之为“View绘制区域”；屏幕顶端、应用界面区之外的那部分显示手机电池网络运营商信息的为“状态栏”，应用区域顶端、View绘制区外部显示Activity名称的部分我们称为“标题栏”。 从这张图片我们可以看到在Android中，当ActionBar存在的情况下， 1屏幕的 高度=状态栏+应用区域的高度=状态栏的 高度+（标题栏的 高度+View 绘制区域的高度） 当ActionBar不存在的情况下 1屏幕的高度=状态栏+应用区域的高度=状态栏的 高度+（View 绘制区域的 高度） View 的 getLeft（）和getRight（）和 getTop（） 和getBottom（）1234View.getLeft() ;View.getTop() ;View.getBottom();View.getRight() ; top是左上角纵坐标，left是左上角横坐标，right是右下角横坐标，bottom是右下角纵坐标,都是相对于它的直接父View而言的，而不是相对于屏幕而言的。这一点要区分清楚。那那个坐标是相对于屏幕而言的呢，以及要怎样获取相对于屏幕的坐标呢？ 目前View里面的变量还没有一个是相对于屏幕而言的，但是我们可以获取到相对于屏幕的坐标。一般来说，我们要获取View的坐标和高度 等，都必须等到View绘制完毕以后才能获取的到，在Activity 的 onCreate（）方法 里面 是获取不到的，必须 等到View绘制完毕以后才能获取地到View的响应的坐标，一般来说，主要 有以下两种方法。 第一种方法，onWindowFocusChanged（）方法里面进行调用 1234567891011121314 @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); //确保只会调用一次 if(first)&#123; first=false; final int[] location = new int[2]; mView.getLocationOnScreen(location); int x1 = location[0] ; int y1 = location[1] ; Log.i(TAG, "onCreate: x1=" +x1); Log.i(TAG, "onCreate: y1=" +y1); &#125;&#125; 第二种方法，在视图树绘制完成的时候进行测量 123456789101112131415mView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver .OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; // 移除监听器，确保只会调用一次，否则在视图树发挥改变的时候又会调用 mView.getViewTreeObserver().removeGlobalOnLayoutListener(this); final int[] location = new int[2]; mView.getLocationOnScreen(location); int x1 = location[0]; int y1 = location[1]; Log.i(TAG, "onCreate: x1=" + x1); Log.i(TAG, "onCreate: y1=" + y1); &#125;&#125;); View 的 getＹ（）， getTranslationY() 和 getTop（） 之间的联getＹ（） Added in API level 14The visual y position of this view, in pixels.(返回的是View视觉上的图标，即我们眼睛看到位置的Y坐标，注意也是相对于直接父View而言的默认值跟getTop（）相同，别急，下面会解释） getTranslationY() Added in API level 14The vertical position of this view relative to its top position, in pixels.(竖直方向上相对于top的偏移量，默认值为0） 那 getY（） 和 getTranslationY（） 和 getTop （） 到底有什么关系呢？ 12345678910111213@ViewDebug.ExportedProperty(category = "drawing")public float getY() &#123; return mTop + getTranslationY();&#125; @ViewDebug.ExportedProperty(category = "drawing") public float getTranslationY() &#123; return mRenderNode.getTranslationY(); &#125; @ViewDebug.CapturedViewProperty public final int getTop() &#123; return mTop; &#125; 从以上的源码我们可以知道 getY（）= getTranslationY（）+ getTop （），而 getTranslationY（） 的默认值是0，除非我们通过 setTranlationY（） 来改变它，这也就是我们上面上到的 getY 默认值跟 getTop（）相同 那我们要怎样改变 top值 和 Y 值呢？ 很明显就是调用相应的set方法 ，即 setY（） 和setTop（） ，就可以改变他们 的值。 View 的 getScroolY 和 View 的 scrollTo() 和 scrollBy（）getScrollY是一个比较特别的函数，因为它涉及一个值叫mScrollY，简单说，getScrollY一般得到的都是0，除非你调用过scrollTo或scrollBy这两个函数来改变它。 scrollTo() 和 scrollBy（）从字面意思我们可以知道 scrollTo() 是滑动到哪里的意思 ，scrollBy（）是相对当前的位置滑动了多少。当然这一点在源码中也是可以体现出来的 12345678910111213141516public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125;public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; 有几点需要注意的是 不论是scrollTo或scrollBy，其实都是对View的内容进行滚动而不是对View本身，你可以做个小实验，一个LinearLayouy背景是黄色，里面放置一个子LinearLayout背景是蓝色，调用scrollTo或scrollBy，移动的永远是蓝色的子LinearLayout。 还有就是scrollTo和scrollBy函数的参数和坐标系是“相反的”，比如scrollTo(-100,0)，View的内容是向X轴正方向移动的，这个相反打引号是因为并不是真正的相反，具体可以看源码，关于这两个函数的源码分析大家可以看Android——源码角度分析View的scrollBy()和scrollTo()的参数正负问题，一目了然。 View 的 width 和 height1234@ViewDebug.ExportedProperty(category = "layout")public final int getHeight() &#123; return mBottom - mTop;&#125; 我们可以看到 Android的 height 是由 mBottom 和 mTop 共同得出的，那我们要怎样设置Android的高度呢？有人会说直接在xml里面设置 android:height=”” 不就OK了，那我们如果要动态设置height的高度呢，怎么办？你可能会想到 setWidth（）方法？但是我们找遍了View的所有方法，都没有发现 setWidth（）方法，那要怎样动态设置height呢？其实有两种方法 123456789 int width=50;int height=100;ViewGroup.LayoutParams layoutParams = view.getLayoutParams();if(layoutParams==null)&#123; layoutParams=new ViewGroup.LayoutParams(width,height);&#125;else&#123; layoutParams.height=height;&#125;view.setLayoutParams(layoutParams); 第二种方法，单独地改变top或者bottom的值，这种方法不推荐使用 至于width，它跟height基本一样，只不过它是有mRight 和mLeft 共同决定而已。 需要注意的是，平时我们在执行动画的过程，不推荐使用LayoutParams来改变View的状态，因为改变LayoutParams会调用requestLayout（）方法，会标记当前View及父容器，同时逐层向上提交，直到ViewRootImpl处理该事件，ViewRootImpl会调用三大流程，从measure开始，对于每一个含有标记位的view及其子View都会进行测量、布局、绘制，性能较差，源码体现如下：关于requestLayout （）方法的更多分析可以查看这一篇博客Android View 深度分析requestLayout、invalidate与postInvalidate 1234567891011public void setLayoutParams(ViewGroup.LayoutParams params) &#123; if (params == null) &#123; throw new NullPointerException("Layout parameters cannot be null"); &#125; mLayoutParams = params; resolveLayoutParams(); if (mParent instanceof ViewGroup) &#123; ((ViewGroup) mParent).onSetLayoutParams(this, params); &#125; requestLayout();&#125; 因此我们如果在api 14 以后 ，在动画执行过程中，要改变View的状态，推荐使用setTranslationY（）和setTranslationX（0等方法，而 尽量避免改变LayoutParams.因为性能嫌贵来说较差。 event.getY() 和 event.getRawY() 要区分于MotionEvent.getRawX() 和MotionEvent.getX();, 在public boolean onTouch(View view, MotionEvent event) 中，当你触到控件时，x,y是相对于该控件左上点（控件本身）的相对位置。 而rawx,rawy始终是相对于屏幕的位置。getX()是表示Widget相对于自身左上角的x坐标,而getRawX()是表示相对于屏幕左上角的x坐标值 (注意:这个屏幕左上角是手机屏幕左上角,不管activity是否有titleBar或是否全屏幕)。 扩展，怎样获取状态栏（StatusBar）和标题栏（titleBar）的高度1234567891011121314151617181920212223242526272829303132 public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); //屏幕 DisplayMetrics dm = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(dm); Log.e(TAG, &quot;屏幕高:&quot; + dm.heightPixels); //应用区域 Rect outRect1 = new Rect(); getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect1); //这个也就是状态栏的 高度 Log.e(TAG, &quot;应用区顶部&quot; + outRect1.top); Log.e(TAG, &quot;应用区高&quot; + outRect1.height()); // 这个方法必须在有actionBar的情况下才能获取到状态栏的高度 //View绘制区域 Rect outRect2 = new Rect(); getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(outRect2); Log.e(TAG, &quot;View绘制区域顶部-错误方法：&quot; + outRect2.top); //不能像上边一样由outRect2.top获取，这种方式获得的top是0，可能是bug吧 Log.e(TAG, &quot;View绘制区域高度：&quot; + outRect2.height()); int viewTop = getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop(); //要用这种方法 Log.e(TAG, &quot;View绘制区域顶部-正确方法：&quot; + viewTop); int titleBarHeight=viewTop; Log.d(TAG, &quot;onWindowFocusChanged: 标题栏高度titleBarHeight=&quot; +titleBarHeight);&#125; 这里我们需要注意的 是在ActionBar存在的情况下，通过这种方法我们才能够得出titleBar的高度，否则是无法得到的，因为viewTop 为0. 这篇博客到此为止，关于更多自定义View 的一些例子，可以看我以下的博客 常用的自定义View例子一(FlowLayout) 自定义View常用例子二（点击展开隐藏控件，九宫格图片控件） 常用的自定义View例子三（MultiInterfaceView多界面处理） 常用的自定义控件四（QuickBarView）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教你用Hexo+Github 搭建属于自己的博客]]></title>
      <url>%2F2016%2F12%2F11%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8Hexo-Github-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[闲聊在大三的时候，一直就想搭建属于自己的一个博客，但由于各种原因，最终都不了了之，恰好最近比较有空，于是就自己参照网上的教程，搭建了属于自己的博客。 至于为什么要搭建自己的博客了？ 哈哈，大概是为了装逼吧，同时自己搭建博客的话，样式的选择也比较自由，可以自己选择，不需要受限于各大平台。 转载请注明原博客地址：手把手教你用Hexo+Github 搭建属于自己的博客 大概可以分为以下几个步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 搭建环境准备大概可以分为以下三步 Node.js 的安装和准备 git的安装和准备 gitHub账户的配置 配置Node.js环境 下载Node.js安装文件： Windows Installer 32-bit Windows Installer 64-bit 根据自己的Windows版本选择相应的安装文件，要是不知道，就安装32-bit的吧- -。 如图所示： 保持默认设置即可，一路Next，安装很快就结束了。 然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口： Windows的运行界面 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~） 在打开的命令行界面中，输入 12node -vnpm -v 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 配置Git环境下载Git安装文件： GIt官网下载地址： Git-2.6.3-64-bit.exe 然后就进入了Git的安装界面，如图： Git安装界面 和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： Git PATH设置 这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入： 1git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 关于 git的下载即安装，可以参考我的这一篇博客： Git下载及配置环境变量 github账户的注册和配置如果已经拥有账号，请跳过此步~ Github注册 打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。 然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。 一定要确认注册，否则无法使用gh-pages！ 创建代码库 登陆之后，点击页面右上角的加号，选择New repository： 新建代码库 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示： 注意：比如我的github名称是gdutxiaoxu ,这里你就填 gdutxiaoxu.github.io,如果你的名字是xujun，那你就填 xujun.github.io 代码库设置 正确创建之后，你将会看到如下界面： 接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图： Github pages 点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 到此搭建hexo博客的相关环境配置已经完成，下面开始讲解Hexo的相关配置 安装Hexo在自己认为合适的地方创建一个文件夹，这里我以E：/hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录 在命令行中输入： 1npm install hexo-cli -g 然后你将会看到: 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入 1npm install hexo --save 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入： 1hexo -v 如果你看到了如图文字，则说明已经安装成功了。 hexo的相关配置 初始化Hexo 接着上面的操作，输入： 1hexo init 然后输入： 1npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 首次体验Hexo 继续操作，同样是在命令行中，输入： 1hexo g 然后输入： 1hexo s 然后会提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/，你将会看到： 到目前为止，Hexo在本地的配置已经全都结束了。 下面会讲解怎样将Hexo与github page 联系起来 怎样将Hexo与github page 联系起来大概分为以下几步 配置git个人信息 配置Deployment 配置Git个人信息如果你之前已经配置好git个人信息，请跳过这一个 步骤，直接来到 1、设置Git的user name和email：(如果是第一次的话) 12git config --global user.name &quot;xujun&quot;git config --global user.email &quot;gdutxiaoxu@163.com&quot; 2、生成密钥 1ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot; 配置Deployment同样在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 比如我的仓库的地址是git@github.com:gdutxiaoxu/gdutxiaoxu.github.io.git，所以配置如下 1234deploy: type: git repo: git@github.com:gdutxiaoxu/gdutxiaoxu.github.io.git branch: master 写博客、发布文章新建一篇博客，执行下面的命令： 1hexo new post &quot;article title&quot; 这时候在我的 电脑的目录下 F:\hexo\source_posts 将会看到 article title.md 文件 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 当然你也可以执行下面的命令，相当于上面两条命令的效果 1hexo d -g #在部署前先生成 部署成功后访问 你的地址，https://yourName.github.io（这里输入我的地址： https://gdutxiao.github.io ),将可以看到生成的文章。 踩坑提醒 1）注意需要提前安装一个扩展： 1npm install hexo-deployer-git --save 2）如果出现下面这样的错误， Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 则是因为没有设置好public key所致。在本机生成public key,不懂的可以参考我的这一篇博客Git ssh 配置及使用 主题推荐每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。有两个比较好的主题推荐给大家。 Yilia Yilia 是为 hexo 2.4+制作的主题。崇尚简约优雅，以及极致的性能。 Yilia地址 NexT 我的网站就是采用这个主题，简洁美观。目前Github上Star最高的Hexo主题，支持几种不同的风格。作者提供了非常完善的配置说明。 Net主题的配置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 比如我的电脑下的 F:\hexo 目录下的成为 站点配置文件，F:\hexo\themes\next 目录下的成为主题配置文件。 1. 安装 NexT Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题 如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 克隆最新版本下载稳定版本在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 2. 启用主题 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 3. 验证主题 首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 4. 主题设定 选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： 1234Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面 注释 # 即可。 选择 Pisce Scheme 123#scheme: Muse#scheme: Mistscheme: Pisces 5. 设置 语言 编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定实例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id 6. 设置 菜单 菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 请注意键值（如 home）的大小写要严格匹配 7. 侧栏 默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： 12left - 靠左放置right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。 12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： 123456post - 默认行为，在文章页面（拥有目录列表）时显示always - 在所有页面中都显示hide - 在所有页面中都隐藏（可以手动展开）remove - 完全移除sidebar: display: post 已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。 8. 设置 头像 编辑 站点配置文件， 新增字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avtar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建uploads目录若不存在） 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 , 配置为：avatar: /images/avatar.png 头像设置示例 avatar: http://example.com/avtar. 9. 设置 作者昵称 编辑 站点配置文件， 设置 author 为你的昵称。 10. 站点描述 编辑 站点配置文件， 设置 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) net主题的官方文档地址 添加插件添加sitemap和feed插件 切换到你本地的hexo 目录CIA，在命令行窗口，属兔以下命令 12npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save 修改_config.yml，增加以下内容 123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 再执行以下命令，部署服务端 1hexo d -g 配完之后，就可以访问 https://gdutxiaoxu.github.io/atom.xml 和 https://gdutxiaoxu.github.io/sitemap.xml ，发现这两个文件已经成功生成了。 添加404 页面GitHub Pages有提供制作404页面的指引：Custom 404 Pages直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。 推荐使用腾讯公益404 我的404页面配置如下 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;gdutxiaoxu.github.io&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考博客Hexo主页 史上最详细的Hexo博客搭建图文教程 我的git系列参考教程 Git下载及配置环境变量 Git 命令行教程及实例教程 Git ssh 配置及使用 git ssh 配置多个账户 转载请注明原博客地址：手把手教你用Hexo+Github 搭建属于自己的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git ssh 配置多个账户]]></title>
      <url>%2F2016%2F12%2F11%2Fgit-ssh-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%B4%A6%E6%88%B7%2F</url>
      <content type="text"><![CDATA[前言：前几天在写博客 手把手教你用Hexo + github 搭建自己博客的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下 Git下载及配置环境变量 Git 命令行教程及实例教程 Git ssh 配置及使用 git ssh 配置多个账户 闲聊这篇教程是在电脑上已经安装好git的前提之上的，要进行以下配置，请先确保你的电脑已经安装好git。以下配置步骤是在git bash里面进行配置的，可以通过 右键》 git bash here 打开 在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。 这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。 而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例， 今天主要是讲述如何配置使用ssh方式来提交和克隆代码。 大概可以分为一下几个步骤 设置Git的user name和email：(如果是第一次的话) 检查是否已经有SSH Key。 生成密钥 添加密钥到ssh-agent 登陆Github, 添加 ssh 测试： 1、设置Git的user name和email：(如果是第一次的话)1234# 这里的“xujun&quot; 可以替换成自己的用户名git config --global user.name &quot;xujun&quot;# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱git config --global user.email &quot;gdutxiaoxu@163.com&quot; 检查是否已经有SSH Key。1 cd ~/.ssh 接着输入ls， 1ls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 生成密钥 这一步骤， 下图是存在的情况下 3、生成密钥12# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot; 连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\Users\Administrator\.ssh 4、添加密钥到ssh-agent确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5、登陆Github, 添加 ssh 。把id_rsa.pub文件里的内容复制到这里 6、测试：1ssh -T git@github.com 你将会看到： Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了。 扩展 如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。 这里同样以我本机目录下的G://test 仓库为例子， 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容 12345678910111213 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = https://github.com/gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master 将文件中的 url = https://github.com/gdutxiaoxu/test.git 更改为 url = git@github.com:gdutxiaoxu/test.git 即可。 修改后的文件如下 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = git@github.com:gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master 进入本地仓库 ，增加 xujun.txt 文件，提交，你会看到不需要再提交密码了 远程仓库 到此本篇博客为止，下一篇博客将讲解电脑怎样配置多个ssh key。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git ssh 配置及使用]]></title>
      <url>%2F2016%2F12%2F11%2FGit-ssh-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言：前几天在写博客 手把手教你用Hexo + github 搭建自己博客的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下 Git下载及配置环境变量 Git 命令行教程及实例教程 Git ssh 配置及使用 git ssh 配置多个账户 闲聊这篇教程是在电脑上已经安装好git的前提之上的，要进行以下配置，请先确保你的电脑已经安装好git。以下配置步骤是在git bash里面进行配置的，可以通过 右键》 git bash here 打开 在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。 这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。 而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例， 今天主要是讲述如何配置使用ssh方式来提交和克隆代码。 大概可以分为一下几个步骤 设置Git的user name和email：(如果是第一次的话) 检查是否已经有SSH Key。 生成密钥 添加密钥到ssh-agent 登陆Github, 添加 ssh 测试： 1、设置Git的user name和email：(如果是第一次的话)1234# 这里的“xujun&quot; 可以替换成自己的用户名git config --global user.name &quot;xujun&quot;# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱git config --global user.email &quot;gdutxiaoxu@163.com&quot; 检查是否已经有SSH Key。1 cd ~/.ssh 接着输入ls， 1ls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 生成密钥 这一步骤， 下图是存在的情况下 3、生成密钥12# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot; 连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\Users\Administrator\.ssh 4、添加密钥到ssh-agent确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5、登陆Github, 添加 ssh 。把id_rsa.pub文件里的内容复制到这里 6、测试：1ssh -T git@github.com 你将会看到： Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了。 扩展 如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。 这里同样以我本机目录下的G://test 仓库为例子， 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容 12345678910111213 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = https://github.com/gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master 将文件中的 url = https://github.com/gdutxiaoxu/test.git 更改为 url = git@github.com:gdutxiaoxu/test.git 即可。 修改后的文件如下 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = git@github.com:gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master 进入本地仓库 ，增加 xujun.txt 文件，提交，你会看到不需要再提交密码了 远程仓库 到此本篇博客为止，下一篇博客将讲解电脑怎样配置多个ssh key。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 命令行教程及实例教程]]></title>
      <url>%2F2016%2F12%2F11%2FGit-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%99%E7%A8%8B%E5%8F%8A%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言：前几天在写博客 手把手教你用Hexo + github 搭建自己博客的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下 Git下载及配置环境变量 Git 命令行教程及实例教程 Git ssh 配置及使用 git ssh 配置多个账户 本篇博客主要讲解以下问题： Git 常用命令 创建新仓库 检出仓库 添加与提交 推送改动 分支 更新与合并 标签 替换本地改动 Git实例教程 操作小技巧 Git 常用命令常用命令创建新仓库创建新文件夹，打开，然后执行 1git init 以创建新的 git 仓库。 检出仓库执行如下命令以创建一个本地仓库的克隆版本： 1git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： 1git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 添加与提交你可以计划改动（把它们添加到缓存区），使用如下命令： 12345git add &lt;filename&gt;git add *# 添加所有文件git add . 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动： 1git commit -m "代码提交信息" 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库： 1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： 123# 注意 server必须是存在的仓库git remote add origin &lt;server&gt;git remote add origin https://github.com/gdutxiaoxu/test2.git 该命令是移除本地缓存已有的remote信息 1git remote remove origin 如此你就能够将你的改动推送到所添加的服务器上去了。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支，并切换过去： 1git checkout -b feature_x 切换回主分支： 1git checkout master 切换回分支： 12git checkout &lt;branch&gt;git checkout feature_x 再把新建的分支删掉： 1git branch -d feature_x 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： 12git push origin &lt;branch&gt;git push origin feature_x 更新与合并要更新你的本地仓库至最新改动，执行： 1git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行： 12git merge &lt;branch&gt;git merge feature_x 两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功： 1git add &lt;filename&gt; 在合并改动之前，也可以使用如下命令查看： 1git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签： 1git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID： 1git log 你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动： 1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： 12git fetch origingit reset --hard origin/master 有用的贴士内建的图形化 git： 1gitk 彩色的 git 输出： 1git config color.ui true 显示历史记录时，只显示一行注释信息： 1git config format.pretty oneline 交互地添加文件至缓存区： 1git add -i 到此 git常用的命令已经 讲解完毕，下面开始讲解Git 实例教程 Git实例教程大概分为以下两步 github账号的注册与Repo的创建 实例教程 github账号的注册与Repo的创建 Github注册 打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。 然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。 一定要确认注册，否则无法使用gh-pages！ 创建代码库 登陆之后，点击页面右上角的加号，选择New repository： 新建代码库 进入代码库创建页面： 到此我们就创建好了repo，地址 为：https://github.com/gdutxiaoxu/test.git 实例教程这里我们把仓库建在 G://test 目录下 首先打开命令行，进入G 盘，输入以下命令 12# 在 test目录下创建 README.md 文件 echo "# test" &gt;&gt; README.md 接着初始化仓库 1git init 可以看到如下图片的效果 将 README.md 文件添加到版本控制 1git add README.md 提交文件到本地缓存，并添加说明 1git commit -m "first commit" 将本地仓库与远程仓库 https://github.com/gdutxiaoxu/test.git 联系起来 1git remote add origin https://github.com/gdutxiaoxu/test.git 将本地仓库缓存的文件提交到远程仓库中 1git push -u origin master 如果你没有配置ssh ，那么在这里需要输入你的github 账户的用户名和密码 正确输入你的用户名和密码后，可以看到 同时我们登陆我们的github 仓库 ： https://github.com/gdutxiaoxu/test.git ，可以看到： 说明已经提交成功了。 注意事项： 如果我们本地已经存在仓库了，那我们只需要执行以下命令就可以将我们本地仓库与远程绑定起来 1234git remote add origin https://github.com/gdutxiaoxu/test.gitgit push -u origin mastergit pull https://github.com/gdutxiaoxu/test.git master 如果本地仓库已经绑定别的远程仓库，我们可以用以下命令将其删除相应的仓库信息 12# 该命令是移除本地缓存已有的remote信息git remote remove origin 如果我们remote repo （即远端仓库已经存在了），那么我们只需要执行以下命令就OK了 1git clone https://github.com/gdutxiaoxu/test.git "you path" 比如我们想储存在 G://test 目录下，那么我们可以输入一下命令 1git clone https://github.com/gdutxiaoxu/test.git G://test 效果图如下 操作小技巧有时候在cmd 窗口中，你会发现复制，粘贴的快捷键失效了，对我们开发者来说很不方便，拿我们有什么解决方法你？ 哈哈，就是开启快速插入模式。 右键点击，点击cmd 窗口 选择快速插入模式，在Cmd 窗口，按右键，就能实现粘贴了。 同理，在git bash 窗口也是这样，这样就不在阐述了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git下载及配置环境变量]]></title>
      <url>%2F2016%2F12%2F11%2FGit%E4%B8%8B%E8%BD%BD%E5%8F%8A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[前言：前几天在写博客 手把手教你用Hexo + github 搭建自己博客的时候，经常需要用到一些git操作，截了好多图，于是就想干脆整理成一系列的git 教程，总结如下 Git下载及配置环境变量 Git 命令行教程及实例教程 Git ssh 配置及使用 git ssh 配置多个账户 下载Git安装文件： GIt官网下载地址： Git-2.6.3-64-bit.exe 然后就进入了Git的安装界面，如图： Git安装界面 和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： Git PATH设置 这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入： 1git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 Git安装界面 大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： Git PATH设置 这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入： 1git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 启动系统相机，相册，裁剪图片及6.0权限管理]]></title>
      <url>%2F2016%2F12%2F08%2FAndroid-%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%EF%BC%8C%E7%9B%B8%E5%86%8C%EF%BC%8C%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87%E5%8F%8A6-0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[在日常开发中，我们经常需要用到上传图片的 功能，这个时候通常有两种做法，第一种，从相机获取，第二种，从相册获取。今天这篇博客主要讲解利用系统的Intent怎样获取？ 主要内容如下 怎样通过相机获取我们的图片 怎样启动相册获取我们想要的图片 在Android 6.0中的动态权限处理】 调用系统Intent和自定义相册的优缺点对比 怎样通过相机获取我们的图片总共有两种方式， 第一种方式：第一步，通过 MediaStore.ACTION_IMAGE_CAPTURE 启动我们的相机 12Intent pIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//调用摄像头actionstartActivityForResult(pIntent, INTENT_CODE_IMAGE_CAPTURE1);//requestcode 第二步，在onActivityResult进行处理，，核心代码如下 123456789101112131415161718@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case INTENT_CODE_IMAGE_CAPTURE1: if (resultCode == RESULT_OK) &#123; Bundle pBundle = data.getExtras(); //从intent对象中获取数据， if (pBundle != null) &#123; Bitmap pBitmap = (Bitmap) pBundle.get("data"); if (pBitmap != null) &#123; mIv.setImageBitmap(pBitmap); &#125; &#125; &#125; break;&#125; 第二种 方式第一步，通过 MediaStore.ACTION_IMAGE_CAPTURE 启动相机，并指定 MediaStore.EXTRA_OUTPUT ，intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile)); 传入我们的URI，这样，最终返回的信息会存储在我们的mFile中。 1234567891011121314151617181920212223private void startCameraWithHighBitmap() &#123; //确定存储拍照得到的图片文件路径 if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; mFile = new File(Environment.getExternalStorageDirectory(), getName()); &#125; else &#123; Toast.makeText(this, "请插入sd卡", Toast.LENGTH_SHORT).show(); return; &#125; try &#123; mFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Intent intent = new Intent(); intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE); //加载Uri型的文件路径 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile)); //向onActivityResult发送intent，requestCode为INTENT_CODE_IMAGE_CAPTURE2 startActivityForResult(intent, INTENT_CODE_IMAGE_CAPTURE2);&#125; 第二步：在onActivityResult进行处理，并对图片进行相应的压缩，防止在大图片的情况下发生OOM 1234567case INTENT_CODE_IMAGE_CAPTURE2: if (resultCode == RESULT_OK) &#123; Bitmap bitmap = ImageZip.decodeSampledBitmapFromFile(mFile.getAbsolutePath(), mWidth, mHeight); mIv.setImageBitmap(bitmap); &#125; break; 1234567891011121314151617181920212223242526272829 public static Bitmap decodeSampledBitmapFromFile(String pathName, int reqWidth, int reqHeight) &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(pathName, options); options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false; Bitmap src = BitmapFactory.decodeFile(pathName, options);// return createScaleBitmap(src, reqWidth, reqHeight, options.inSampleSize); return src; &#125; private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // 源图片的高度和宽度 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; // Calculate the largest inSampleSize value that is a power of 2 and keeps both // height and width larger than the requested height and width. while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 两种方法的区别第一种方法获取的bitmap是被缩放的bitmap，第二种方法获取的bitmap是完整的bitmap，实际使用中根据需求情况决定使用哪一种方法。 官网参考地址 怎样启动相册获取我们想要的图片第一步，通过 Intent.ACTION_GET_CONTENT 这个Intent，并设置相应的type，启动相册。 123Intent i = new Intent(Intent.ACTION_GET_CONTENT, null);i.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "image/*");startActivityForResult(i, INTENT_CODE_IMAGE_GALLERY1); 第二步，在onActivityResult中对返回的uri数据进行处理 需要注意的是：这里我们需要注意是不是MIUI系统，如果不是MIUI系统，我们只需要进行一下处理，就OK了 12345678910111213141516171819private void setPhotoForNormalSystem(Intent data) &#123; String filePath = getRealPathFromURI(data.getData()); Bitmap bitmap = ImageZip.decodeSampledBitmapFromFile(filePath, mWidth, mHeight); mIv.setImageBitmap(bitmap);&#125;/** * 解析Intent.getdata()得到的uri为String型的filePath * * @param contentUri * @return */public String getRealPathFromURI(Uri contentUri) &#123; String[] proj = &#123;MediaStore.Audio.Media.DATA&#125;; Cursor cursor = managedQuery(contentUri, proj, null, null, null); int column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA); cursor.moveToFirst(); return cursor.getString(column_index);&#125; 如果是MIUI系统，我们需要进行一下处理 1234567891011121314151617private void setPhotoForMiuiSystem(Intent data) &#123; Uri localUri = data.getData(); String scheme = localUri.getScheme(); String imagePath = &quot;&quot;; if (&quot;content&quot;.equals(scheme)) &#123; String[] filePathColumns = &#123;MediaStore.Images.Media.DATA&#125;; Cursor c = getContentResolver().query(localUri, filePathColumns, null, null, null); c.moveToFirst(); int columnIndex = c.getColumnIndex(filePathColumns[0]); imagePath = c.getString(columnIndex); c.close(); &#125; else if (&quot;file&quot;.equals(scheme)) &#123;//小米4选择云相册中的图片是根据此方法获得路径 imagePath = localUri.getPath(); &#125; Bitmap bitmap = ImageZip.decodeSampledBitmapFromFile(imagePath, mWidth, mHeight); mIv.setImageBitmap(bitmap);&#125; 在代码中的体现如下，即判断是否是MIUI系统，对于不同的系统采用不同的方法 1234567891011121314151617@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode != RESULT_OK) &#123; return; &#125; switch (requestCode) &#123; case INTENT_CODE_IMAGE_GALLERY1: if (SystemUtils.isMIUI()) &#123; setPhotoForMiuiSystem(data); &#125; else &#123; setPhotoForNormalSystem(data); &#125; break; &#125;&#125; Android6.0动态权限管理我们知道在Android6.0以上的系统，有一些权限需要动态授予 123456789101112131415161718192021222324252627282930313233343536373839404142group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTSgroup:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAILgroup:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDARgroup:android.permission-group.CAMERA permission:android.permission.CAMERAgroup:android.permission-group.SENSORS permission:android.permission.BODY_SENSORSgroup:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATIONgroup:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGEgroup:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIOgroup:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS 我们这里容易 得知读取相机需要的权限有，写sd卡权限，读取camera权限，这两个权限都需要动态授予。 这里我们以检查是否授予camera权限为例子讲解第一步，在启动相机的时候检查时候已经授予camera权限，没有的话 ，请求camera权限 12345678910111213141516171819202122232425262728293031323334353637if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) &#123;//还没有授予权限 if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#123; Toast.makeText(this, &quot;您已禁止该权限，需要重新开启。&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;permission&#125;, request_camera2); &#125;&#125;else&#123;// 已经授予权限 startCameraWithHighBitmap();&#125;private void startCameraWithHighBitmap() &#123; //确定存储拍照得到的图片文件路径 if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; mFile = new File(Environment.getExternalStorageDirectory(), getName()); &#125; else &#123; Toast.makeText(this, &quot;请插入sd卡&quot;, Toast.LENGTH_SHORT).show(); return; &#125; try &#123; mFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Intent intent = new Intent(); intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE); //加载Uri型的文件路径 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mFile)); //向onActivityResult发送intent，requestCode为INTENT_CODE_IMAGE_CAPTURE2 startActivityForResult(intent, INTENT_CODE_IMAGE_CAPTURE2);&#125; 第二步:重写onRequestPermissionsResult方法，判断是否授权成功，成功的话启动相机，核心代码如下。 12345678910111213141516171819@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case request_camera2: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; startCameraWithHighBitmap(); &#125; else &#123; // Permission Denied Toast.makeText(this, &quot;Permission Denied&quot;, Toast .LENGTH_SHORT).show(); &#125; break; &#125;&#125; 至于检查sd卡写权限的，这里不再阐述，有兴趣的话，可以下载源码看一下。 关于Android6.0动态获取权限的，可以参考这一篇博客在Android 6.0 设备上动态获取权限 调用系统Intent和自定义相册的优缺点对比调用系统Intent启动相册优点： 代码简洁 缺点：对于不同的手机厂商，room往往被修改了，有时候调用系统的Intent，会有一些一项不到的bug， 不能实现多张图片的选择 自定义相册优点： 实现的样式可以自己定制，可以实现多张图片的选择等 缺点： 代码量稍微多一些 总结综上所述，对于本地相册的功能，本人还是强烈推荐自己实现，因为采用系统的，灵活性差，更重要的是，经常会有一些 莫名其妙的bug 这里给大家推荐两种实现方式，一个是鸿洋大神以前写的，一个是GitHub的开源库。 Android 超高仿微信图片选择器 图片该这么加载 Android仿微信图片上传，可以选择多张图片，缩放预览，拍照上传等 android-multiple-images-selector 裁剪图片关于裁剪图片的Intent，网上的大多数做法是 123456789101112131415161718192021222324252627282930public static Intent cropPic(Uri imageUri) &#123; Intent intent = new Intent("com.android.camera.action.CROP"); intent.putExtra("crop", "true"); // 设置x,y的比例，截图方框就按照这个比例来截 若设置为0,0，或者不设置 则自由比例截图 intent.putExtra("aspectX", 2); intent.putExtra("aspectY", 1); // 裁剪区的宽和高 其实就是裁剪后的显示区域 若裁剪的比例不是显示的比例， // 则自动压缩图片填满显示区域。若设置为0,0 就不显示。若不设置，则按原始大小显示 intent.putExtra("outputX", 200); intent.putExtra("outputY", 100); // 不知道有啥用。。可能会保存一个比例值 需要相关文档啊 intent.putExtra("scale", true); // true的话直接返回bitmap，可能会很占内存 不建议 intent.putExtra("return-data", false); // 上面设为false的时候将MediaStore.EXTRA_OUTPUT即"output"关联一个Uri intent.putExtra("output", imageUri); // 看参数即可知道是输出格式 intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString()); // 面部识别 这里用不上 intent.putExtra("noFaceDetection", false); return intent;&#125; 当你运行代码的时候，部分设备会报错，大致的意思是：com.android.camera.action.CROP 的Activity not found 解决方法，我们可以捕获一下异常，防止发生崩溃，并弹出吐司提醒用户不支持裁剪功能。 12345678try&#123; Intent intent = IntentUtils.cropPic(Uri.fromFile(mF)); startActivityForResult(intent,req_crop);&#125;catch(ActivityNotFoundException a)&#123; String errorMessage = "Your device doesn't support the crop action!"; Toast toast = Toast.makeText(this, errorMessage, Toast.LENGTH_SHORT); toast.show();&#125; 当然，github上面有两个比较好的开源库 android-crop cropper 文章首发地址CSDN：http://blog.csdn.net/gdutxiaoxu/article/details/53411790 源码下载地址：http://download.csdn.net/detail/gdutxiaoxu/9698246]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit使用教程（一）- Retrofit入门详解]]></title>
      <url>%2F2016%2F12%2F08%2FRetrofit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89-Retrofit%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Retrofit使用教程（一）- Retrofit入门详解 转载请注明博客地址：http://blog.csdn.net/gdutxiaoxu/article/details/52745491 源码下载地址：https://github.com/gdutxiaoxu/RetrofitDemo.git 本人已经好久没有更新 博客了，这次更新博客打算写一下retrofit的使用教程系列的 博客，写作思路大概如下 先从retrofit的基本使用讲起; 接着将retrofit结合RxJava的使用; 接着讲Retrofit的封装使用，（包括错误统一处理）; 有时间和能力的话会尝试研究一下retrofit的 源码. 本篇博客主要讲解以下问题 Retrofit简介 Retrofit的简单使用例子 Retrofit的get请求 Retrofit的put请求（提交表单数据） 如何为 retrofit添加header 如何提交json数据 Retrofit简介Retrofit是square开源的网络请求库，底层是使用OKHttp封装的，网络请求速度很快. 主要有一下几种请求方法 格式 含义 @GET 表示这是一个GET请求 @POST 表示这个一个POST请求 @PUT 表示这是一个PUT请求 @DELETE 表示这是一个DELETE请求 @HEAD 表示这是一个HEAD请求 @OPTIONS 表示这是一个OPTION请求 @PATCH 表示这是一个PAT请求 各种请求注解的意思 格式 含义 @Headers 添加请求头 @Path 替换路径 @Query 替代参数值，通常是结合get请求的 @FormUrlEncoded 用表单数据提交 @Field 替换参数值，是结合post请求的 Retrofit的简单使用例子要使用retrofit请求网络数据，大概可以分为以下几步 1)添加依赖，这里以AndroidStudio为例：在build.grale添加如下依赖 12 compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0' 2） 创建Retrofit对象 123456Retrofit retrofit = new Retrofit.Builder() //使用自定义的mGsonConverterFactory .addConverterFactory(GsonConverterFactory.create()) .baseUrl("http://apis.baidu.com/txapi/") .build();mApi = retrofit.create(APi.class); 3）发起网络请求 12345678910111213mApi = retrofit.create(APi.class);Call&lt;News&gt; news = mApi.getNews("1", "10");news.enqueue(new Callback&lt;News&gt;() &#123; @Override public void onResponse(Call&lt;News&gt; call, Response&lt;News&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;News&gt; call, Throwable t) &#123; &#125;&#125;); 123456public interface APi &#123; @Headers("apikey:81bf9da930c7f9825a3c3383f1d8d766") @GET("word/word") Call&lt;News&gt; getNews(@Query("num") String num,@Query("page")String page);&#125; 到此一个简单的使用retrofit的网络请求就完成了。接下来我们来了解retrofit的各种请求方式。 Retrofit的get请求加入我们想请求这样的网址：http://apis.baidu.com/txapi/world/world?num=10&amp;page=1，header为&quot;apikey:81bf9da930c7f9825a3c3383f1d8d766&quot;,我们可以这样请求： 第一步，在interface Api中 增加如下方法1234@Headers("apikey:81bf9da930c7f9825a3c3383f1d8d766")@GET("word/word")Call&lt;News&gt; getNews(@Query("num") String num,@Query("page")String page); 第二部，在代码里面请求123456789101112131415161718192021222324//创建retrofit对象Retrofit retrofit = new Retrofit.Builder() //使用自定义的mGsonConverterFactory .addConverterFactory(GsonConverterFactory.create()) .baseUrl("http://apis.baidu.com/txapi/") .build();// 实例化我们的mApi对象mApi = retrofit.create(APi.class); // 调用我们的响应的方法Call&lt;News&gt; news = mApi.getNews(number, page);news.enqueue(new Callback&lt;News&gt;() &#123; @Override public void onResponse(Call&lt;News&gt; call, Response&lt;News&gt; response) &#123; News body = response.body(); Logger.i("onResponse: ="+body.toString()); &#125; @Override public void onFailure(Call&lt;News&gt; call, Throwable t) &#123; Logger.i("onResponse: ="+t.getMessage()); &#125;&#125;); 解释说明假设BaseUrl是http://apis.baidu.com/txapi/的前提下 1）其中 @GET(“word/word”)会追加到baseUrl ：http://apis.baidu.com/txapi/的后面，即变成：http://apis.baidu.com/txapi/world/world 2）@Query(“num”) String num,@Query(“page”)String page；分别对应键值的名称与值。会追加到http://apis.baidu.com/txapi/world/world的后面，请求网址即变成:http://apis.baidu.com/txapi/world/world?num=10&amp;page=1 3） @Headers(“apikey:81bf9da930c7f9825a3c3383f1d8d766”)是 在基础之上为 其添加响应头 4）如果想继续增加参数，只需要在方法参数追加这样的形式就OK了：,@Query(“page”)String page 123@Headers("apikey:81bf9da930c7f9825a3c3383f1d8d766")@GET("word/word")Call&lt;News&gt; getNews(@Query("num") String num,@Query("page")String page，@Query("type") String type); 5)加入我们想要请求这样的网址http://apis.baidu.com/txapi/tiyu/tiyu?num=10&amp;page=1，,我们可以这样写 12345 @Headers(&#123;"apikey:81bf9da930c7f9825a3c3383f1d8d766" ,"Content-Type:application/json"&#125;)@GET("&#123;type&#125;/&#123;type&#125;")Call&lt;News&gt; tiYu(@Path("type") String type, @Query("num") String num,@Query("page")String page);String type="tiyu";Call&lt;News&gt; news = api.tiYu(type,number, page); retrofit的post请求假如我们想要 请求这样的网址http://apis.baidu.com/txapi/world/world?以post的 方式提交这样的 数据：num=10&amp;page=1，我们可以写成 如下的 样子，注意post的时候必须使用@Field这种形式的注解，而不是使用@Query这种形式的注解，其他的 与get请求一样，这样只给出核心代码 1234@FormUrlEncoded@Headers(&#123;"apikey:81bf9da930c7f9825a3c3383f1d8d766" ,"Content-Type:application/json"&#125;)@POST("world/world")Call&lt;News&gt; postNews(@Field("num") String num, @Field("page")String page); 如何为retrofit添加请求头head总共有以下几种方式 第一种方法在OKHttpClient interceptors里面进行处理，这样添加的headKey不会覆盖掉 前面的 headKey 1234567891011121314okHttpClient.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request original = chain.request(); // Request customization: add request headers Request.Builder requestBuilder = original.newBuilder() .addHeader("header-key", "value1") .addHeader("header-key", "value2"); Request request = requestBuilder.build(); return chain.proceed(request); &#125;&#125;); 第二种方法同样在在OKHttpClient interceptors里面进行处理，这样添加的headKey会覆盖掉 前面的 headKey12345678910111213okHttpClient.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request original = chain.request(); // Request customization: add request headers Request.Builder requestBuilder = original.newBuilder() .header("headerkey", "header-value"); // &lt;-- this is the important line Request request = requestBuilder.build(); return chain.proceed(request); &#125;&#125;); 第三种方法利用 retrofit自带的注解，比如我们想要添加这样的请求头：”apikey:81bf9da930c7f9825a3c3383f1d8d766” ,”Content-Type:application/json”；则可以写成如下的 样式 123@Headers(&#123;"apikey:81bf9da930c7f9825a3c3383f1d8d766" ,"Content-Type:application/json"&#125;)@GET("world/world")Call&lt;News&gt; getNews(@Query("num") String num,@Query("page")String page); 通过post提交json数据Post 提交JSON数据 有时提交的数据量比较大时，用键值对的方式提交参数不太方便，Retrofit可以通过@Body注释，直接传递一个对象给请求主体，Retrofit通过JSON转化器，把对象映射成JSON数据。 假设我们需要提交的数据为1234&#123; "id": 1, "text": "my task title"&#125; 接口定义： 12345public interface TaskService &#123; @Headers(&#123;"Content-Type: application/json","Accept: application/json"&#125;) @POST("/tasks") Call&lt;Task&gt; createTask(@Body Task task);&#125; 传递实体需要有Model： 12345678910public class Task &#123; private long id; private String text; public Task() &#123;&#125; public Task(long id, String text) &#123; this.id = id; this.text = text; &#125;&#125; 客户端调用： 123Task task = new Task(1, "my task title"); Call&lt;Task&gt; call = taskService.createTask(task); call.enqueue(new Callback&lt;Task&gt;() &#123;&#125;); 这样，服务端得到的是JOSN数据： 1234&#123; "id": 1, "text": "my task title"&#125; 到此，这篇博客为止 题外话：其实retrofit在5月份实习的时候就接触了，之前为什么不写 博客了，因为网上的 使用教程很多，觉得没有必要。到后面学习的时候，发现retrofit的使用时 比较灵活的，并且使用方法也是相对较多的，于是，就写了retrofit这系列的使用博客。 转载请注明博客地址：http://blog.csdn.net/gdutxiaoxu/article/details/52745491 源码下载地址：https://github.com/gdutxiaoxu/RetrofitDemo.git 参考官网地址http://square.github.io/retrofit/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用的自定义View例子一(FlowLayout)]]></title>
      <url>%2F2016%2F12%2F08%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%BE%8B%E5%AD%90%E4%B8%80-FlowLayout%2F</url>
      <content type="text"><![CDATA[常用的自定义View例子一（ FlowLayout）在Android开发中，我们经常会遇到流布式的布局，经常会用来一些标签的显示，比如qq中个人便签，搜索框下方提示的词语，这些是指都是流布式的布局，今天我就我们日常开放中遇到的流布式布局坐一些总结 转载请注明博客地址：http://blog.csdn.net/gdutxiaoxu/article/details/51765428 源码下载地址：https://github.com/gdutxiaoxu/CustomViewDemo.git 1. 先给大家看一下效果 图一 图二 仔细观察，我们可以知道图二其实是图一效果的升级版，图一当我们控件的宽度超过这一行的时候，剩余的宽度它不会自动分布到每个控件中，而图二的效果当我们换行的时候，如控件还没有占满这一行的时候，它会自动把剩余的宽度分布到每个控件中 2.废话不多说了，大家来直接看来看一下图一的源码1）代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * 博客地址：http://blog.csdn.net/gdutxiaoxu * @author xujun * @time 2016/6/20 23:49. */public class SimpleFlowLayout extends ViewGroup &#123; private int verticalSpacing = 20; public SimpleFlowLayout(Context context ) &#123; super(context); &#125; /** * 重写onMeasure方法是为了确定最终的大小 * @param widthMeasureSpec * @param heightMeasureSpec */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom();//处理Padding属性，让当前的ViewGroup支持Padding int widthUsed = paddingLeft + paddingRight; int heightUsed = paddingTop + paddingBottom; int childMaxHeightOfThisLine = 0; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() != GONE) &#123;// 已用的宽度 int childUsedWidth = 0;// 已用的高度 int childUsedHeight = 0;// 调用ViewGroup自身的方法测量孩子的宽度和高度，我们也可以自己根据MeasureMode来测量 measureChild(child,widthMeasureSpec,heightMeasureSpec); childUsedWidth += child.getMeasuredWidth(); childUsedHeight += child.getMeasuredHeight();//处理Margin，支持孩子的Margin属性 Rect marginRect = getMarginRect(child); int leftMargin=marginRect.left; int rightMargin=marginRect.right; int topMargin=marginRect.top; int bottomMargin=marginRect.bottom; childUsedWidth += leftMargin + rightMargin; childUsedHeight += topMargin + bottomMargin;//总宽度没有超过本行 if (widthUsed + childUsedWidth &lt; widthSpecSize) &#123; widthUsed += childUsedWidth; if (childUsedHeight &gt; childMaxHeightOfThisLine) &#123; childMaxHeightOfThisLine = childUsedHeight; &#125; &#125; else &#123;//总宽度已经超过本行 heightUsed += childMaxHeightOfThisLine + verticalSpacing; widthUsed = paddingLeft + paddingRight + childUsedWidth; childMaxHeightOfThisLine = childUsedHeight; &#125; &#125; &#125;//加上最后一行的最大高度 heightUsed += childMaxHeightOfThisLine; setMeasuredDimension(widthSpecSize, heightUsed); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); /** * 为了 支持Padding属性 */ int childStartLayoutX = paddingLeft; int childStartLayoutY = paddingTop; int widthUsed = paddingLeft + paddingRight; int childMaxHeight = 0; int childCount = getChildCount();//摆放每一个孩子的高度 for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; int childNeededWidth, childNeedHeight; int left, top, right, bottom; int childMeasuredWidth = child.getMeasuredWidth(); int childMeasuredHeight = child.getMeasuredHeight(); Rect marginRect = getMarginRect(child); int leftMargin=marginRect.left; int rightMargin=marginRect.right; int topMargin=marginRect.top; int bottomMargin=marginRect.bottom; childNeededWidth = leftMargin + rightMargin + childMeasuredWidth; childNeedHeight = topMargin + topMargin + childMeasuredHeight;// 没有超过本行 if (widthUsed + childNeededWidth &lt;= r - l) &#123; if (childNeedHeight &gt; childMaxHeight) &#123; childMaxHeight = childNeedHeight; &#125; left = childStartLayoutX + leftMargin; top = childStartLayoutY + topMargin; right = left + childMeasuredWidth; bottom = top + childMeasuredHeight; widthUsed += childNeededWidth; childStartLayoutX += childNeededWidth; &#125; else &#123; childStartLayoutY += childMaxHeight + verticalSpacing; childStartLayoutX = paddingLeft; widthUsed = paddingLeft + paddingRight; left = childStartLayoutX + leftMargin; top = childStartLayoutY + topMargin; right = left + childMeasuredWidth; bottom = top + childMeasuredHeight; widthUsed += childNeededWidth; childStartLayoutX += childNeededWidth; childMaxHeight = childNeedHeight; &#125; child.layout(left, top, right, bottom); &#125; &#125; &#125; private Rect getMarginRect(View child) &#123; LayoutParams layoutParams = child.getLayoutParams(); int leftMargin = 0; int rightMargin = 0; int topMargin = 0; int bottomMargin = 0; if (layoutParams instanceof MarginLayoutParams) &#123; MarginLayoutParams marginLayoutParams = (MarginLayoutParams) layoutParams; leftMargin = marginLayoutParams.leftMargin; rightMargin = marginLayoutParams.rightMargin; topMargin = marginLayoutParams.topMargin; bottomMargin = marginLayoutParams.bottomMargin; &#125; return new Rect(leftMargin, topMargin, rightMargin, bottomMargin); &#125;&#125; 2）思路解析 首先我们重写onMeasure方法，在OnMeasure方法里面我们调用measureChild（）这个方法去获取每个孩子的宽度和高度，每次增加一个孩子我们执行 widthUsed += childUsedWidth; 添加完一个孩子以后我们判断widthUsed是够超出控件本身的最大宽度widthSpecSize，若没有超过执行 widthUsed += childUsedWidth; if (childUsedHeight &gt; childMaxHeightOfThisLine) { childMaxHeightOfThisLine = childUsedHeight; } 超过控件的宽度执行 heightUsed += childMaxHeightOfThisLine + verticalSpacing; widthUsed = paddingLeft + paddingRight + childUsedWidth; childMaxHeightOfThisLine = childUsedHeight; 最后调用 setMeasuredDimension(widthSpecSize, heightUsed);这个方法去设置它的大小3.在OnLayout方法里面，所做的工作就是去摆放每一个孩子的位置 ，判断需不需要换行，不需要更改left值，需要换行，更改top值 3）注意事项讲解之前，我们先来了解一下一个基本知识 从这张图片里面我们可以得出这样结论 Width=控件真正的宽度（realWidth）+PaddingLeft+PaddingRight margin是子控件相对于父控件的距离 注意事项 为了支持控件本身的padding属性，我们做了处理，主要代码如下 123456789int widthUsed = paddingLeft + paddingRight;int heightUsed = paddingTop + paddingBottom; ---------- if (widthUsed + childUsedWidth &lt; widthSpecSize) &#123; widthUsed += childUsedWidth; if (childUsedHeight &gt; childMaxHeightOfThisLine) &#123; childMaxHeightOfThisLine = childUsedHeight; &#125; &#125; 为了支持子控件的margin属性，我们同样也做了处理 12345678Rect marginRect = getMarginRect(child);int leftMargin=marginRect.left;int rightMargin=marginRect.right;int topMargin=marginRect.top;int bottomMargin=marginRect.bottom; childUsedWidth += leftMargin + rightMargin;childUsedHeight += topMargin + bottomMargin; 即我们在计算孩子所占用的宽度和高度的时候加上margin属性的高度，接着在计算需要孩子总共用的宽高度的时候加上每个孩子的margin属性的宽高度，这样自然就支持了孩子的margin属性了 4.缺陷如下图所见，在控件宽度参差不齐的情况下，控件换行会留下一些剩余的宽度，作为想写出鲁棒性的代码的我们会觉得别扭，于是我们相处了解决办法。 解决方法见下面 图二源码解析 废话不多说，先看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/** * 博客地址：http://blog.csdn.net/gdutxiaoxu * @author xujun * @time 2016/6/26 22:54. */public class PrefectFlowLayout extends ViewGroup &#123; public PrefectFlowLayout(Context context) &#123; super(context); &#125; public PrefectFlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public PrefectFlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; //父容器宽度 private int parentWidthSize; //水平间距 private int horizontalSpacing = 16; //垂直间距 private int verticalSpacing = 16; //当前行 private Line currentLine; //所有行的集合 private List&lt;Line&gt; mLines = new ArrayList&lt;&gt;(); //当前行已使用宽度 private int userWidth = 0; /** * 行对象 */ private class Line &#123; //一行里面所添加的子View集合 private List&lt;View&gt; children; //当前行高度 private int height; //当前行已使用宽度 private int lineWidth = 0; public Line() &#123; children = new ArrayList&lt;&gt;(); &#125; /** * 添加一个子控件 * * @param child */ private void addChild(View child) &#123; children.add(child); if (child.getMeasuredHeight() &gt; height) &#123; //当前行高度以子控件最大高度为准 height = child.getMeasuredHeight(); &#125; //将每个子控件宽度进行累加，记录使用的宽度 lineWidth += child.getMeasuredWidth(); &#125; /** * 获取行的高度 * * @return */ public int getHeight() &#123; return height; &#125; /** * 获取子控件的数量 * * @return */ public int getChildCount() &#123; return children.size(); &#125; /** * 放置每一行里面的子控件的位置 * * @param l 距离最左边的距离 * @param t 距离最顶端的距离 */ public void onLayout(int l, int t) &#123; //当前行使用的宽度，等于每个子控件宽度之和+子控件之间的水平距离 lineWidth += horizontalSpacing * (children.size() - 1); int surplusChild = 0; int surplus = parentWidthSize - lineWidth;//剩余宽度 if (surplus &gt; 0) &#123; //如果有剩余宽度，则将剩余宽度平分给每一个子控件 surplusChild = (int) (surplus / children.size()+0.5); &#125; for (int i = 0; i &lt; children.size(); i++) &#123; View child = children.get(i); child.getLayoutParams().width=child.getMeasuredWidth()+surplusChild; if (surplusChild&gt;0)&#123; //如果长度改变了后，需要重新测量，否则布局中的属性大小还会是原来的大小 child.measure(MeasureSpec.makeMeasureSpec( child.getMeasuredWidth()+surplusChild,MeasureSpec.EXACTLY) ,MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY)); &#125; child.layout(l, t, l + child.getMeasuredWidth(), t + child.getMeasuredHeight()); l += child.getMeasuredWidth() + horizontalSpacing; &#125; &#125; &#125; // getMeasuredWidth() 控件实际的大小 // getWidth() 控件显示的大小 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //将之前测量的数据进行清空，以防复用时影响下次测量 mLines.clear(); currentLine = null; userWidth = 0; //获取父容器的宽度和模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); parentWidthSize = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight(); //获取父容器的高度和模式 int heigthMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec) - getPaddingTop() - getPaddingBottom(); int childWidthMode, childHeightMode; //为了测量每个子控件，需要指定每个子控件的测量规则 //子控件设置为WRAP_CONTENT，具体测量规则详见，ViewGroup的getChildMeasureSpec()方法 if (widthMode == MeasureSpec.EXACTLY) &#123; childWidthMode = MeasureSpec.AT_MOST; &#125; else &#123; childWidthMode = widthMode; &#125; if (heigthMode == MeasureSpec.EXACTLY) &#123; childHeightMode = MeasureSpec.AT_MOST; &#125; else &#123; childHeightMode = heigthMode; &#125; //获取到子控件高和宽的测量规则 int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(parentWidthSize, childWidthMode); int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(heightSize, childHeightMode); currentLine = new Line();//创建第一行 for (int i = 0; i &lt; getChildCount(); i++) &#123; View child = getChildAt(i); //测量每一个孩子 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); //获取当前子控件的实际宽度 int childMeasuredWidth = child.getMeasuredWidth(); //让当前行使用宽度加上当前子控件宽度 userWidth += childMeasuredWidth; if (userWidth &lt;= parentWidthSize) &#123; //如果当前行使用宽度小于父控件的宽度，则加入该行 currentLine.addChild(child); //当前行使用宽度加上子控件之间的水平距离 userWidth += horizontalSpacing; //如果当前行加上水平距离后超出父控件宽度,则换行 if (userWidth &gt; parentWidthSize) &#123; newLine(); &#125; &#125; else &#123; //以防出现一个子控件宽度超过父控件的情况出现 if (currentLine.getChildCount() == 0) &#123; currentLine.addChild(child); &#125; newLine(); //并将超出范围的当前的子控件加入新的行中 currentLine.addChild(child); //并将使用宽度加上子控件的宽度; userWidth = child.getMeasuredWidth()+horizontalSpacing; &#125; &#125; //加入最后一行，因为如果最后一行宽度不足父控件宽度时，就未换行 if (!mLines.contains(currentLine)) &#123; mLines.add(currentLine); &#125; int totalHeight = 0;//总高度 for (Line line : mLines) &#123; //总高度等于每一行的高度+垂直间距 totalHeight += line.getHeight() + verticalSpacing; &#125; //resolveSize(),将实际高度与父控件高度进行比较，选取最合适的 setMeasuredDimension(parentWidthSize + getPaddingLeft() + getPaddingRight(), resolveSize(totalHeight + getPaddingTop() + getPaddingBottom(), heightMeasureSpec)); &#125; /** * 换行 */ private void newLine() &#123; mLines.add(currentLine);//记录之前行 currentLine = new Line();//重新创建新的行 userWidth = 0;//将使用宽度初始化 &#125; /** * 放置每个子控件的位置 * * @param changed * @param l * @param t * @param r * @param b */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; l += getPaddingLeft(); t += getPaddingTop(); for (int i = 0; i &lt; mLines.size(); i++) &#123; Line line = mLines.get(i); //设置每一行的位置，每一行的子控件由其自己去分配 line.onLayout(l, t); //距离最顶端的距离，即每一行高度和垂直间距的累加 t += line.getHeight() + verticalSpacing; &#125; &#125; /** * 获取子控件的测量规则 * * @param mode 父控件的测量规则 * @return 子控件设置为WRAP_CONTENT，具体测量规则详见，ViewGroup的getChildMeasureSpec()方法 */ private int getMode(int mode) &#123; int childMode = 0; if (mode == MeasureSpec.EXACTLY) &#123; childMode = MeasureSpec.AT_MOST; &#125; else &#123; childMode = mode; &#125; return childMode; &#125;&#125; 2.思路解析 对比图一的实现思路，我们封装了Line这个内部类，看到这个名字，相信大家都猜到是什么意思了，其实就是一个Line实例对象代表一行，Line里面的List children用来存放孩子 private List&lt;View&gt; children;//一行里面所添加的子View集合 Line里面还封装了void onLayout(int l, int t)方法，即自己去拜访每个孩子的位置，实现剩余的宽度平均分配，主要体现在这几行代码12345678910 if (surplus &gt; 0) &#123; //如果有剩余宽度，则将剩余宽度平分给每一个子控件 surplusChild = (int) (surplus / children.size()+0.5); &#125; -------//重新分配每个孩子的大小 child.measure(MeasureSpec.makeMeasureSpec( child.getMeasuredWidth()+surplusChild,MeasureSpec.EXACTLY) ,MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY)); 今天就写到这里了，有时间再来补充，最近考试比较忙，已经好久没有更新博客了。源码下载地址：https://github.com/gdutxiaoxu/CustomViewDemo.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[360面试心得（Android)]]></title>
      <url>%2F2016%2F12%2F08%2F360%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97%EF%BC%88Android%2F</url>
      <content type="text"><![CDATA[360面试心得（Android） 这次360面试，总共面试了两轮，都是视频面试。 时间:2016-08-23 转载请注明原博客地址： 闲谈： 从大二暑假的时候开始，一直想进腾讯或者阿里，在招实习生的时候，最终遗憾落选。暑假的时候为了好好准备校招，我放弃了去步步高实习的机会，继续在原来的一家公司实习。在暑假的时候找师兄师姐内推了腾讯，阿里，最终都没有通过简历筛选，没有面试。说实话，刚开始内心是挺失落的，挺难受的，但经过一两天的调整，我也意识到自己的错误，以前那种强烈想进bat的欲望渐渐淡了下来，当然并不是说不想进bat，只是不再那么注重结果，更注重这奋斗过程中个人的成长。 360一面差不多三十五分钟 介绍你做过的项目 手写单例模式 布局优化 有没有用过什么开源框架？ ImagLoader的实现原理 OnTouchEvent事件中 down事件 和up事件的传递 hashMap的实现 原理 LinkedHashMap的实现原理 内存管理及优化 点九图 点九图https://isux.tencent.com/android-ui-9-png.html 放大后可以比较明显的看到上下左右分别有一个像素的黑色线段，这里分别标注了序号。简单来说， 序号1和2标识了可以拉伸的区域， 序号3和4标识了内容区域。当设定了按钮实际应用的宽和高之后，横向会拉伸1区域的像素，纵向会拉伸2区域的像素。如下图： 这里程序设置的文字垂直居中，水平居左的对齐方式。对齐方式是没有问题的，但是对于这种大圆角同时又有些不规则边框的的图形来说，错误的标注方式会让排版看起来很混乱。所以我们需要修正内容区域的线段位置和长度。 有两点需要特别注意下：1.最外围的一圈像素必须要么是纯黑色，要么是透明，一点点的半透明的像素都不可以有，比如说99%的黑色或者是1%的投影都不可以有; 2.文件的后缀名必须是.9.png，不能是.png或者是.9.png.png，这样的命名都会导致编译失败。 内存管理及优化我这里答的是内存泄漏和oom少用static静态变量 1) 珍惜Services资源 我们知道service所在的Activity级别相对后台Activity的级别是比较 高的，一般不易被回收。在service不再使用的时候，及时退出。最好的方法是使用IntentService 2）在UI不可见的时候释放资源 当用户切换到其它应用并且你的应用 UI不再可见时，你应该释放你的应用UI上所占用的所有内存资源。在这个时候释放UI资源可以显著的增加系统缓存进程的能力，它会对用户体验有着很直接的影响。 为了能够接收到用户离开你的UI时的通知，你需要实现Activtiy类里面的onTrimMemory()回调方法。你应该使用这个方法来监听到TRIM_MEMORY_UI_HIDDEN级别的回调，此时意味着你的UI已经隐藏，你应该释放那些仅仅被你的UI使用的资源。 请注意：你的应用仅仅会在所有UI组件的被隐藏的时候接收到onTrimMemory()的回调并带有参数TRIM_MEMORY_UI_HIDDEN。这与onStop()的回调是不同的，onStop会在activity的实例隐藏时会执行，例如当用户从你的app的某个activity跳转到另外一个activity时前面activity的onStop()会被执行。因此你应该实现onStop回调，并且在此回调里面释放activity的资源，例如释放网络连接，注销监听广播接收者。除非接收到onTrimMemory(TRIM_MEMORY_UI_HIDDEN))的回调，否者你不应该释放你的UI资源。这确保了用户从其他activity切回来时，你的UI资源仍然可用，并且可以迅速恢复activity。 3) 当内存紧张时释放部分内存 关于onTrimMemory的介绍 在你的app生命周期的任何阶段，onTrimMemory的回调方法同样可以告诉你整个设备的内存资源已经开始紧张。你应该根据onTrimMemory回调中的内存级别来进一步决定释放哪些资源。 TRIM_MEMORY_RUNNING_MODERATE：你的app正在运行并且不会被列为可杀死的。但是设备此时正运行于低内存状态下，系统开始触发杀死LRU Cache中的Process的机制。TRIM_MEMORY_RUNNING_LOW：你的app正在运行且没有被列为可杀死的。但是设备正运行于更低内存的状态下，你应该释放不用的资源用来提升系统性能（但是这也会直接影响到你的app的性能）。TRIM_MEMORY_RUNNING_CRITICAL：你的app仍在运行，但是系统已经把LRU Cache中的大多数进程都已经杀死，因此你应该立即释放所有非必须的资源。如果系统不能回收到足够的RAM数量，系统将会清除所有的LRU缓存中的进程，并且开始杀死那些之前被认为不应该杀死的进程，例如那个包含了一个运行态Service的进程。同样，当你的app进程正在被cached时，你可能会接受到从onTrimMemory()中返回的下面的值之一: TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。TRIM_MEMORY_COMPLETE: 系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源。因为onTrimMemory()的回调是在API 14才被加进来的，对于老的版本，你可以使用onLowMemory)回调来进行兼容。onLowMemory相当与TRIM_MEMORY_COMPLETE。 Note: 当系统开始清除LRU缓存中的进程时，尽管它首先按照LRU的顺序来操作，但是它同样会考虑进程的内存使用量。因此消耗越少的进程则越容易被留下来。 4) 避免bitmaps的浪费 当你加载一个bitmap时，仅仅需要保留适配当前屏幕设备分辨率的数据即可，如果原图高于你的设备分辨率，需要做缩小的动作。请记住，增加bitmap的尺寸会对内存呈现出2次方的增加，因为X与Y都在增加。 Note:在Android 2.3.x (API level 10)及其以下, bitmap对象的pixel data是存放在native内存中的，它不便于调试。然而，从Android 3.0(API level 11)开始，bitmap pixel data是分配在你的app的Dalvik heap中, 这提升了GC的工作效率并且更加容易Debug。因此如果你的app使用bitmap并在旧的机器上引发了一些内存问题，切换到3.0以上的机器上进行Debug。 5) 使用优化的数据容器 利用Android Framework里面优化过的容器类，例如SparseArray, SparseBooleanArray, 与 LongSparseArray。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。 6) 请注意内存开销 对你所使用的语言与库的成本与开销有所了解，从开始到结束，在设计你的app时谨记这些信息。通常，表面上看起来无关痛痒(innocuous)的事情也许实际上会导致大量的开销。例如： Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。每一个类的实例花销是12-16 bytes。往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。7) 请注意代码“抽象” 通常，开发者使用抽象作为”好的编程实践”，因为抽象能够提升代码的灵活性与可维护性。然而，抽象会导致一个显著的开销：通常他们需要同等量的代码用于可执行。那些代码会被map到内存中。因此如果你的抽象没有显著的提升效率，应该尽量避免他们。 8) 使用ProGuard来剔除不需要的代码 ProGuard能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以使得你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。 9) 对最终的APK使用zipalign 在编写完所有代码，并通过编译系统生成APK之后，你需要使用zipalign对APK进行重新校准。如果你不做这个步骤，会导致你的APK需要更多的RAM，因为一些类似图片资源的东西不能被mapped。 Notes: Google Play不接受没有经过zipalign的APK。 360二面一面过了十多分钟以后，接着就进行二面，都是视频面试，差不多二十分钟左右 AsyncTak的原理及常用方法 APK从安装到启动的过程 平时是怎样学习的？ 学习和实习是在怎样协调的 ？ 有360手机助手有什么想了解的吗？ 对360手机助手有什么想了解的？这里我提问的是省流量升级是怎样实现的？后面追问是不是利用动态加载技术。面试官解释的是不是你，是对比版本之间的二进制文件差异。 面试总结题外话两轮面试面试官人都挺好的，都面带笑容个，感觉很好说话，当天晚上我加了面试官的微信，问他多久会出结果，面试官问我说后面有没有接到电话，我说没有，然后面试官说应该被刷了。 个人心得可能是第一次视频面试，感觉个人太紧张了，有好多原理性的东西讲着讲着就忘记讲了，面试的时候真的是太紧张了，发挥不太好，平时一定要多总结，不然面试的时候一下子总结地不太好，发挥不出应有的水平。 转载请注明原博客地址：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89Behavior-%E2%80%94%E2%80%94-%E4%BB%BF%E7%9F%A5%E4%B9%8E%EF%BC%8CFloatActionButton%E9%9A%90%E8%97%8F%E4%B8%8E%E5%B1%95%E7%A4%BA%2F</url>
      <content type="text"><![CDATA[使用CoordinatorLayout打造各种炫酷的效果 自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示 前段时间写了一篇博客使用CoordinatorLayout打造各种炫酷的效果,主要介绍了APPBarLayout和CollapsingToolbarLayout的基本用法，AppBarLayout主要用来实现在滚动的时候ToolBar的 隐藏于展示，CollapsingToolbarLayout主要用来实现parallax和pin等效果。如果你对CoordinatorLayout还不了解的话，请先阅读这篇文章。 写作思路 CoordinatorLayout Behavior 简介 怎样自定义 Behavior 仿知乎效果 自定义 Behavior 的实现 自定义 Behavior 两种方法的 对比 FloatActionButton 自定义 Behavior 效果的实现 题外话 今天就来讲解怎样通过自定义behavior来实现各种炫酷的效果 ，效果图如下 下面让我们一起来看一下怎样实现仿知乎的效果老规矩，先看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout android:id="@+id/coordinatorLayout" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/index_app_bar" theme="@style/AppTheme.AppBarOverlay" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="@color/colorPrimary" app:layout_scrollFlags="scroll|enterAlways"&gt; &lt;ImageView android:id="@+id/search" android:layout_width="24dp" android:layout_height="24dp" android:layout_centerVertical="true" android:layout_marginLeft="10dp" android:src="@drawable/search"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="10dp" android:layout_toRightOf="@id/search" android:text="搜索话题、问题或人" android:textSize="16sp"/&gt; &lt;/RelativeLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;!--使用RadioGroup来实现tab的切换--&gt; &lt;RadioGroup android:id="@+id/rg" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="bottom" android:background="@color/bg_tab" android:orientation="horizontal" app:layout_behavior="@string/behavior_footer" &gt; &lt;RadioButton android:id="@+id/rb_home" style="@style/bottom_tab" android:drawableTop="@drawable/sel_home" android:text="Home"/&gt; &lt;RadioButton android:id="@+id/rb_course" style="@style/bottom_tab" android:drawableTop="@drawable/sel_course" android:text="course"/&gt; &lt;RadioButton android:id="@+id/rb_direct_seeding" style="@style/bottom_tab" android:drawableTop="@drawable/sel_direct_seeding" android:text="direct"/&gt; &lt;RadioButton android:id="@+id/rb_me" style="@style/bottom_tab" android:drawableTop="@drawable/sel_me" android:text="me"/&gt; &lt;/RadioGroup&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 1234567891011121314151617181920&lt;style name=&quot;bottom_tab&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;0dp&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;60dp&lt;/item&gt; &lt;item name=&quot;android:layout_weight&quot;&gt;1&lt;/item&gt; &lt;item name=&quot;android:text&quot;&gt;0dp&lt;/item&gt; &lt;item name=&quot;android:gravity&quot;&gt;center&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@drawable/sel_bottom_tab_text&lt;/item&gt; &lt;item name=&quot;android:padding&quot;&gt;10dp&lt;/item&gt; &lt;item name=&quot;android:button&quot;&gt;@null&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;bottom_tab&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;0dp&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;60dp&lt;/item&gt; &lt;item name=&quot;android:layout_weight&quot;&gt;1&lt;/item&gt; &lt;item name=&quot;android:text&quot;&gt;0dp&lt;/item&gt; &lt;item name=&quot;android:gravity&quot;&gt;center&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@drawable/sel_bottom_tab_text&lt;/item&gt; &lt;item name=&quot;android:padding&quot;&gt;10dp&lt;/item&gt; &lt;item name=&quot;android:button&quot;&gt;@null&lt;/item&gt;&lt;/style&gt; 思路分析根据动态如可以看到，主要有两个效果 上面的AppBarLayout 向上滑动的时候会隐藏，向下滑动的时候会展示，说白了就是给APPLayout的子View Relativelayout 设置 app:layout_scrollFlags=”scroll|enterAlways”，核心代码如下 123456789101112131415161718&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/index_app_bar&quot; theme=&quot;@style/AppTheme.AppBarOverlay&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt; ---- &lt;/RelativeLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 下面的 RadioGroup ，我们可以看到，向上 滑动的时候会隐藏，向下滑动的时候会显示，其实我们只是给其设置了 behavior 而已 app:layout_behavior=”@string/behavior_footer”，那这个behavior_footer是什么东西，别急 ，下面就是介绍了 1&lt;string name=&quot;behavior_footer&quot;&gt;com.xujun.contralayout.behavior.FooterBehavior&lt;/string&gt; Behavior简介 Behavior是CoordinatorLayout里面的一个内部类，通过它我们可以与 CoordinatorLayout的一个或者多个子View进行交互，包括 drag，swipes, flings等手势动作。 今天 我们主要着重介绍里面的几个方法 方法 解释 boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) 确定child View 是否有一个特定的兄弟View作为布局的依赖（即dependency） boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) 当child View 的 dependent view 发生变化的时候，这个方法会调用 boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes) 当CoordinatorLayout 的直接或者非直接子View开始准备嵌套滑动的时候会调用 void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) 当嵌套滑动的 时候，target尝试滑动或者正在滑动的 时候会调用 关于更多方法，请参考官网文档说明 怎样自定义Behavior前面已经说到，今天主要介绍四个方法，这里我们把它分为两组。 第一组 12345// 决定child 依赖于把一个 dependencyboolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency)// 当 dependency View 改变的时候 child 要做出怎样的响应boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) 第二组 12345// 当CoordinatorLayout的直接或者非直接子View开始嵌套滑动的时候，会调用这个方法boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, V child, View directTargetChild, View target, int nestedScrollAxes)// 当嵌套滑动的时候，target 尝试滑动或者正在滑动会调用这个方法onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) 首先我们先看第一组是怎样实现的？12345678910111213141516171819202122232425262728293031/** * 知乎效果底部behavior 依赖于 AppBarLayout * * @author xujun on 2016/11/30. * @email gdutxiaoxu@163.com */public class FooterBehaviorDependAppBar extends CoordinatorLayout.Behavior&lt;View&gt; &#123; public static final String TAG = "xujun"; public FooterBehaviorDependAppBar(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; //当 dependency instanceof AppBarLayout 返回TRUE，将会调用onDependentViewChanged（）方法 @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency instanceof AppBarLayout; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; //根据dependency top值的变化改变 child 的 translationY float translationY = Math.abs(dependency.getTop()); child.setTranslationY(translationY); Log.i(TAG, "onDependentViewChanged: " + translationY); return true; &#125;&#125; 思路分析 这里我们要分清两个概念，child 和 dependency ，child 是我们要改变的坐标的view，而 dependency 是child 的 附属 ，即child 会随着 dependency 坐标的改变而改变。 比如上面的例子：当我们把 app:layout_behavior=”com.xujun.contralayout.behavior.FooterBehaviorDependAppBar” 设置给 RadioGroup 的时候，这时候 child 就是 RadioGroup ，而 dependency 就是 APPBarLayout ，因为我们在 layoutDependsOn 方法里面 ，返回 dependency instanceof AppBarLayout ，即当 dependency 是 AppBarLayout 或者 AppBarLayout的子类的时候返回TRUE。 12345//当 dependency instanceof AppBarLayout 返回TRUE，将会调用onDependentViewChanged（）方法 @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency instanceof AppBarLayout; &#125; 而之所以 RadioGroup 在向上滑动的时候会隐藏，向下滑动的时候会显示，是因为我们在 onDependentViewChanged 方法的时候 动态地根据 dependency 的 top 值改变 RadioGroup 的 translationY 值，核心 代码如下 123456789@Overridepublic boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; //根据dependency top值的变化改变 child 的 translationY float translationY = Math.abs(dependency.getTop()); child.setTranslationY(translationY); Log.i(TAG, &quot;onDependentViewChanged: &quot; + translationY); return true;&#125; 到此第一种思路分析为止 第二种思路主要是根据 onStartNestedScroll（） 和 onNestedPreScroll()方法 来实现的， 当我们开始滑动的时候，我们判断是否是垂直滑动，如果是返回TRUE，否则返回 FALSE，返回TRUE，会接着调用onNestedPreScroll（）等一系列方法。 123456//1.判断滑动的方向 我们需要垂直滑动@Overridepublic boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;&#125; 在 onNestedPreScroll（） 方法里面，我们根据我们的逻辑来决定是否显示 target ， 在这里我们是向上上滑动的时候，如果我们滑动的距离超过 target 的高度 并且 当前是可见的状态下，我们执行动画，隐藏 target，当我们向下滑动的时候，并且 View 是不可见的情况下，我们执行动画 ，显示target 12345678910111213141516171819//2.根据滑动的距离显示和隐藏footer view @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0 &amp;&amp; sinceDirectionChange &lt; 0 || dy &lt; 0 &amp;&amp; sinceDirectionChange &gt; 0) &#123; child.animate().cancel(); sinceDirectionChange = 0; &#125; sinceDirectionChange += dy; int visibility = child.getVisibility(); if (sinceDirectionChange &gt; child.getHeight() &amp;&amp; visibility == View.VISIBLE) &#123; hide(child); &#125; else &#123; if (sinceDirectionChange &lt; 0 &amp;&amp; (visibility == View.GONE || visibility == View .INVISIBLE)) &#123; show(child); &#125; &#125; &#125; 全部代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 知乎效果底部 behavior * * @author xujun on 2016/11/30. * @email gdutxiaoxu@163.com */public class FooterBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private int sinceDirectionChange; public FooterBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; //1.判断滑动的方向 我们需要垂直滑动 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0; &#125; //2.根据滑动的距离显示和隐藏footer view @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; if (dy &gt; 0 &amp;&amp; sinceDirectionChange &lt; 0 || dy &lt; 0 &amp;&amp; sinceDirectionChange &gt; 0) &#123; child.animate().cancel(); sinceDirectionChange = 0; &#125; sinceDirectionChange += dy; int visibility = child.getVisibility(); if (sinceDirectionChange &gt; child.getHeight() &amp;&amp; visibility == View.VISIBLE) &#123; hide(child); &#125; else &#123; if (sinceDirectionChange &lt; 0 &amp;&amp; (visibility == View.GONE || visibility == View .INVISIBLE)) &#123; show(child); &#125; &#125; &#125; private void hide(final View view) &#123; ViewPropertyAnimator animator = view.animate().translationY(view.getHeight()). setInterpolator(INTERPOLATOR).setDuration(200); animator.setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animator) &#123; &#125; @Override public void onAnimationEnd(Animator animator) &#123; view.setVisibility(View.GONE); &#125; @Override public void onAnimationCancel(Animator animator) &#123; show(view); &#125; @Override public void onAnimationRepeat(Animator animator) &#123; &#125; &#125;); animator.start(); &#125; private void show(final View view) &#123; ViewPropertyAnimator animator = view.animate().translationY(0). setInterpolator(INTERPOLATOR). setDuration(200); animator.setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animator) &#123; &#125; @Override public void onAnimationEnd(Animator animator) &#123; view.setVisibility(View.VISIBLE); &#125; @Override public void onAnimationCancel(Animator animator) &#123; hide(view); &#125; @Override public void onAnimationRepeat(Animator animator) &#123; &#125; &#125;); animator.start(); &#125;&#125; 两种实现方法的对比和总结 我们知道第一种方法我们主要是重写layoutDependsOn 和 onDependentViewChanged 这两个方法，这个方法在 layoutDependsOn 判断 dependency 是否是 APpBarLayout 的实现类，所以 会导致 child 依赖于 AppBarLayout，灵活性不是太强 而第二种方法，我们主要是重写 onStartNestedScroll 和 onNestedPreScroll 这两个方法，判断是否是垂直滑动，是的话就进行处理，灵活性大大增强，推荐使用这一种方法 需要注意的是不管是第一种方法，还是第二种方法，我们都需要重写带两个构造方法的函数，因为底层机制会采用反射的形式获得该对象 123public FooterBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125; 自定义 Behavior 实现 FloatingActionButton 的显示与隐藏效果图如下 缩放隐藏的 向上向下隐藏的 布局代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout android:id=&quot;@+id/activity_floating_action_button&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; tools:context=&quot;com.xujun.contralayout.UI.FloatingActionButtonActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/index_app_bar&quot; theme=&quot;@style/AppTheme.AppBarOverlay&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt; &lt;ImageView android:id=&quot;@+id/search&quot; android:layout_width=&quot;24dp&quot; android:layout_height=&quot;24dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:src=&quot;@drawable/search&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/search&quot; android:text=&quot;搜索话题、问题或人&quot; android:textSize=&quot;16sp&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right|end&quot; android:layout_marginBottom=&quot;40dp&quot; android:layout_marginRight=&quot;25dp&quot; android:background=&quot;@android:color/holo_green_light&quot; android:src=&quot;@drawable/add&quot; app:layout_behavior=&quot;@string/behavior_my_fab_scale&quot;/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 如果想使用不同的效果，只需要给 FloatingActionButton 制定不同的 bevaior 即可 1app:layout_behavior=&quot;com.xujun.contralayout.behavior.MyFabBehavior&quot; 自定义behavior 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * FloatingActionButton behavior 向上向下隐藏的 * @author xujun on 2016/12/1. * @email gdutxiaoxu@163.com */public class MyFabBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private float viewY;//控件距离coordinatorLayout底部距离 private boolean isAnimate;//动画是否在进行 public MyFabBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; //在嵌套滑动开始前回调 @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; if(child.getVisibility() == View.VISIBLE&amp;&amp;viewY==0)&#123; //获取控件距离父布局（coordinatorLayout）底部距离 viewY=coordinatorLayout.getHeight()-child.getY(); &#125; return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;//判断是否竖直滚动 &#125; //在嵌套滑动进行时，对象消费滚动距离前回调 @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; //dy大于0是向上滚动 小于0是向下滚动 if (dy &gt;=0&amp;&amp;!isAnimate&amp;&amp;child.getVisibility()==View.VISIBLE) &#123; hide(child); &#125; else if (dy &lt;0&amp;&amp;!isAnimate&amp;&amp;child.getVisibility()==View.GONE) &#123; show(child); &#125; &#125; //隐藏时的动画 private void hide(final View view) &#123; ViewPropertyAnimator animator = view.animate().translationY(viewY).setInterpolator(INTERPOLATOR).setDuration(200); animator.setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animator) &#123; isAnimate=true; &#125; @Override public void onAnimationEnd(Animator animator) &#123; view.setVisibility(View.GONE); isAnimate=false; &#125; @Override public void onAnimationCancel(Animator animator) &#123; show(view); &#125; @Override public void onAnimationRepeat(Animator animator) &#123; &#125; &#125;); animator.start(); &#125; //显示时的动画 private void show(final View view) &#123; ViewPropertyAnimator animator = view.animate().translationY(0).setInterpolator(INTERPOLATOR).setDuration(200); animator.setListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animator) &#123; view.setVisibility(View.VISIBLE); isAnimate=true; &#125; @Override public void onAnimationEnd(Animator animator) &#123; isAnimate=false; &#125; @Override public void onAnimationCancel(Animator animator) &#123; hide(view); &#125; @Override public void onAnimationRepeat(Animator animator) &#123; &#125; &#125;); animator.start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * &lt;p&gt;下拉时显示FAB，上拉隐藏，留出更多位置给用户。&lt;/p&gt; * Created on 2016/12/1. * * @author xujun */public class ScaleDownShowBehavior extends FloatingActionButton.Behavior &#123; /** * 退出动画是否正在执行。 */ private boolean isAnimatingOut = false; private OnStateChangedListener mOnStateChangedListener; public ScaleDownShowBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; if ((dyConsumed &gt; 0 || dyUnconsumed &gt; 0) &amp;&amp; !isAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;//往下滑 AnimatorUtil.scaleHide(child, viewPropertyAnimatorListener); if (mOnStateChangedListener != null) &#123; mOnStateChangedListener.onChanged(false); &#125; &#125; else if ((dyConsumed &lt; 0 || dyUnconsumed &lt; 0) &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; AnimatorUtil.scaleShow(child, null); if (mOnStateChangedListener != null) &#123; mOnStateChangedListener.onChanged(true); &#125; &#125; &#125; public void setOnStateChangedListener(OnStateChangedListener mOnStateChangedListener) &#123; this.mOnStateChangedListener = mOnStateChangedListener; &#125; // 外部监听显示和隐藏。 public interface OnStateChangedListener &#123; void onChanged(boolean isShow); &#125; public static &lt;V extends View&gt; ScaleDownShowBehavior from(V view) &#123; ViewGroup.LayoutParams params = view.getLayoutParams(); if (!(params instanceof CoordinatorLayout.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;The view is not a child of CoordinatorLayout&quot;); &#125; CoordinatorLayout.Behavior behavior = ((CoordinatorLayout.LayoutParams) params).getBehavior(); if (!(behavior instanceof ScaleDownShowBehavior)) &#123; throw new IllegalArgumentException(&quot;The view is not associated with ScaleDownShowBehavior&quot;); &#125; return (ScaleDownShowBehavior) behavior; &#125; private ViewPropertyAnimatorListener viewPropertyAnimatorListener = new ViewPropertyAnimatorListener() &#123; @Override public void onAnimationStart(View view) &#123; isAnimatingOut = true; &#125; @Override public void onAnimationEnd(View view) &#123; isAnimatingOut = false; view.setVisibility(View.GONE); &#125; @Override public void onAnimationCancel(View arg0) &#123; isAnimatingOut = false; &#125; &#125;;&#125; 思路这里就不详细展开了，因为前面在讲解 仿知乎效果的时候已经讲过了，大概就是根据不同的滑动行为执行不同的动画 而已 题外话 通过这篇博客，熟悉 CoordinatorLayout 的 各种用法，同时也初步理解了自定义Behavior的思路 同时复习了动画的相关知识 如果你觉得效果还不错，欢迎到我的github上面star，github地址 文章首发地址CSDN：http://blog.csdn.net/gdutxiaoxu/article/details/53453958 源码下载地址：https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用CoordinatorLayout打造各种炫酷的效果]]></title>
      <url>%2F2016%2F12%2F08%2F%E4%BD%BF%E7%94%A8CoordinatorLayout%E6%89%93%E9%80%A0%E5%90%84%E7%A7%8D%E7%82%AB%E9%85%B7%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[使用CoordinatorLayout打造各种炫酷的效果文章首发地址CSDN：http://blog.csdn.net/gdutxiaoxu/article/details/52858598 CoordinatorLayout简介CoordinatorLayout是在 Google IO/15 大会发布的，遵循Material 风格，包含在 support Library中，结合AppbarLayout, CollapsingToolbarLayout等 可 产生各种炫酷的效果 CoordinatorLayout简介通常用来 干什么Google官方地址 CoordinatorLayout is intended for two primary use cases: As a top-level application decor or chrome layout As a container for a specific interaction with one or more child views 简单来说就是 作为最上层的View 作为一个 容器与一个或者多个子View进行交互 下面我们一起先来看一下我们实现的效果图动态图 结合ToolBar 结合ViewPager 结合ViewPager的视觉特差 AppBarLayout它是继承与LinearLayout的，默认 的 方向 是Vertical 类型 说明 int SCROLL_FLAG_ENTER_ALWAYS When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. int SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED An additional flag for ‘enterAlways’ which modifies the returning view to only initially scroll back to it’s collapsed height. int SCROLL_FLAG_EXIT_UNTIL_COLLAPSED When exiting (scrolling off screen) the view will be scrolled until it is ‘collapsed’. int SCROLL_FLAG_SCROLL The view will be scroll in direct relation to scroll events. int SCROLL_FLAG_SNAP Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it’s closest edge. 类型 说明 int SCROLL_FLAG_ENTER_ALWAYS W((entering) / (scrolling on screen))下拉的时候，这个View也会跟着滑出。 int SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED 另一种enterAlways，但是只显示折叠后的高度。 int SCROLL_FLAG_EXIT_UNTIL_COLLAPSED ((exiting) / (scrolling off screen))上拉的时候，这个View会跟着滑动直到折叠。 int SCROLL_FLAG_SCROLL 这个View将会响应Scroll事件 int SCROLL_FLAG_SNAP 在Scroll滑动事件结束以前 ，如果这个View部分可见，那么这个View会停在最接近当前View的位置 我们可以通过两种 方法设置这个Flag 方法一 1setScrollFlags(int) 方法二 1app:layout_scrollFlags="scroll|enterAlways" 注意事项AppBarLayout必须作为CoordinatorLayout的直接子View，否则它的大部分功能将不会生效，如layout_scrollFlags等。 首先我们先来看一下我们 效果图一是怎样实现的代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;android.support.design.widget.CoordinatorLayout android:id="@+id/main_content" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:layout_scrollFlags="scroll|enterAlways" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; . &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_margin="15dp" android:src="@drawable/add_2"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 思路 分析 从图中我们可以知道 layout_scrollFlags=”scroll|enterAlways，前面已经说到layout_scrollFlags=scroll的时候，这个View会 跟着 滚动 事件响应，layout_scrollFlags=“enterAlways”的时候 这个View会响应下拉事件所以呈现出来的结果应该是我们在上拉的时候toolBar 会隐藏，下拉的时候toolBar会出来 那如果当我们的toolBar 等于 app:layout_scrollFlags=”scroll|snap”的时候 ，layout_scrollFlags=scroll的时候，这个View会 跟着 滚动 事件响应，layout_scrollFlags=“snap”的时候 在Scroll滑动事件结束以前 ，如果这个View部分可见，那么这个View会停在最接近当前View的位置。综上呈现的效果如下，代码见ToolBarSampleSnar的布局文件 结合ViewPager布局代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;android.support.design.widget.CoordinatorLayout android:id="@+id/main_content" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="250dp"&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="200dp" android:background="?attr/colorPrimary" android:scaleType="fitXY" android:src="@drawable/tangyan" app:layout_scrollFlags="scroll|enterAlways"/&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabs" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="?attr/colorPrimary" app:tabIndicatorColor="@color/colorAccent" app:tabIndicatorHeight="4dp" app:tabSelectedTextColor="#000" app:tabTextColor="#fff"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_margin="15dp" android:src="@drawable/add_2"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 思路分析 其实相对于前 一个例子，只是把 摆放RecyclerView 的位置替换成ViewPager而已，为了有页面导航器的效果，再使用 TabLayout而已，而TabLayout 在我们滑动的时候最终会停靠在 最顶部，是因为我们没有设置其layout_scrollFlags，即TabLayout是静态的 运行以后，即可看到以下的结果 下面我们一起来看一下 TabLayout是怎样结合ViewPager直线 导航器的效果的代码注释 里面已经解释地很清楚了 ，这里我就不解释了 1234567891011121314151617181920212223242526272829303132333435363738public class ViewPagerSample extends AppCompatActivity &#123; ViewPager mViewPager; List&lt;Fragment&gt; mFragments; String[] mTitles = new String[]&#123; "主页", "微博", "相册" &#125;; private TabLayout mTabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); // 第一步，初始化ViewPager和TabLayout mViewPager = (ViewPager) findViewById(R.id.viewpager); mTabLayout = (TabLayout) findViewById(R.id.tabs); setupViewPager(); &#125; private void setupViewPager() &#123; mFragments = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mTitles.length; i++) &#123; ListFragment listFragment = ListFragment.newInstance(mTitles[i]); mFragments.add(listFragment); &#125; // 第二步：为ViewPager设置适配器 BaseFragmentAdapter adapter = new BaseFragmentAdapter(getSupportFragmentManager(), mFragments, mTitles); mViewPager.setAdapter(adapter); // 第三步：将ViewPager与TableLayout 绑定在一起 mTabLayout.setupWithViewPager(mViewPager); &#125;&#125; 如果我们想更改Indicator的相关样式，我们可以在布局文件里面使用 12345678910&lt;android.support.design.widget.TabLayout android:id="@+id/tabs" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="?attr/colorPrimary" app:tabIndicatorColor="@color/colorAccent" app:tabIndicatorHeight="4dp" app:tabSelectedTextColor="#000" app:tabTextColor="#fff"/&gt; 如果你不想使用Google 帮我们 封装好的控件的话，你也可以自己自定义一个控件，你可以参考我的这一篇博客仿网易新闻的顶部导航指示器 在看例子结合ViewPager的视觉特差之前 ，我们需要先了解CollapsingToolbarLayout这个控件 CollapsingToolbarLayout CollapsingToolbarLayout继承与FrameLayout，官网地址,请自备梯子。 简单来说 ,CollapsingToolbarLayout是工具栏的包装器,它通常作为AppBarLayout的孩子。主要实现以下功能 Collapsing title（可以折叠 的 标题 ） Content scrim（内容装饰），当我们滑动的位置 到达一定阀值的时候，内容 装饰将会被显示或者隐藏 Status bar scrim（状态栏布） Parallax scrolling children，滑动的时候孩子呈现视觉特差效果 Pinned position children，固定位置的 孩子 下面我们一起来看一下几个常量 常量 解释说明 int COLLAPSE_MODE_OFF The view will act as normal with no collapsing behavior.(这个 View将会 呈现正常的结果，不会表现出折叠效果） int COLLAPSE_MODE_PARALLAX The view will scroll in a parallax fashion. See setParallaxMultiplier(float) to change the multiplier used.（在滑动的时候这个View 会呈现 出 视觉特差效果 ） int COLLAPSE_MODE_PIN The view will pin in place until it reaches the bottom of the CollapsingToolbarLayout.（当这个View到达 CollapsingToolbarLayout的底部的时候，这个View 将会被放置，即代替整个CollapsingToolbarLayout） 我们有两种方法可以设置这个常量, 方法一：在代码中使用这个方法 1setCollapseMode(int collapseMode) 方法 二：在布局文件中使用自定义属性 1app:layout_collapseMode="pin" 到此 ，CollapsingToolbarLayout的一些重要属性已经讲解完毕，下面我们一起来看一下我们是怎样结合ViewPager实现视差效果的 结合ViewPager的视觉特差布局代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/background_light" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/main.appbar" android:layout_width="match_parent" android:layout_height="300dp" android:fitsSystemWindows="true" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/main.collapsing" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true" app:contentScrim="?attr/colorPrimary" app:expandedTitleMarginEnd="64dp" app:expandedTitleMarginStart="48dp" app:layout_scrollFlags="scroll|exitUntilCollapsed" &gt; &lt;ImageView android:id="@+id/main.backdrop" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:scaleType="centerCrop" android:src="@drawable/tangyan" app:layout_collapseMode="parallax" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabs" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="?attr/colorPrimary" app:tabIndicatorColor="@color/colorAccent" app:tabIndicatorHeight="4dp" app:tabSelectedTextColor="#000" app:tabTextColor="#fff"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_margin="15dp" android:src="@drawable/add_2"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 效果图如下 思路解析 结构图如图片所示，先说明CollapsingToolbarLayout的变化 CollapsingToolbarLayout里面 包含ImageView 和ToolBar，ImageView的app:layout_collapseMode=”parallax”，表示视差效果，ToolBar的 app:layout_collapseMode=”pin”，当这个TooBar到达 CollapsingToolbarLayout的底部的时候，会代替整个CollapsingToolbarLayout显示 接着说明TabLayout的变化 从前面的描述我们已经知道当 没有指定app:layout_scrollFlags的时候，最终TabLayout会静止，不会随着滑动的 时候消失不见 拓展如果我们仅仅 改变CollapsingToolbarLayout的app:layout_scrollFlags=”scroll|exitUntilCollapsed|snap”的时候，其它代码不变，运行以后，我们将可以看到如下效果图 总结这篇博客主要讲解了CoordinatorLayout，AppBarLayout，CollapsingToolbarLayout的一些相关属性。 对于AppBarLayout，我们主要 讲解了这个属性app:layout_scrollFlags，设置不同 的属性我们可以在滚动的时候显示不同 的效果 对于CollapsingToolbarLayout，我们主要讲解了app:layout_collapseMode这个属性，设置不同的值，我们可以让其子View呈现不同的 炫酷效果，如parallax和pin等 CoordinatorLayout的相关用法还有很多，有兴趣 了解的请自行阅读: 官方文档地址 题外话CoordinatorLayout这个控件真的很强大，使用它可以实现各种炫酷的效果，简化了开发者的许多工作，有能力的话可以去研究一下源码 ，看是怎样实现的？ 参考文章：android-[译]掌握CoordinatorLayout 源码下载地址：https://github.com/gdutxiaoxu/CoordinatorLayoutExample.git]]></content>
    </entry>

    
  
  
</search>
