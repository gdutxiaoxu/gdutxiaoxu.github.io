<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员徐公</title>
  <icon>https://www.gravatar.com/avatar/40aa50998f368ef580c3c762f66afff2</icon>
  <subtitle>微信公众号：程序员徐公</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gdutxiaoxu.gitee.io/"/>
  <updated>2021-05-08T06:54:20.806Z</updated>
  <id>https://gdutxiaoxu.gitee.io/</id>
  
  <author>
    <name>徐公</name>
    <email>gdutxiaoxu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员如何写好自己的简历，一位 5 年中大厂老哥跟你聊聊</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/05/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8E%86%EF%BC%8C%E4%B8%80%E4%BD%8D%205%20%E5%B9%B4%E4%B8%AD%E5%A4%A7%E5%8E%82%E8%80%81%E5%93%A5%E8%B7%9F%E4%BD%A0%E8%81%8A%E8%81%8A/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/05/08/程序员如何写好自己的简历，一位 5 年中大厂老哥跟你聊聊/</id>
    <published>2021-05-08T00:33:13.000Z</published>
    <updated>2021-05-08T06:54:20.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发我的微信公众号：程序员徐公，微信公众号<strong>程序员徐公</strong>回复<strong>徐公666</strong>，可以获得简历模板</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是程序员徐公，双非本科，某中大厂程序员，加上实习，恰好有 5 年的程序员生涯。</p><p>从实习到校招，中途踩过不少坑。在职场中有一些自己的心得，今天，跟大家一起来聊聊，程序员应该如何写好自己的一份简历。</p><p>前段时间，有一些粉丝私信我说，<strong>明年我想进大厂，今年想开始准备，有什么建议嘛？</strong></p><p>我回复他的第一句话说，<strong>先整理好自己的简历，再进行下一步的计划</strong>。为什么这么说呢？</p><p>第一：整理简历的过程，其实是一次<strong>复盘总结</strong>。在这过程中，我们会知道自己哪些地方做得好的，哪些做得不好的，这样才能针对性地进行复习。</p><p>第二：挺多人，简历写不好，在筛选简历的时候，直接被 pass，连面试的机会都没有，这是很可惜的。</p><p>第三：简历写不好，<strong>没突出重点</strong>，面试官很难从短短的一个小时之内，发现你的亮点，空有一身才华，却得不到展现，多可惜呀。</p><p>下面，就让我们一起来聊一聊，对于技术人来说，怎样才算是一份好的简历？</p><h1 id="一、突出你的亮点"><a href="#一、突出你的亮点" class="headerlink" title="一、突出你的亮点"></a>一、突出你的亮点</h1><p>一份简历，简单来说，主要分为四部分</p><ol><li>个人基本信息</li><li>过往履历</li><li>个人技能</li><li>项目经历</li></ol><p>而 HR，面试官在筛选简历的时候，很有可能不超过一分钟，在这短短的 60 秒时间之内，如果要脱颖而出，简历一定要突出你的亮点，让人耳目一新，彰显自己的才能。</p><p>对于程序员来说，个人亮点，我们可以从以下及方面着手，比如说。</p><ol><li>解决了什么疑难杂症，如解决了 top crash， crash 率降低了 0.1% 等</li><li>性能上面带来了多少提升，如编译速度的提升，提升了多少，降低了多少 min等</li><li>你在这个项目作出了什么成绩，比如主导搭建了代码扫描框架，自动扫描，提高代码质量，减少 review 成本。</li></ol><p><strong>千里马常有，而伯乐不常有</strong>。一定要重视简历，让简历能够反映你的真实水平，先不说做到锦上添花，至少不要拖后腿。</p><h1 id="二、展现自己的个人技能"><a href="#二、展现自己的个人技能" class="headerlink" title="二、展现自己的个人技能"></a>二、展现自己的个人技能</h1><p>个人技能这块，也是简历中必不可少的一部分。</p><p><strong>第一，先说最重要的一点，按照掌握的程度分为几个等级，精通，熟悉，掌握，了解，强烈建议不要写精通，道理你懂的。</strong></p><p><strong>第二：不熟悉的点不要写到简历上面，否则就是给自己挖坑。</strong></p><p>比如，你只是使用了网络库 OkHttp，你在简历上面写熟悉/掌握 Okhttp。恭喜你，兄弟，你给自己埋下了一颗<strong>定时炸弹</strong>。面试官可能会问你各种原理的，Okhttp  的设计原理是怎样，拦截器是怎样设计的，有什么优缺点，连接池等等？</p><p>说到这，想起了当年实习生面试的时候，写了某开源库，一问三不知。</p><p><strong>第三：技能要具体，突出重点，让面试官有话可问</strong>。</p><p>反例：</p><blockquote><p>熟悉 Java</p></blockquote><p>正例： </p><blockquote><p>熟悉类加载，并使用类加载技术开发了一个模块化框架</p></blockquote><p>面试其实是一个双向的选择过程，简历上面技能写得具体，面试官看到了，可能会往这个方面提问题，这是非常 nice 的，我们恰好可以展现自己的特长。</p><p>相反，如果简历上面写得不具体，面试官找不出想问的点，那可能就会往他/她擅长的方面问，这时候，对于求职者来说，是非常吃亏的。</p><p>因为每个人都有擅长和不擅长的技能，不可能面面俱到。</p><p><strong>第四，写的技能一定要跟你应聘的岗位相关，不相关的不要写上去</strong>。</p><p>比如，你应聘的是 Android 开发工程师，你在简历上面写一堆后端技能。匹配度不高，简历可能会 pass。</p><p>当然，也不是不可以写与应聘岗位不相关的技能，只是说简历要跟我们应聘的岗位匹配度高一点。这样，简历筛选通过的几率比较高。</p><p><strong>最后，专有名词一定要写对，这体现一个人的专业素养和细心。比如 Java，不要写成 java，android 不要写成 Android</strong>。</p><h1 id="三、以项目为主体，展现自己的技术能力和项目贡献"><a href="#三、以项目为主体，展现自己的技术能力和项目贡献" class="headerlink" title="三、以项目为主体，展现自己的技术能力和项目贡献"></a>三、以项目为主体，展现自己的技术能力和项目贡献</h1><p>我们可以从以下思路，以项目为主体，设计我们的简历。</p><p>如图，大概分为以下层级</p><ol><li>项目名称，开始时间和结束时间，在项目中担任的角色</li><li>项目简介，说清楚这个项目主要是做什么的，有多少量级，尽量不要超过一行，切忌不要超过两行</li><li>项目职责，个人的建议，主要分为两大块，一个是技术职责，一个是业务职责。这样面试官能够很清楚的知道，你在项目中做了什么。</li></ol><p>项目职责，这一块是最重要的，也是展现我们能力的时候，尤其要重视。</p><p>在写一块的时候，建议分点论述，这样显得调理清晰。</p><ul><li>比如你解决了项目的什么疑难杂症，带来了什么收益。这块在面试当中也经常被问到，<strong>项目中你有遇到什么技术难点嘛，是怎么解决的</strong>？这块回答好了，可以给我们的面试加很多分</li><li>做了什么性能优化？这块可以有很多，根据自己擅长的领域和项目经历加上去即可。比如启动优化，编译速度优化，APK 瘦身等</li><li>你在这个项目中作出了什么成绩？这块要结合我们项目中的情况来说，比如你推动了 MVVM 框架，组件化的落地等</li></ul><h1 id="量化你的项目，给出数字"><a href="#量化你的项目，给出数字" class="headerlink" title="量化你的项目，给出数字"></a>量化你的项目，给出数字</h1><p>量化我们的项目，给出数字化结果，可以提高简历的专业度和说服力，给面试官和 hr 留下深刻的印象。</p><p>例子一</p><p>改写前：应用 xx 技术，解决了 top N 奔溃</p><p>改写后：应用 xx 技术，解决了 top N 奔溃，crash 率降低了 0.1% 等</p><p>例子二</p><p>改写前：应用 xx 技术，减少了内存泄露的发生</p><p>改写后：应用 xx 技术，减少了内存泄露的发生，内存 top 值极少了 xxM</p><p>例子三：</p><p>改写前：结合使用 xx，实现了 app 登录和个人资料的自动填充</p><p>改写后：结合使用 xx，实现了 app 登录和个人资料的自动填充，提高了多少的转化率</p><h1 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h1><p>写简历，有一些新手会经常犯一些错误，下面简单列举一下</p><ol><li>简历要用 PDF 格式，不要用 Word 格式，有兼容性问题，可能会乱码</li><li>简历命名，建议已这样的格式命名，<strong>昵称-应聘岗位-联系方式</strong>，这样可以一目了然</li><li>简历不要太长，尽量控制在两页之内。主要重点介绍你最近做过的项目或者你觉得自己做得比较好的项目</li><li>不要在简历中写之前的待遇和期望待遇。</li><li>如果平时有写博客，可以将博客地址写在简历上面，这是一个加分项。不过，如果你的博客上面只是单纯记流水账，就不要写上去了，反而容易减分。Github 也是同样的道理。</li></ol><p>暂时就想起这么多了，以后记得再补充，对了，我整理了一份简历模板，想获取的话，可以在我的微信公众号<strong>程序员徐公</strong>回复<strong>徐公666</strong></p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210507091915.png"></p><h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><p>写好一份简历，有很多技巧，排版，量化数据等，但有一点最重要的是，自身要有底子，要有实力。不然，简历写得再好，一切都是泡沫。</p><p>十年磨一剑，铁杵磨成针。不管什么行业，想要脱颖而出，坚持是最重要的。唯有日复一日的坚持与打磨，才能走得更高更远。</p><p>以上，是我对如何写好简历的一些看法，觉得写得不错的，可以点个赞哦。微信公众号后台回复<strong>徐公666</strong>，可以获得我整理的简历模板一份。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzUzODQxMzYxNQ==&mid=2247485229&idx=1&sn=decb80fd2a5870764e954b2419f0e599&chksm=fad9586dcdaed17b9ca091578f156c80cc84238c742cbfbef0a7d959528e72ff9286e1bee079#rd">我的 5 年 Android 学习之路，那些年一起踩过的坑</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzUzODQxMzYxNQ==&mid=2247485028&idx=2&sn=9df955d54f9eedd58f95bfae1d4717b1&chksm=fad95924cdaed03238715f1150827a8ce24f257dec390785ea2d6626c1d3a9f9e5f4d74c072f#rd">职场上这四件事，越早知道越好</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzUzODQxMzYxNQ==&mid=2247484166&idx=1&sn=1b4646ea54b01dcbc655f1fe747cb36f&chksm=fad95c46cdaed550adbdad109ad79d172ffff03a07a5b7aafe173f6f1e85414604842339bc6c#rd">今天，说三件小事</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzUzODQxMzYxNQ==&mid=2247484161&idx=2&sn=8d19078c3789c757f4aa4ca23e00a60e&chksm=fad95c41cdaed557b7a676ef23c7f9e94b797bf0d4a6e1fa8df9626fc98c4bffbcf0ce86afb2#rd">技术人的未来在哪里</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzUzODQxMzYxNQ==&mid=2247484138&idx=2&sn=5685e895e85ad1a08b30750885f78644&chksm=fad95daacdaed4bc0b7445db3db62a64894957be350bc87f9bc4b3eff2d0f425c54ed5422a8f#rd">致刚入职场的你 - 程序员的成长笔记</a></p><p>关注我的公众号<strong>程序员徐公</strong>，回复 <strong>徐公666</strong>  获取简历模板，回复 <strong>黑马</strong> ，获取黑马视频教程。</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%20(1).png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文首发我的微信公众号：程序员徐公，微信公众号&lt;strong&gt;程序员徐公&lt;/strong&gt;回复&lt;strong&gt;徐公666&lt;/strong&gt;，可以获得简历模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字节跳动抖音 Android 校招面经，已拿 offer</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/04/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%8A%96%E9%9F%B3Android-%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F%EF%BC%8C%E5%B7%B2%E6%8B%BF-offer/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/04/24/字节跳动抖音Android-校招面经，已拿-offer/</id>
    <published>2021-04-23T16:14:29.000Z</published>
    <updated>2021-04-23T16:16:16.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：可爱猫图鉴赏员<br>链接：<a href="https://www.nowcoder.com/discuss/489732?type=0&amp;order=0&amp;pos=2992&amp;page=1&amp;channel=-2&amp;source_id=discuss_tag">https://www.nowcoder.com/discuss/489732?type=0&amp;order=0&amp;pos=2992&amp;page=1&amp;channel=-2&amp;source_id=discuss_tag</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天，在逛博客的时候，看到一篇不错的校招生面经，转载过来，大家可以看一下。</p><p>作者背景大概是这样的：</p><blockquote><p>2021应届秋招</p><p>个人背景 ：本科，软件工程专业，有一段暑期实习（美团）和几个安卓项目</p><p>提前批投递了字节头条的客户端，挂在了终面，正式批又投了抖音的客户端，简历通过后约了大概一周后面试</p></blockquote><h2 id="一面（-45min）"><a href="#一面（-45min）" class="headerlink" title="一面（~45min）"></a>一面（~45min）</h2><ol><li>介绍项目，讲述一下实习的工作内容和感想（~10min）</li><li>什么是内存泄漏，Android里有哪些内存泄漏的场景，原因是什么</li><li>JVM的GC过程，GC的算法都有哪些</li><li>进程和线程的概念，Android里怎样实现多线程？（Thread  Handler  AsyncTask  IntentService等等）</li><li>Handler的原理和使用</li><li>Handler是怎么和线程绑定的（Looper），为什么Looper.loop()要设计成死循环</li><li>Java的几种内部类，区别是什么</li><li>Activity的生命周期和启动模式</li><li>写题：二叉树的右视图（层序遍历即可）</li></ol><p>一面比较短，问的问题也比较基础，大概30分钟后开始二面</p><h2 id="二面（-1h30min）"><a href="#二面（-1h30min）" class="headerlink" title="二面（~1h30min）"></a>二面（~1h30min）</h2><ol><li>自我介绍</li><li>介绍项目，为什么要自学安卓（~5min）</li><li>Android如何实现多进程，应用场景是什么（答的不好）</li><li>Android的IPC机制（Binder）是否了解（答的也不好）</li><li>如何用两个队列（FIFO）实现栈（FILO）</li><li>HashMap和HashTable区别，HashMap原理和实现，hash()的算法</li><li>如果自己设计hash算***怎么设计，为什么（答的素数取余）</li><li>String的hashCode()和Object的hashCode()</li><li>虚拟内存和物理内存的概念和关系，内存分页的调度算法</li><li>怎么实现LRU缓存（参考leetcode T146）</li><li>可以自己写一个java.lang.Object类吗，系统会加载哪一个</li><li>Java里泛型的实现</li><li>了解常见排序算法吗，手写一下快排</li><li>Java里加锁的方式，synchornized关键字的原理，悲观锁和乐观锁都有哪些实现</li><li>死锁的条件和解决方法，讲讲银行家算法</li><li>TCP的三次握手四次挥手，为什么要四次挥手</li><li>TCP的流量控制算法（滑动窗口），拥塞控制算法</li><li>怎么解决用户高频点击打开新Activity导致的多实例问题（Activity启动模式）</li><li>怎么判断两个无环单链表是否相交</li><li>写题：leetcode 445</li><li>反问</li></ol><p>二面问题量非常的大，集中在Java/OS/算法，但并没有特别难以回答的问题，认真准备的话大部分都能答出来。面试官也非常友好，给了很多引导和提示。</p><p>因为三面面试官的时间问题，约了两天后的三面</p><h2 id="三面（-45min）"><a href="#三面（-45min）" class="headerlink" title="三面（~45min）"></a>三面（~45min）</h2><ol><li>自我介绍</li><li>介绍一下实习做的工作，是自己完成的吗，遇到什么困难，成果怎么样</li><li>RecyclerView怎么实现的item缓存，跟ListView有什么区别（因为项目用到了所以被问了）</li><li>写题：1233. 删除子文件夹</li><li>设计题：微信的联系人列表功能<ul><li>（1）设计添加联系人的API（从可能的方式，数据形式，接口参数方面回答）</li><li>（2）怎么实现联系人列表的UI（答的RecyclerView）</li><li>（3）怎么实现A-Z首字母的快速定位功能</li></ul></li><li>是自学的Android吗，为什么选择这个方向，有没有什么经验给同样想自学的学弟学妹</li><li>是哪里人，为什么想到上海来就业</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>校招生面试，尤其是大厂，说到底，一般主要问几点</p><ol><li>基础，包括 Java 基础，计算机基础，Android 的一些基础，Handler，线程池原理</li><li>项目或者实习经历，做了什么，难点是什么，有什么收获</li><li>算法，这个可以多刷刷剑指 offer，leetcode 或者牛客。</li></ol><p>如果想进入大厂的，建议大二，大三的时候，可以着手开始准备。</p><ol><li>在大三的时候，尽量争取能够进入中大厂实习，这时候的竞争相对校招会小很多，表现不错的，基本可以直接留下来转正。</li><li>投递简历的时候，尽量找师兄师姐内推。简历还可以的，基本可以直接面试，免去了笔试。如果你身边没有熟人的话，我也可以帮你内推哦。</li></ol><p>最后，送给大家一些我大学时候整理的资料。</p><ol><li>公众号回复 <strong>Java</strong>，领取马士兵 java 学习视频</li><li>公众号回复 <strong>黑马</strong>，领取黑马 52 期不加密视频</li><li>公众号回复  <strong>剑指 offer</strong>，领取剑指 offer 题解</li></ol><h2 id="找到我"><a href="#找到我" class="headerlink" title="找到我"></a>找到我</h2><p>我是站在巨人的肩膀上成长起来的，同样，我也希望成为你们的巨人。觉得不错的话可以关注一下我的微信公众号程序员徐公，在此感谢各位大佬们。主要分享</p><p>1.<strong>Android 开发相关知识</strong>：包括 java，kotlin， Android 技术。<br>2.<strong>面试相关分享</strong>：包括常见的面试题目，大厂面试真题、面试经验套路分享。<br>3.<strong>算法相关学习笔记</strong>：比如怎么学习算法，leetcode 常见算法总结，跟大家一起学习算法。<br>4.<strong>时事点评</strong>：主要是关于互联网的，比如小米高管屌丝事件，拼多多女员工猝死事件等</p><p>希望我们可以成为朋友，成长路上的忠实伙伴！</p><p><img src="https://img-blog.csdnimg.cn/img_convert/32330cdfb6f0dfc77e5e0eccfc2d7dde.png"></p>]]></content>
    
    <summary type="html">
    
      字节跳动抖音 Android 校招面经，已拿 offer
    
    </summary>
    
      <category term="面经" scheme="https://gdutxiaoxu.gitee.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://gdutxiaoxu.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（七） - JetPack App Startup 使用及源码浅析</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/04/18/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%83%EF%BC%89-JetPack-App-Startup-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/04/18/Android-启动优化（七）-JetPack-App-Startup-使用及源码浅析/</id>
    <published>2021-04-18T15:47:15.000Z</published>
    <updated>2021-04-18T15:49:50.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文收录于 <a href="https://github.com/gdutxiaoxu/AndroidGuide">https://github.com/gdutxiaoxu/AndroidGuide</a> 「Android学习+面试指南」一份涵盖大部分 Android 程序员所需要掌握的核心知识。准备 Android 面试，首选 AndroidGuide！<strong>微信公众号：程序员徐公</strong></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子，写了几篇 Android 启动优化的文章，主要是从两个方面论述的。</p><ol><li>Application 多线程异步加载，以及怎么解决多线程任务依赖的问题</li><li>首页布局优化，从常规的布局嵌套优化到渐进式加载，再到异步加载。</li></ol><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>发布在掘金之后，几篇文章都被推荐上了掘金首页，深得大家的喜欢，阅读量也挺不错的。</p><p>有不少公众号粉丝在后台问我 <strong>JetPack App Startup</strong> 是什么，跟我开源的 <a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a> 有什么区别？</p><p>今天，就让我们来聊一聊 JetPack App Startup。</p><p>目录大概是这样的</p><blockquote><p>1 什么是 JetPack App Startup <br/><br>2 JetPack App Startup 能解决什么问题 <br/><br>3 JetPack App Startup 基本使用 <br/><br>4 JetPack App Startup 进阶使用 <br/><br>5 JetPack App Startup 源码浅析 <br/><br>6 小结</p></blockquote><h2 id="什么是-JetPack-App-Startup"><a href="#什么是-JetPack-App-Startup" class="headerlink" title="什么是 JetPack App Startup"></a>什么是 JetPack App Startup</h2><p>我们先来看一下官方的解释，<a href="https://developer.android.com/topic/libraries/app-startup">官方地址</a>：<a href="https://developer.android.com/topic/libraries/app-startup">https://developer.android.com/topic/libraries/app-startup</a></p><blockquote><p>The App Startup library provides a straightforward, performant way to initialize components at application startup. Both library developers and app developers can use App Startup to streamline startup sequences and explicitly set the order of initialization.</p></blockquote><blockquote><p>Instead of defining separate content providers for each component you need to initialize, App Startup allows you to define component initializers that share a single content provider. This can significantly improve app startup time.</p></blockquote><p>翻译过来就是：</p><ol><li>App Startup 这个库提供了一个组件，可以在应用程序启动的时候初始化。</li><li>开发人员可以使用这个组件精简启动序列和显式地设置初始化的顺序。 　</li><li>我们不需要为每个组件定义单独的 ContentProvider,App Startup 允许您定义的所有组件化共享一个内容提供者。这样可以<strong>极大地减少高应用程序的启动时间</strong></li></ol><h2 id="JetPack-App-Startup-能解决什么问题"><a href="#JetPack-App-Startup-能解决什么问题" class="headerlink" title="JetPack App Startup 能解决什么问题"></a>JetPack App Startup 能解决什么问题</h2><p><strong>听了上面的介绍，是不是还有点懵？</strong></p><p>App Startup 能减少高应用程序的启动时间，它是怎么做到的？</p><p>做过 Android 启动优化的，可能都知道，Android 的启动流程是这样的。</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210417133422.png"></p><p>从 <code>Application#attachBaseContext</code> 到 <code>ContentProvider#onCreate</code>，到 <code>Application#onCreate</code> 再到 <code>MainActivity#onCreate</code>。</p><p>而 <strong>App Startup</strong> 设计的初衷，正是为了收拢 ContentProvider。有不少第三方的 SDk，为了使用者不必手动调用 <code>SDK#init</code> 方法，使用了 ContentProvider 这一个骚操作。</p><p>在 AndroidManifest 里面注册了自己的 xxSDkProvider，然后在 xxSDkProvider 的 onCreate 方面里面进行初始化，确实调用者不需要自己初始化了，可却增加了启动耗时，如果要作优化，还得自己剔除 ContentProvider 的初始化，值不值得，我是感觉没必要，这操作是<strong>真的骚</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;application ...&gt;</span><br><span class="line"></span><br><span class="line">    &lt;provider</span><br><span class="line">        android:name&#x3D;&quot;.xxSDkProvider&quot;</span><br><span class="line">        android:authorities&#x3D;&quot;$&#123;applicationId&#125;.xxSDkProvider&quot;</span><br><span class="line">        android:exported&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class XXSDKProvider : ContentProvider() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(): Boolean &#123;</span><br><span class="line">        Log.d(TAG, &quot;XXSDKProvider create()&quot;)</span><br><span class="line">        XXSDK.init()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>同时，这里给做启动优化的同学提供了一种思路。打开你的 Apk，看一下 AndroidManiest 里面有多少 provider，看一下是否有这样的骚操作。如果有，改一下，说不定启动优化，一下子就减少了 100 多 毫秒。</strong></p><p>接下来，我们来看一下 AppStartUp 怎么使用</p><h2 id="AppStartUp-基本使用"><a href="#AppStartUp-基本使用" class="headerlink" title="AppStartUp 基本使用"></a>AppStartUp 基本使用</h2><p>简单来说，分为三步</p><ol><li>gradle 文件引入App Startup 库。</li><li>自定义一个用于初始化的 Initializer。</li><li>将自定义 Initializer 配置到 AndroidManifest.xml 当中。</li></ol><p><strong>第一步，在 build.gradle 文件添加依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;androidx.startup:startup-runtime:1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：自定义实现 Initializer 类</strong></p><p>主要有两个方法</p><ol><li><code>T create(@NonNull Context context)</code> 初始化一个组件，返回给 Application</li><li><code>List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies()</code> 当前的 Initializer 依赖于哪些 Initializers，通过这个可以确定先后启动的顺序</li></ol><p>我们以官方的例子来讲解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initializes WorkManager.</span><br><span class="line">class WorkManagerInitializer : Initializer&lt;WorkManager&gt; &#123;</span><br><span class="line">    override fun create(context: Context): WorkManager &#123;</span><br><span class="line">        val configuration &#x3D; Configuration.Builder().build()</span><br><span class="line">        WorkManager.initialize(context, configuration)</span><br><span class="line">        return WorkManager.getInstance(context)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; No dependencies on other libraries.</span><br><span class="line">        return emptyList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WorkManagerInitializer 返回一个 WorkManager，它不需要依赖于其他的 Initializer，直接返回 emptyList() 即可。</p><p>如果需要依赖其他的 Initializer，重写 dependencies 方法，返回即可。如下面的 ExampleLoggerInitializer 依赖于 WorkManagerInitializer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initializes ExampleLogger.</span><br><span class="line">class ExampleLoggerInitializer : Initializer&lt;ExampleLogger&gt; &#123;</span><br><span class="line">    override fun create(context: Context): ExampleLogger &#123;</span><br><span class="line">        &#x2F;&#x2F; WorkManager.getInstance() is non-null only after</span><br><span class="line">        &#x2F;&#x2F; WorkManager is initialized.</span><br><span class="line">        return ExampleLogger(WorkManager.getInstance(context))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun dependencies(): List&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; Defines a dependency on WorkManagerInitializer so it can be</span><br><span class="line">        &#x2F;&#x2F; initialized after WorkManager is initialized.</span><br><span class="line">        return listOf(WorkManagerInitializer::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  ExampleLogger(val workManager: WorkManager)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：在 AndroidManifest 里面配置自定义的 InitializationProvider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">    &lt;!-- This entry makes ExampleLoggerInitializer discoverable. --&gt;</span><br><span class="line">    &lt;meta-data  android:name&#x3D;&quot;com.xj.anchortask.appstartup.ExampleLoggerInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure><p>它是有固定格式的，配置者只需要配置 meta-data 中的 name 即可。<br><code>android:name=&quot;com.xj.anchortask.appstartup.ExampleLoggerInitializer&quot;</code> 这里的 name 是我们自定义的 Initializer 全路径。</p><p>程序运行跑起来，可以看到以下输出结果，符合我们的预期</p><blockquote><p>2021-04-17 17:48:42.049 28059-28059/com.xj.anchortask I/AnchorTaskApplication: attachBaseContext:<br>2021-04-17 17:48:42.077 28059-28059/com.xj.anchortask I/AnchorTaskApplication: create: WorkManagerInitializer init<br>2021-04-17 17:48:42.077 28059-28059/com.xj.anchortask I/AnchorTaskApplication: create: ExampleLoggerInitializer init<br>2021-04-17 17:48:42.084 28059-28059/com.xj.anchortask I/AnchorTaskApplication: onCreate: </p></blockquote><h2 id="AppStartUp-进阶使用"><a href="#AppStartUp-进阶使用" class="headerlink" title="AppStartUp 进阶使用"></a>AppStartUp 进阶使用</h2><h3 id="手动初始化"><a href="#手动初始化" class="headerlink" title="手动初始化"></a>手动初始化</h3><p>上面我们讲解了 AppStartUp 的基本使用步骤，如果我们不像在 Application onCreate 之前执行我们的 ExampleLoggerInitializer，要怎么使用呢？</p><p>其实很简单，</p><ol><li>第一步，在 AndroidManifest InitializationProvider 中移除 移除 <code>&lt;meta-data</code> 标签</li><li>在代码中调用 AppInitializer initializeComponent 方法初始化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppInitializer.getInstance(context).initializeComponent(ExampleLoggerInitializer::class.java)</span><br></pre></td></tr></table></figure><h2 id="App-start-up-源码分析"><a href="#App-start-up-源码分析" class="headerlink" title="App start up 源码分析"></a>App start up 源码分析</h2><p>我们首先来看一下他的结构，只有简单的几个类</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210417180733.png"></p><p><strong>Initializer</strong> 这个接口就没有必要说了，很简单，只有两个方法。</p><p><strong>InitializationProvider</strong> 继承了 ContentProvider，借助了 ContentProvider 会在 Application onCreate 之前执行的特点。来执行一些初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class InitializationProvider extends ContentProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onCreate() &#123;</span><br><span class="line">        Context context &#x3D; getContext();</span><br><span class="line">        if (context !&#x3D; null) &#123;</span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new StartupException(&quot;Context cannot be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ----</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到在 onCreate 方法中调用  AppInitializer discoverAndInitialize 方法进行初始化。</p><ol><li>找到 AndroidManifest InitializationProvider 下的 meta 便签</li><li>判断 meta 便签下 value 的值是不是 androidx.startup</li><li>判断是不是实现 Initializer 接口，是的话，执行 doInitialize 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void discoverAndInitialize() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.beginSection(SECTION_NAME);</span><br><span class="line">        ComponentName provider &#x3D; new ComponentName(mContext.getPackageName(),</span><br><span class="line">                InitializationProvider.class.getName());</span><br><span class="line">        ProviderInfo providerInfo &#x3D; mContext.getPackageManager()</span><br><span class="line">                .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">        Bundle metadata &#x3D; providerInfo.metaData;</span><br><span class="line">        String startup &#x3D; mContext.getString(R.string.androidx_startup);</span><br><span class="line">        &#x2F;&#x2F; 找到 metadata 标签</span><br><span class="line">        if (metadata !&#x3D; null) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; initializing &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">            Set&lt;String&gt; keys &#x3D; metadata.keySet();</span><br><span class="line">            for (String key : keys) &#123;</span><br><span class="line">                String value &#x3D; metadata.getString(key, null);</span><br><span class="line">                &#x2F;&#x2F; 判断 value 的值是不是 androidx.startup</span><br><span class="line">                &#x2F;&#x2F; 判断是不是实现了 Initializer 接口，是的话，反射初始化</span><br><span class="line">                if (startup.equals(value)) &#123;</span><br><span class="line">                    Class&lt;?&gt; clazz &#x3D; Class.forName(key);</span><br><span class="line">                    if (Initializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Class&lt;? extends Initializer&lt;?&gt;&gt; component &#x3D;</span><br><span class="line">                                (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz;</span><br><span class="line">                        mDiscovered.add(component);</span><br><span class="line">                        if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                            StartupLogger.i(String.format(&quot;Discovered %s&quot;, key));</span><br><span class="line">                        &#125;</span><br><span class="line">                        doInitialize(component, initializing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (PackageManager.NameNotFoundException | ClassNotFoundException exception) &#123;</span><br><span class="line">        throw new StartupException(exception);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>doInitialize 方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T doInitialize(</span><br><span class="line">        @NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span><br><span class="line">        @NonNull Set&lt;Class&lt;?&gt;&gt; initializing) &#123;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        boolean isTracingEnabled &#x3D; Trace.isEnabled();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isTracingEnabled) &#123;</span><br><span class="line">                &#x2F;&#x2F; Use the simpleName here because section names would get too big otherwise.</span><br><span class="line">                Trace.beginSection(component.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            if (initializing.contains(component)) &#123;</span><br><span class="line">                String message &#x3D; String.format(</span><br><span class="line">                        &quot;Cannot initialize %s. Cycle detected.&quot;, component.getName()</span><br><span class="line">                );</span><br><span class="line">                throw new IllegalStateException(message);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result;</span><br><span class="line">            if (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                initializing.add(component);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object instance &#x3D; component.getDeclaredConstructor().newInstance();</span><br><span class="line">                    Initializer&lt;?&gt; initializer &#x3D; (Initializer&lt;?&gt;) instance;</span><br><span class="line">                    List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies &#x3D;</span><br><span class="line">                            initializer.dependencies();</span><br><span class="line"></span><br><span class="line">                    if (!dependencies.isEmpty()) &#123;</span><br><span class="line">                        for (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                            if (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                                doInitialize(clazz, initializing);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initializing %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result &#x3D; initializer.create(mContext);</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initialized %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    initializing.remove(component);</span><br><span class="line">                    mInitialized.put(component, result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    throw new StartupException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result &#x3D; mInitialized.get(component);</span><br><span class="line">            &#125;</span><br><span class="line">            return (T) result;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在执行初始化的时候，先判断了是否有依赖项，有的话先执行依赖项的初始化</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>App start up，我觉得他的设计初衷应该是为了收拢 ContentProvider，实际上对启动优化的帮助不是很大。</li><li>如果你的项目都是同步初始化的话，并且使用到了多个ContentProvider，App Startup可能有一定的优化空间，毕竟统一到了一个ContentProvider中，同时支持了简单的顺序依赖。</li><li>ContentProvider 初始化的这个思想，目前有挺多 SDK 这么做的，像 FaceBook 广告 SDK，友盟 SDk 等。我们在启动优化的时候，是不是可以去掉相应的 ContentProvider，减少创建 Provider 的时间</li><li>实际项目中 启动优化，大多数啊都会使用多线程异步加载，这时候 App start up 就显得很鸡肋了，没用</li></ul><p><strong>参考博客：</strong><br><a href="https://blog.csdn.net/guolin_blog/article/details/108026357">Jetpack新成员，App Startup一篇就懂</a></p><blockquote><p>本文收录于 <a href="https://github.com/gdutxiaoxu/AndroidGuide">https://github.com/gdutxiaoxu/AndroidGuide</a> 「Android学习+面试指南」一份涵盖大部分 Android 程序员所需要掌握的核心知识。准备 Android 面试，首选 AndroidGuide！微信公众号：<strong>程序员徐公</strong></p></blockquote><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%20(new).png"></p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（七） - JetPack App Startup 使用及源码浅析
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>2021 Android 如何自学，Android 学习路线分享，一位 5 年中大厂老哥跟你聊聊</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/04/18/2021-Android-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%EF%BC%8CAndroid-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%88%86%E4%BA%AB%EF%BC%8C%E4%B8%80%E4%BD%8D-5-%E5%B9%B4%E4%B8%AD%E5%A4%A7%E5%8E%82%E8%80%81%E5%93%A5%E8%B7%9F%E4%BD%A0%E8%81%8A%E8%81%8A/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/04/18/2021-Android-如何自学，Android-学习路线分享，一位-5-年中大厂老哥跟你聊聊/</id>
    <published>2021-04-18T02:11:58.000Z</published>
    <updated>2021-04-18T14:17:29.333Z</updated>
    
    <content type="html"><![CDATA[<p>光阴似箭，日月如梭，时间真的过得飞快。<br>加上实习，从事 Android 开发，差不多有 5 年了，在这里，我分享一下我的经验，在 Android 的学习路上，我是站在巨人的肩膀上成长起来的。</p><p>大概分为三个部分</p><blockquote><p>一、Android 职业规划<br>二、Android 学习路线<br>三、如何进入大厂<br>三、Android 学习资料分享</p></blockquote><h1 id="Android-成长生涯"><a href="#Android-成长生涯" class="headerlink" title="Android 成长生涯"></a>Android 成长生涯</h1><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E6%88%90%E9%95%BF%E9%98%B6%E6%A2%AF.jpeg"></p><h2 id="1-3-年"><a href="#1-3-年" class="headerlink" title="1-3 年"></a>1-3 年</h2><p>前 3 年，我觉得是我们成长最快的时候。</p><p>尤其是刚开始工作的一年，刚开始接触项目，我们会接触到很多新知识，比较网络框架的封装，Android 架构 MVVN，MVC，MVP 等。</p><p><strong>这段时期是我们进步最快的时候，因为很多东西我们都不会，我们会逼着自己去学习。</strong></p><p>第二到第三年，也是我们成长的关键时期。这时候，在项目中，我们基本会自己独立负责需求。这时候的我们，大多数基本功能都可以自己独立实现。需要注意的是<strong>代码风格和代码思维的培养</strong>。</p><p><strong>代码风格</strong>，指的是编码习惯。比如方法命名，方法的合理拆分，适当添加注解，注释。听起来可能会很虚，但是千万别小看这些细节。反正我在组里见过一些工作五六年的，代码一坨一坨的，像 si 一样。</p><p><strong>代码思维</strong>，有点类似于人的视野和思考方式吧。很多时候，实现某个效果，有很多种方案。我们为了应付需求，可能会随便选择一种，没有去了解其他方案。而这恰恰错过了我们成长的最佳时期。</p><p><strong>记住，永远别给自己设限，或许在编程的路上会遇到很多问题，但是总会有解决方法的，而这取决你的态度。</strong></p><h2 id="3-5-年"><a href="#3-5-年" class="headerlink" title="3-5 年"></a>3-5 年</h2><p>这个时期，不出意外，我们基本都是高级工程师了。这时候大多数人会遇到瓶颈，<strong>不知道学些什么好。好像什么都会，但是不够深入</strong>。我也遇到这样的情况，现在正在深挖。</p><p>这方面我暂时也给不了太多意见，只能说，选择一个方向，静下心来，去学习，相信能收获到我们想要的。</p><p>学习方向有很多，比如 Android 性能优化（启动，卡顿， Crash 治理）， JNI C++，gradle 打包，编译速度，音视频等等，这些都是大的方向。</p><p><strong>最近写的一些文章，自我感觉还行，有兴趣的可以看看。</strong></p><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><h2 id="5-年之后"><a href="#5-年之后" class="headerlink" title="5 年之后"></a>5 年之后</h2><p><a href="https://mp.weixin.qq.com/s/xCFa2pHxhFGdn51dWoDdQg">技术人的四大出路，你适合哪一个</a></p><p>大多数技术人，一般会有以下方向。</p><ul><li>第一：成为技术大神，比如架构师，及技术专家等。</li><li>第二：技术管理，比如技术总监等。</li><li>第三：技术转型，如转项目管理，产品等，你牛逼的话，说不定下一个张小龙就是你（哥们，想多了，那有这么容易）。</li><li>第四：自主创业，做自媒体等</li></ul><p>我目前来说，可能会选择第一条路吧，成为一名技术专家。</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210410172556.png"></p><p><strong>在技术的路上，或许会很累，很难，可那又怎样呢</strong></p><p>35 岁中年职业危机，很多职业都有，不仅仅局限于程序员。</p><p>从本质上面说，自身竞争力下降占很大原因。毕竟，优秀的人才从来不缺少机会。</p><p><strong>既然选择了，便只顾风雨兼程。</strong></p><p>为了未来有更多的选择，从现在开始，朝着自己的目标努力奋斗吧，书写属于自己的人生。</p><hr><h1 id="Android-学习路线"><a href="#Android-学习路线" class="headerlink" title="Android 学习路线"></a>Android 学习路线</h1><p><strong>下面，说一下 Android 的学习路线，不会很具体，主要是从大的方面来说，感兴趣的可以看一下。</strong></p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210410174904.png"></p><h2 id="搭建基本的开发环境，敲下-Hello-world"><a href="#搭建基本的开发环境，敲下-Hello-world" class="headerlink" title="搭建基本的开发环境，敲下 Hello world"></a>搭建基本的开发环境，敲下 Hello world</h2><p>首先你配置好电脑开发环境。首先需要配置 Java，AndroidStudio 的开发环境。</p><p>现在的 IDE 对比几年前的，真的是方便多了，可以自动帮我们配置好环境变量。还记得当年刚开始配环境的时候，<strong>折腾了两三天。在配置变量的时候，有时候英文的逗号输成中文的，在 cmd 窗口输入 Java，一直提醒没有这个命令，一把鼻涕一行泪</strong>。</p><p><strong>依稀还记得，当配置完环境之后，敲下第一段程序 <em>Hello world</em> 时的那份喜悦。</strong></p><h2 id="掌握基本的语法和常用的数据结构"><a href="#掌握基本的语法和常用的数据结构" class="headerlink" title="掌握基本的语法和常用的数据结构"></a>掌握基本的语法和常用的数据结构</h2><p>第一：你要先掌握基本的语法，可以从一些书籍开始学起。跟着书本慢慢敲，从第一个程序 Hello World 慢慢敲起，<strong>万丈高楼平地起</strong>。</p><p>由于 Android 是用 java 或者 kotlin 语言开发的，建议优先掌握 java 语言。这里推荐两本书籍。</p><ol><li>java 编程思想，一本很经典的 java 书籍</li><li>java 剑指 offer，面试神器。校招的时候，有很多面试题目，里面都有涉及到。</li></ol><p>第二：掌握基本的语法之后，常用的数据结构，数组，链表，队列，栈。这些基本的概念和语法要知道。还有线程，文件 IO 操作，网络操作。</p><p>学完这些之后，Java 的基本知识你大概掌握了，这时候建议你动手写一些小项目或者 Demo，比如坦克大战，计算器等，这些网上都有代码。想跟着视频一起学的话，推荐马士兵的视频，可以在我的微信公众号 <strong>程序员徐公</strong> 回复”<strong>Java</strong>“，会将教程发给你</p><h2 id="Android-学习入门"><a href="#Android-学习入门" class="headerlink" title="Android 学习入门"></a>Android 学习入门</h2><p>掌握这些之后，你可以去看一些 Android 入门的书籍或者一些视频。</p><p>书籍我推荐郭霖的第一行代码，目前出了第三版了，写得真不错。</p><p>视频的话，我推荐你可以看黑马的 Android 视频，里面会从一些基本语法讲起，接着是项目实战，会手把手教你实现简单的新闻客户端，360 手机卫士等等。</p><p>想获取黑马视频资料的话，可以去我的微信公众号<strong>程序员徐公</strong>回复”<strong>黑马</strong>“两字，会将教程发给你。</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/20210410183019.png"></p><h2 id="Android-进阶"><a href="#Android-进阶" class="headerlink" title="Android 进阶"></a>Android 进阶</h2><p>学习完基本的知识之后，可以去看看任玉刚的 Android 开发艺术探索，虽然是几年前出版的，但真的是精华。</p><p>接着，可以关注一些架构，性能优化方面的。</p><ul><li>MVC， MVP， MVVN</li><li>内存泄露怎么检测，常见的内存泄露有哪些</li><li>怎么检测 ANR，有哪些手段呢，优缺点是什么</li><li>怎么捕获 Crash，Java Crash 和 native crash 有哪些不同呢</li><li> Android 检测启动时间，启动优化怎么做，常见的 Android 启动优化手段有哪些</li><li>Android gradle，是怎样打包的，怎样提高编译速度</li></ul><p><strong>这里推荐几篇不错的文章</strong>。</p><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><h2 id="关注前沿技术"><a href="#关注前沿技术" class="headerlink" title="关注前沿技术"></a>关注前沿技术</h2><p>关注前沿技术，可以去一些论坛，公众号上面逛逛。</p><p>论坛的话，推荐掘金，CSDN</p><p> Android 技术公众号的话，推荐鸿洋，郭霖的公众号，当然还有我的公众号<strong>程序员徐公</strong>。文章的质量算是比较高的。</p><p> 最后，有空的时候多去 <a href="https://github.com/">github</a> 或者 <a href="https://developer.android.com/">google 官网</a> 看看，有什么新技术，一般第一时间会更新。</p><hr><h1 id="如何进入大厂"><a href="#如何进入大厂" class="headerlink" title="如何进入大厂"></a>如何进入大厂</h1><p>面试是一个双向选择的过程，我们要保持足够的自信。</p><p>在我看来，要进入大厂，有 4 点最重要。</p><ol><li>编程能力，包括常用技术以及常用技术的原理，<strong>毕竟招人，是来干活的，不是来当爹的</strong>。</li><li>技术深度，在大厂，分工越来越越明确，职责越来越细。很多时候，需要的是某一个技术领域的人才，而不是什么都懂一点的全才。</li><li>算法。</li><li>软技能，沟通能力等</li></ol><h2 id="如何学习算法"><a href="#如何学习算法" class="headerlink" title="如何学习算法"></a>如何学习算法</h2><p>现如今，如果你想进入大厂，腾讯，阿里，头条，拼多多等，不管是社招还是校招，肯定都会面试到算法的。</p><p>相信很多人有这样的想法，<strong>面试的时候早火箭，工作的时候拧螺丝</strong>。确实，这种情况非常常见，我也认同。但没办法，谁叫我们想进入大厂呢。</p><p><strong>不过，这种情况也可以理解。怎么在几轮面试中确定面试者的水平呢？<br>肯定是考察算法，基础这些，原理这些</strong>。</p><p>虽然这些代表不了全部，但起码能在一定程度上代表了面试者的水平能力。要知道，<strong>编程语言其实都是想通的，编程思维和算法能力才是核心。</strong></p><p>掌握了原理，编程思维，切换到另外一门语言其实是很快的。这也就是面试官喜欢考察算法和原理的原因。</p><p><strong>至于要怎么学习算法，我简单归纳一下</strong></p><p>第一：要了解基本的数据结果，数组，链表，Map，Set，二叉树等，了解他们的优缺点，时间复杂度，空间复杂度等</p><p>第二：要掌握一些常见的算法，递归，迭代，八大排序，二分查找，贪心算法等</p><p>第三：掌握一种算法，不仅要知道 what，还要知道 why（分析各种算法的优缺点），比如 topK问题，有常见的几种解决方案，排序，快排思想，海量数据堆排序</p><p>第四：刚开始学的时候，可能会比较吃力，<strong>可以先刷题，慢慢找感觉，从易到难</strong>。</p><ul><li>比如，第一天，你刷这道算法题的时候看不懂，先不用着急，很多人都是这样过来的，先搜一下答案，看一下别人是怎么解决的。</li><li>看懂了之后，自己用代码写一遍，跑一遍。这很重要，很多时候，你以为你自己懂了，但当你在写的时候是写不出来的，在你动手写代码时，会不断加深你的印象</li><li>第二天，自己再写一遍，加深印象</li></ul><p>第五：学好算法不是一日之功，需要长期的积累。建议的做法是每天做一两道题，题目不在多，贵在于理解。坚持一两个月，你会发现你的感觉逐渐好起来了。</p><p><a href="https://github.com/gdutxiaoxu/Android_interview">https://github.com/gdutxiaoxu/Android_interview</a></p><h1 id="Android-学习资料分析"><a href="#Android-学习资料分析" class="headerlink" title="Android 学习资料分析"></a>Android 学习资料分析</h1><h2 id="黑马-52-期不加密视频"><a href="#黑马-52-期不加密视频" class="headerlink" title="黑马 52 期不加密视频"></a>黑马 52 期不加密视频</h2><p><strong>获取方式在微信公众号 “程序员徐公” 回复“黑马” 两字</strong></p><blockquote><p>01、安卓基础+JNI (14天)<br>02、Android应用开 发-代码版本管理和实战(1天)<br>03、android案例与项目_手机安全卫士(12天)<br>04、自定义控件与视图(2天)<br>05、android项目 实战_智慧北京(6天)<br>06、android项 目实战_谷歌应用市场(6天)<br>07、android进阶 高阶案例-QQ5.0特效专辑(2天)<br>08、android游戏开发_ 植物大战僵尸(3天)<br>09、android案例与项目_ 百度地图(1天_ 补充)<br>10、android项目实战_智能短信管理(3天_ <em>补充)<br>11、Android</em> _WebView&amp;HTML5开发(1天 _补充) </p></blockquote><h2 id="Java-马士兵视频"><a href="#Java-马士兵视频" class="headerlink" title="Java  马士兵视频"></a>Java  马士兵视频</h2><p><strong>获取方式在微信公众号 “程序员徐公” 回复“java” 两字</strong></p><p><strong>第一部分：J2se学习视频内容包括：</strong></p><blockquote><p>尚学堂科技_马士兵_JAVA视频教程_JDK5.0_下载-安装-配置<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第01章_JAVA简介_源代码_及重要说明<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第02章_递归补充<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第02章_基础语法<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第03章_面向对象<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第04章_异常处理<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第05章_数组<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第06章_常用类<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第07章_容器<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第08章_IO<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第09章_线程<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第10章_网络<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_第11章_GUI<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_5.0_专题_日期处理<br>尚学堂科技_马士兵_JAVA视频教程_J2SE_专题_正则表达式</p></blockquote><p><strong>第二部分：j2se练习项目视频内容包括：</strong></p><p>第二部分：j2se练习项目视频内容包括：</p><blockquote><p>尚学堂科技_马士兵_在线聊天系统雏形视频教程_java_eclipse<br>尚学堂科技_马士兵_坦克大战视频教程_java_eclipse<br>尚学堂科技_马士兵_坦克大战图片版<br>尚学堂科技_马士兵_JAVA_坦克大战网络版视频教程<br>尚学堂科技_马士兵_snake_贪吃蛇内部视频</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上是我这些年来， Android 学习路上的一些简单分享。在 Android 的学习路上，我是站在巨人的肩膀上成长起来的，同样，我也希望成为你们的巨人。</p><p>希望我们可以成为朋友，成长路上的忠实伙伴！</p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%EF%BC%88%E4%B8%8D%E5%B8%A6%E6%B0%B4%E5%8D%B0%EF%BC%89.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;光阴似箭，日月如梭，时间真的过得飞快。&lt;br&gt;加上实习，从事 Android 开发，差不多有 5 年了，在这里，我分享一下我的经验，在 Android 的学习路上，我是站在巨人的肩膀上成长起来的。&lt;/p&gt;
&lt;p&gt;大概分为三个部分&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一、
      
    
    </summary>
    
    
      <category term="个人总结" scheme="https://gdutxiaoxu.gitee.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>黑马 Android 52 期学习视频，不加密的，免费分享给大家</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/04/17/%E9%BB%91%E9%A9%AC-Android-52-%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%EF%BC%8C%E4%B8%8D%E5%8A%A0%E5%AF%86%E7%9A%84%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/04/17/黑马-Android-52-期学习视频，不加密的，免费分享给大家/</id>
    <published>2021-04-17T14:33:13.000Z</published>
    <updated>2021-05-11T15:21:19.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-黑马学习视频"><a href="#Android-黑马学习视频" class="headerlink" title="Android 黑马学习视频"></a>Android 黑马学习视频</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>01、安卓基础+JNI (14天)</li><li>02、Android应用开 发-代码版本管理和实战(1天)</li><li>03、android案 例与项目_手机安全卫士(12天)</li><li>04、自定义控件与视图(2天)</li><li>05、android项目实战_ 智慧北京(6天)</li><li>06、android项目实战_谷歌应用市场(6天)</li><li>07、android进阶高阶案例-QQ5.0特效专辑(2天)</li><li>08、android游戏开发_植物大战僵尸(3天)</li><li>09、android案例与项目_ .百度地图(1天_ 补充)</li><li>10、android项目实战_ 智能短信管理(3天_ 补充)</li><li>11、Android_ <em>WebView&amp;HTML5开发(1天</em> 补充)</li></ul><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><p><a href="https://pan.baidu.com/s/123PF5W2t1SgjQ9wpoFW7Rg">百度云链接</a></p><p><a href="https://github.com/gdutxiaoxu/Android_interview">Android 学习 + 面试指南：</a></p><p>如果链接过期了，可以关注我的微信公众号“<strong>程序员徐公</strong>”，回复“<strong>黑马</strong>“两字，会自动发给你</p><ol><li>公众号程序员徐公回复<strong>黑马</strong>，获取 Android 学习视频</li><li>公众号程序员徐公回复<strong>徐公666</strong>，获取简历模板，教你如何优化简历，走进大厂</li><li>公众号程序员徐公回复<strong>面试</strong>，可以获得面试常见算法，剑指 offer 题解</li><li>公众号程序员徐公回复<strong>马士兵</strong>，可以获得马士兵学习视频一份</li></ol><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/02/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BE%90%E5%85%AC%20(new).png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-黑马学习视频&quot;&gt;&lt;a href=&quot;#Android-黑马学习视频&quot; class=&quot;headerlink&quot; title=&quot;Android 黑马学习视频&quot;&gt;&lt;/a&gt;Android 黑马学习视频&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot;
      
    
    </summary>
    
    
      <category term="Android 学习资料" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（六） - 深入理解布局优化</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/02/27/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E5%85%AD%EF%BC%89-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/02/27/Android 启动优化（六）- 深入理解布局优化/</id>
    <published>2021-02-27T15:47:15.000Z</published>
    <updated>2021-04-22T09:18:31.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br>我的掘金：<a href="https://juejin.im/user/2207475076966584">https://juejin.im/user/2207475076966584</a>  <br><br>github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br>微信公众号：程序员徐公 <br></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到 Android 启动优化，你一般会想到什么呢？</p><ol><li>Android 多线程异步加载</li><li>Android 首页懒加载</li></ol><p>对，这是两种很常见的优化手段，但是如果让你主导这件事情，你会如何开始呢？</p><ol><li>梳理现有的业务，哪些是一定要在启动初始化的，哪些是不必要的</li><li>需要在启动初始化的，哪些是可以在主线程初始化的，哪些是可以在子线程初始化的</li></ol><p>当我们把任务丢到子线程初始化，这时候，我们又会遇到两个问题。</p><ol><li>在首页，我们需要用到这个库，如果直接使用，这个库可能还没有初始化，这时候直接调用该库，会发生异常，你要怎么解决</li><li>当我们的任务相互依赖时，比如 A 依赖于 B， C 也依赖于 B，要怎么解决这种依赖关系。</li></ol><p>这些你有想过嘛。答案都在这几篇文章里面了，这里我就不展开讲了，有兴趣的可以看一下。</p><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><strong>接下来，我们来说一下布局优化相关的。</strong></p><h1 id="布局优化的现状与发展趋势"><a href="#布局优化的现状与发展趋势" class="headerlink" title="布局优化的现状与发展趋势"></a>布局优化的现状与发展趋势</h1><h2 id="耗时原因"><a href="#耗时原因" class="headerlink" title="耗时原因"></a>耗时原因</h2><p>众所周知，布局加载一直是耗时的重灾区。特别是启动阶段，作为第一个 View 加载，更是耗时。</p><p>而布局加载之所以耗时，有两个原因。</p><ol><li>读取 xml 文件，这是一个 IO 操作。</li><li>解析 xml 对象，反射创建 View</li></ol><p>一些很常见的做法是</p><ol><li>减少布局嵌套层数，减少过度绘制</li><li>空界面，错误界面等界面进行懒加载</li></ol><p> 那除了这些做法，我们还有哪些手段可以优化呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>异步加载</li><li>采用代码的方式编写布局</li></ol><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>google 很久之前提供了 AsyncLayoutInflater，异步加载的方案，不过这种方式有蛮多坑的，下文会介绍</p><h3 id="采用代码的方式编写布局"><a href="#采用代码的方式编写布局" class="headerlink" title="采用代码的方式编写布局"></a>采用代码的方式编写布局</h3><p>代码编写的方式编写布局，我们可能想到使用 java 声明布局，对于稍微复杂一点的布局，这种方式是不可取的，存在维护性查，修改困难等问题。为了解决这个问题，github 上面诞生了一系列优秀的开源库。</p><p><a href="https://github.com/facebook/litho">litho</a></p><p><a href="https://github.com/iReaderAndroid/X2C">X2C</a></p><blockquote><p>为了即保留xml的优点，又解决它带来的性能问题，我们开发了X2C方案。即在编译生成APK期间，将需要翻译的layout翻译生成对应的java文件，这样对于开发人员来说写布局还是写原来的xml，但对于程序来说，运行时加载的是对应的java文件.<br/><br>我们采用APT（Annotation Processor Tool）+ JavaPoet技术来完成编译期间【注解】-&gt;【解注解】-&gt;【翻译xml】-&gt;【生成java】整个流程的操作。</p></blockquote><p><strong>这两个开源库在大型的项目基本不会使用，不过他们的价值是值得肯定的，核心思想很有意义</strong>。</p><p>xml 布局加载耗时的问题， google 也想改善这种现状，最近 Compose beta 发布了，他是采用声明式 UI 的方式来编写布局，避免了 xml 带来的耗时。同时，还支持布局实时预览。这个应该是以后的发展趋势。</p><p><a href="https://github.com/android/compose-samples">compose-samples</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面讲了布局优化的现状与发展趋势，接下来我们一起来看一下，有哪些布局优化手段，可以应用到项目中的。</p><ol><li>渐进式加载</li><li>异步加载</li><li>compose 声明式 UI</li></ol><h1 id="渐进式加载"><a href="#渐进式加载" class="headerlink" title="渐进式加载"></a>渐进式加载</h1><h2 id="什么是渐进式加载"><a href="#什么是渐进式加载" class="headerlink" title="什么是渐进式加载"></a>什么是渐进式加载</h2><p>渐进式加载，简单来说，就是一部分一部分加载，当前帧加载完成之后，再去加载下一帧。</p><p>一种极致的做法是，加载 xml 文件，就想加载一个空白的 xml，布局全部使用 ViewStub 标签进行懒加载。</p><p>这样设计的好处是可以减缓同一时刻，加载 View 带来的压力，通常的做法是我们先加载核心部分的 View，再逐步去加载其他 View。</p><p>有人可能会这样问了，这样的设计很鸡肋，有什么用呢？</p><p><strong>确实，在高端机上面作用不明显，甚至可能看不出来，但是在中低端机上面，带来的效果还是很明显的</strong>。在我们项目当中，复杂的页面首帧耗时约可以减少 30%。</p><p><strong>优点</strong>：适配成本低，在中低端机上面效果明显。</p><p><strong>缺点</strong>：还是需要在主线程读取 xml 文件</p><h2 id="核心伪代码"><a href="#核心伪代码" class="headerlink" title="核心伪代码"></a>核心伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start()&#123;</span><br><span class="line">    loadA()&#123;</span><br><span class="line">        loadB()&#123;</span><br><span class="line">            loadC()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种写法，是可以的，但是这种做法，有一个很明显的缺点，就是会造成回调嵌套层数过多。当然，我们也可以使用 RxJava 来解决这种问题。但是，如果项目中没用 Rxjava，引用进来，会造成包 size 增加。</p><p>一个简单的做法就是<strong>使用队列的思想，将所有的 ViewStubTask 添加到队列当中，当当前的 ViewStubTask 加载完成，才加载下一个</strong>，这样可以避免回调嵌套层数过多的问题。</p><p>改造之后的代码见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val decorView &#x3D; this.window.decorView</span><br><span class="line">ViewStubTaskManager.instance(decorView)</span><br><span class="line">            .addTask(ViewStubTaskContent(decorView))</span><br><span class="line">            .addTask(ViewStubTaskTitle(decorView))</span><br><span class="line">            .addTask(ViewStubTaskBottom(decorView))</span><br><span class="line">            .start()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">class ViewStubTaskManager private constructor(val decorView: View) : Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private var iViewStubTask: IViewStubTask? &#x3D; null</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        const val TAG &#x3D; &quot;ViewStubTaskManager&quot;</span><br><span class="line"></span><br><span class="line">        @JvmStatic</span><br><span class="line">        fun instance(decorView: View): ViewStubTaskManager &#123;</span><br><span class="line">            return ViewStubTaskManager(decorView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private val queue: MutableList&lt;ViewStubTask&gt; &#x3D; CopyOnWriteArrayList()</span><br><span class="line">    private val list: MutableList&lt;ViewStubTask&gt; &#x3D; CopyOnWriteArrayList()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun setCallBack(iViewStubTask: IViewStubTask?): ViewStubTaskManager &#123;</span><br><span class="line">        this.iViewStubTask &#x3D; iViewStubTask</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun addTask(viewStubTasks: List&lt;ViewStubTask&gt;): ViewStubTaskManager &#123;</span><br><span class="line">        queue.addAll(viewStubTasks)</span><br><span class="line">        list.addAll(viewStubTasks)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun addTask(viewStubTask: ViewStubTask): ViewStubTaskManager &#123;</span><br><span class="line">        queue.add(viewStubTask)</span><br><span class="line">        list.add(viewStubTask)</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fun start() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        iViewStubTask?.beforeTaskExecute()</span><br><span class="line">        &#x2F;&#x2F; 指定 decorView 绘制下一帧的时候会回调里面的 runnable</span><br><span class="line">        ViewCompat.postOnAnimation(decorView, this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun stop() &#123;</span><br><span class="line">        queue.clear()</span><br><span class="line">        list.clear()</span><br><span class="line">        decorView.removeCallbacks(null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun isEmpty() &#x3D; queue.isEmpty() || queue.size &#x3D;&#x3D; 0</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        if (!isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当队列不为空的时候，先加载当前 viewStubTask</span><br><span class="line">            val viewStubTask &#x3D; queue.removeAt(0)</span><br><span class="line">            viewStubTask.inflate()</span><br><span class="line">            iViewStubTask?.onTaskExecute(viewStubTask)</span><br><span class="line">            &#x2F;&#x2F; 加载完成之后，再 postOnAnimation 加载下一个</span><br><span class="line">            ViewCompat.postOnAnimation(decorView, this)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            iViewStubTask?.afterTaskExecute()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnDetach() &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.onDetach()</span><br><span class="line">        &#125;</span><br><span class="line">        list.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnDataReady() &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.onDataReady()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IViewStubTask &#123;</span><br><span class="line"></span><br><span class="line">    fun beforeTaskExecute()</span><br><span class="line"></span><br><span class="line">    fun onTaskExecute(viewStubTask: ViewStubTask)</span><br><span class="line"></span><br><span class="line">    fun afterTaskExecute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址：<a href="https://github.com/gdutxiaoxu/AnchorTask%EF%BC%8C**%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E4%B8%BB%E8%A6%81%E5%9C%A8">https://github.com/gdutxiaoxu/AnchorTask，**核心代码主要在</a> <code>ViewStubTask</code>，<code>ViewStubTaskManager</code>**, 有兴趣的可以看看</p><h1 id="异步加载-1"><a href="#异步加载-1" class="headerlink" title="异步加载"></a>异步加载</h1><p>异步加载，简单来说，就是在子线程创建 View。在实际应用中，我们通常会先预加载 View，常用的方案有：</p><ol><li>在合适的时候，启动子线程 inflate layout。然后取的时候，直接去缓存里面查找 View 是否已经创建好了，是的话，直接使用缓存。否则，等待子线程 inlfate 完成。</li></ol><h2 id="AsyncLayoutInflater"><a href="#AsyncLayoutInflater" class="headerlink" title="AsyncLayoutInflater"></a>AsyncLayoutInflater</h2><p>官方提供了一个类，可以来进行异步的inflate，但是有两个缺点：</p><ol><li>每次都要现场new一个出来</li><li>异步加载的view只能通过callback回调才能获得（死穴）</li></ol><p>因此，我们可以仿造官方的 AsyncLayoutInflater 进行改造。<strong>核心代码在 AsyncInflateManager</strong>。主要介绍两个方法。</p><p><code>asyncInflate</code> 方法，在子线程 inflateView，并将加载结果存放到 mInflateMap 里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    @UiThread</span><br><span class="line">fun asyncInflate(</span><br><span class="line">        context: Context,</span><br><span class="line">        vararg items: AsyncInflateItem?</span><br><span class="line">    ) &#123;</span><br><span class="line">        items.forEach &#123; item -&gt;</span><br><span class="line">            if (item &#x3D;&#x3D; null || item.layoutResId &#x3D;&#x3D; 0 || mInflateMap.containsKey(item.inflateKey) || item.isCancelled() || item.isInflating()) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            mInflateMap[item.inflateKey] &#x3D; item</span><br><span class="line">            onAsyncInflateReady(item)</span><br><span class="line">            inflateWithThreadPool(context, item)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>getInflatedView</code> 方法，用来获得异步inflate出来的view，核心思想如下</p><ul><li>先从缓存结果里面拿 View，拿到了view直接返回</li><li>没拿到view，但是子线程在inflate中，等待返回</li><li>如果还没开始inflate，由UI线程进行inflate</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 用来获得异步inflate出来的view</span><br><span class="line"> *</span><br><span class="line"> * @param context</span><br><span class="line"> * @param layoutResId 需要拿的layoutId</span><br><span class="line"> * @param parent      container</span><br><span class="line"> * @param inflateKey  每一个View会对应一个inflateKey，因为可能许多地方用的同一个 layout，但是需要inflate多个，用InflateKey进行区分</span><br><span class="line"> * @param inflater    外部传进来的inflater，外面如果有inflater，传进来，用来进行可能的SyncInflate，</span><br><span class="line"> * @return 最后inflate出来的view</span><br><span class="line"> *&#x2F;</span><br><span class="line">@UiThread</span><br><span class="line">fun getInflatedView(</span><br><span class="line">    context: Context?,</span><br><span class="line">    layoutResId: Int,</span><br><span class="line">    parent: ViewGroup?,</span><br><span class="line">    inflateKey: String?,</span><br><span class="line">    inflater: LayoutInflater</span><br><span class="line">): View &#123;</span><br><span class="line">    if (!TextUtils.isEmpty(inflateKey) &amp;&amp; mInflateMap.containsKey(inflateKey)) &#123;</span><br><span class="line">        val item &#x3D; mInflateMap[inflateKey]</span><br><span class="line">        val latch &#x3D; mInflateLatchMap[inflateKey]</span><br><span class="line">        if (item !&#x3D; null) &#123;</span><br><span class="line">            val resultView &#x3D; item.inflatedView</span><br><span class="line">            if (resultView !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;拿到了view直接返回</span><br><span class="line">                removeInflateKey(item)</span><br><span class="line">                replaceContextForView(resultView, context)</span><br><span class="line">                Log.i(TAG, &quot;getInflatedView from cache: inflateKey is $inflateKey&quot;)</span><br><span class="line">                return resultView</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (item.isInflating() &amp;&amp; latch !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;没拿到view，但是在inflate中，等待返回</span><br><span class="line">                try &#123;</span><br><span class="line">                    latch.await()</span><br><span class="line">                &#125; catch (e: InterruptedException) &#123;</span><br><span class="line">                    Log.e(TAG, e.message, e)</span><br><span class="line">                &#125;</span><br><span class="line">                removeInflateKey(item)</span><br><span class="line">                if (resultView !&#x3D; null) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;getInflatedView from OtherThread: inflateKey is $inflateKey&quot;)</span><br><span class="line">                    replaceContextForView(resultView, context)</span><br><span class="line">                    return resultView</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果还没开始inflate，则设置为false，UI线程进行inflate</span><br><span class="line">            item.setCancelled(true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, &quot;getInflatedView from UI: inflateKey is $inflateKey&quot;)</span><br><span class="line">    &#x2F;&#x2F;拿异步inflate的View失败，UI线程inflate</span><br><span class="line">    return inflater.inflate(layoutResId, parent, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单-Demo-示范"><a href="#简单-Demo-示范" class="headerlink" title="简单 Demo 示范"></a>简单 Demo 示范</h2><p>第一步：选择在合适的时机调用  <code>AsyncUtils#asyncInflate</code> 方法预加载 View，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object AsyncUtils &#123;</span><br><span class="line"></span><br><span class="line">    fun asyncInflate(context: Context) &#123;</span><br><span class="line">        val asyncInflateItem &#x3D;</span><br><span class="line">            AsyncInflateItem(</span><br><span class="line">                LAUNCH_FRAGMENT_MAIN,</span><br><span class="line">                R.layout.fragment_asny,</span><br><span class="line">                null,</span><br><span class="line">                null</span><br><span class="line">            )</span><br><span class="line">        AsyncInflateManager.instance.asyncInflate(context, asyncInflateItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun isHomeFragmentOpen() &#x3D;</span><br><span class="line">        getSP(&quot;async_config&quot;).getBoolean(&quot;home_fragment_switch&quot;, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在获取 View 的时候，先去缓存里面查找 View</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater, container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        &#x2F;&#x2F; Inflate the layout for this fragment</span><br><span class="line">        val startTime &#x3D; System.currentTimeMillis()</span><br><span class="line">        val homeFragmentOpen &#x3D; AsyncUtils.isHomeFragmentOpen()</span><br><span class="line">        val inflatedView: View</span><br><span class="line"></span><br><span class="line">        inflatedView &#x3D; AsyncInflateManager.instance.getInflatedView(</span><br><span class="line">            context,</span><br><span class="line">            R.layout.fragment_asny,</span><br><span class="line">            container,</span><br><span class="line">            LAUNCH_FRAGMENT_MAIN,</span><br><span class="line">            inflater</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        Log.i(</span><br><span class="line">            TAG,</span><br><span class="line">            &quot;onCreateView: homeFragmentOpen is $homeFragmentOpen, timeInstance is $&#123;System.currentTimeMillis() - startTime&#125;, $&#123;inflatedView.context&#125;&quot;</span><br><span class="line">        )</span><br><span class="line">        return inflatedView</span><br><span class="line">&#x2F;&#x2F;        return inflater.inflate(R.layout.fragment_asny, container, false)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><p>可以大大减少 View 创建的时间，使用这种方案之后，获取 View 的时候基本在 10ms 之内的。</p><p><strong>缺点</strong></p><ol><li>由于 View 是提前创建的，并且会存在在一个 map，需要根据自己的业务场景将 View 从 map 中移除，不然会发生内存泄露</li><li>View 如果缓存起来，记得在合适的时候重置 view 的状态，不然有时候会发生奇奇怪怪的现象。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <strong>参考文章</strong></p><p><a href="https://juejin.cn/post/6844903924965572615">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a></p><ol><li>View 的渐进式加载，在 JectPack compose 没有推广之后，推荐使用这种方案，适配成本低</li><li>View 的异步加载方案，虽然效果显著，但是适配成本也高，没搞好，容易发生内存泄露</li><li>JectPack compose 声明式 UI，基本是未来的趋势，有兴趣的可以提前了解一下他。</li></ol><p>这篇文章,加上一些 Demo，足足花了我几个晚上的时间，觉得不错的话可以关注一下我的微信公众号<strong>程序员徐公</strong>，小弟在此感谢各位大佬们。</p><p>源码地址：<a href="https://github.com/gdutxiaoxu/AnchorTask">https://github.com/gdutxiaoxu/AnchorTask</a></p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（六） - 深入理解布局优化
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（五） - AnchorTask 1.0.0 版本更新了</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/02/18/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89-%20%20AnchorTask%201.0.0%20%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%BA%86/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/02/18/Android 启动优化（五）-  AnchorTask 1.0.0 版本更新了/</id>
    <published>2021-02-18T15:47:15.000Z</published>
    <updated>2021-04-22T09:16:23.156Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f71791b5cb4f96984c4863e0b7fe18~tplv-k3u1fbpfcp-zoom-1.image">点此扫码关注</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周六，吃错了东西，突然头晕，发烧，半夜突然呕吐，拉肚子，整个人被折腾得够呛的。到医院检查，说是 xx 肠炎，吃错东西导致的，整整躺在家休息四天。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb71568b4c2413d93c2aa1303214203~tplv-k3u1fbpfcp-zoom-1.image"></p><p>今天，终于缓过来了。更新一下 Android 启动优化有向无环图系列的最后一篇文章。最近一段时间，暂时不会更新这方面的文章了。系列文章汇总如下：</p><p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://juejin.cn/post/6931903136256753672">Android 启动优化（三） - AnchorTask 使用说明 </a></p><p><a href="https://juejin.cn/post/6931905215733956616">Android 启动优化（四）- 手把手教你实现 AnchorTask</a></p><h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h2><ol><li>之前的 0.1.0 版本 配置前置依赖任务，是通过 <code>AnchorTask getDependsTaskList</code> 的方式，他是通过 <code>className</code> 找到 <code>AnchorTask</code>，并且内聚在当前的 AnchorTask 中，从全局的角度看 ，这种方式不太直观，1.0.0 放弃了这种方式，参考阿里 <code>Alpha</code> 的方式，通过 <code>addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</code></li><li>1.0.0 版本新增了 Project 类，并增加 <code>OnProjectExecuteListener</code> 监听</li><li>1.0.0 版本新增 <code>OnGetMonitorRecordCallback</code> 监听，方便统计各个任务的耗时</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p> Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p><p>多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p><p>假设我们有这样的任务依赖</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3633baa6201b48eebd19283d5613cb74~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我们要怎么使用它呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val project &#x3D;</span><br><span class="line">    AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)</span><br><span class="line">        .setAnchorTaskCreator(ApplicationAnchorTaskCreator())</span><br><span class="line">        .addTask(TASK_NAME_ZERO)</span><br><span class="line">        .addTask(TASK_NAME_ONE)</span><br><span class="line">        .addTask(TASK_NAME_TWO)</span><br><span class="line">        .addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br><span class="line">        .addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)</span><br><span class="line">        .addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)</span><br><span class="line">        .build()</span><br><span class="line">project.start().await()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationAnchorTaskCreator : IAnchorTaskCreator &#123;</span><br><span class="line">    override fun createTask(taskName: String): AnchorTask? &#123;</span><br><span class="line">        when (taskName) &#123;</span><br><span class="line">            TASK_NAME_ZERO -&gt; &#123;</span><br><span class="line">                return AnchorTaskZero()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TASK_NAME_ONE -&gt; &#123;</span><br><span class="line">                return AnchorTaskOne()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_TWO -&gt; &#123;</span><br><span class="line">                return AnchorTaskTwo()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_THREE -&gt; &#123;</span><br><span class="line">                return AnchorTaskThree()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_FOUR -&gt; &#123;</span><br><span class="line">                return AnchorTaskFour()</span><br><span class="line">            &#125;</span><br><span class="line">            TASK_NAME_FIVE -&gt; &#123;</span><br><span class="line">                return AnchorTaskFive()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo 跑起来，可以看到预期的效果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b031f5ee23ec4c87bdd495d7499e48ba~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>第一步：在 moulde build.gradle 配置远程依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.xj.android:anchortask:1.0.0&#39;</span><br></pre></td></tr></table></figure><p>最新的版本号可以看这里 <a href="https://dl.bintray.com/xujun94/maven/com/xj/android/anchortask/">lastedt version</a></p><p>第二步：自定义 <code>AnchorTaskZero</code>，继承 <code>AnchorTask</code>，并指定 <code>taskName</code>，注意 <code>taskName </code>必须是唯一的，因为我们会根据 <code>taskName</code> 找到相应的 <code>AnchorTask</code> 重写相应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskZero() : AnchorTask(TASK_NAME_ZERO) &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果任务 三 依赖任务 二，任务 一，可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br></pre></td></tr></table></figure><p>最后，通过 <code> project.start()</code>  方法启动， 如果需要阻塞等待，调用 await() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)</span><br><span class="line">                .setAnchorTaskCreator(ApplicationAnchorTaskCreator())</span><br><span class="line">                .addTask(TASK_NAME_ZERO)</span><br><span class="line">                .addTask(TASK_NAME_ONE)</span><br><span class="line">                .addTask(TASK_NAME_TWO)</span><br><span class="line">                .addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)</span><br><span class="line">                .addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)</span><br><span class="line">                .addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)</span><br><span class="line">                .build()</span><br><span class="line">project.start().await()</span><br></pre></td></tr></table></figure><h3 id="监听任务回调"><a href="#监听任务回调" class="headerlink" title="监听任务回调"></a>监听任务回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">project.addListener(object : OnProjectExecuteListener &#123;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F; project 开始执行的时候</span><br><span class="line">            override fun onProjectStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(MyApplication.TAG, &quot;onProjectStart &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; project 执行一个 task 完成的时候</span><br><span class="line">            override fun onTaskFinish(taskName: String) &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(</span><br><span class="line">                    MyApplication.TAG,</span><br><span class="line">                    &quot;onTaskFinish, taskName is $taskName&quot;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; project 执行完成的时候</span><br><span class="line">            override fun onProjectFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(MyApplication.TAG, &quot;onProjectFinish &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h3 id="添加每个任务执行耗时回调"><a href="#添加每个任务执行耗时回调" class="headerlink" title="添加每个任务执行耗时回调"></a>添加每个任务执行耗时回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project.onGetMonitorRecordCallback &#x3D; object : OnGetMonitorRecordCallback &#123;</span><br><span class="line">           </span><br><span class="line">            &#x2F;&#x2F; 所有 task 执行完毕会调用这个方法，Map 存储了 task 的执行时间， key 是 taskName，value 是时间，单位毫秒</span><br><span class="line">            override fun onGetTaskExecuteRecord(result: Map&lt;String?, Long?&gt;?) &#123;</span><br><span class="line">                onGetMonitorRecordCallback?.onGetTaskExecuteRecord(result)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 所有 task 执行完毕会调用这个方法，costTime 执行时间</span><br><span class="line">            override fun onGetProjectExecuteTime(costTime: Long) &#123;</span><br><span class="line">                onGetMonitorRecordCallback?.onGetProjectExecuteTime(costTime)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="AnchorProject-介绍"><a href="#AnchorProject-介绍" class="headerlink" title="AnchorProject 介绍"></a>AnchorProject 介绍</h2><ol><li><code>AnchorTaskDispatcher start</code> 方法必须在主线程调用，子线程调用会抛出异常。</li><li><code>await</code> 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走，await 方法携带一个参数，timeOutMillion 表示超时等待的时间</li><li><code>await()</code> 方法必须在 start 方法之后调用</li><li>添加任务是通过 <code>AnchorProject.Builder().addTask</code> 添加的，典型的构造模式</li><li>设置执行的线程池，可以通过 <code>AnchorProject.Builder().setThreadPoolExecutor(TaskExecutorManager.instance.cpuThreadPoolExecutor)</code></li></ol><h2 id="AnchorTask-介绍"><a href="#AnchorTask-介绍" class="headerlink" title="AnchorTask 介绍"></a>AnchorTask 介绍</h2><p>AnchorTask 实现了 IAnchorTask 接口，主要有几个方法</p><ul><li><code>isRunOnMainThread(): Boolean</code>表示是否在主线程运行，默认值是 false</li><li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li><li> <code>needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li><li> <code> fun run()</code> 方法，表示任务执行的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskOne : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听任务的回调"><a href="#监听任务的回调" class="headerlink" title="监听任务的回调"></a>监听任务的回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val anchorTask &#x3D; AnchorTaskTwo()</span><br><span class="line">        anchorTask.addCallback(object : IAnchorCallBack &#123;</span><br><span class="line">            override fun onAdd() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onAdd: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onStart:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onFinish:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。</p><ol><li>根据 BFS 构建出有向无环图，并得到它的拓扑排序</li><li>在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的<ol><li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li><li>执行任务</li><li> 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li></ol></li></ol><p><a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a></p><p>想看 1.0.0 版本的具体实现，可以看这篇文章。 <a href="https://github.com/gdutxiaoxu/AnchorTask/wiki/AnchorTask-1.0.0-%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E">AnchorTask 1.0.0 原理说明</a>。</p><p><strong>如果你觉得对你有所帮助，可以关注我的微信公众号 <em>程序员徐公</em></strong></p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（五） - AnchorTask 1.0.0 版本更新了
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（四） - 手把手教你实现 AnchorTask</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/01/27/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89-%20%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%20AnchorTask/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/01/27/Android 启动优化（四）- 手把手教你实现 AnchorTask/</id>
    <published>2021-01-27T15:47:15.000Z</published>
    <updated>2021-04-22T09:17:14.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p></blockquote><p>上一篇博客介绍了 AnchorTask 的基本使用，今天，让我们一起看一下怎么实现它。</p><p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://juejin.cn/post/6931903136256753672">Android 启动优化（三） - AnchorTask 使用说明 </a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>AnchorTask，锚点任务，它的实现原理是构建一个有向无环图，拓扑排序之后，如果任务 B 依赖任务 A，那么 A 一定排在任务 B 之前。</p><p><em><strong>了解原理之前，请必须先了解有向无环图和多线程的一些基本知识，不然，下文，你基本是看不懂的</strong></em>。</p><h3 id="一个共识"><a href="#一个共识" class="headerlink" title="一个共识"></a>一个共识</h3><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/20210219104449.png"></p><ul><li><strong>前置任务</strong>：任务 3 依赖于任务 0，1，那么任务 3 的前置任务是任务 0， 1</li><li><strong>子任务</strong>：任务 0 执行完之后，任务 3 才能执行，那么称呼任务 3 为 任务 0 的子任务</li></ul><h3 id="如何构建一个有向无环图"><a href="#如何构建一个有向无环图" class="headerlink" title="如何构建一个有向无环图"></a>如何构建一个有向无环图</h3><p>这里我们采用 BFS 方法实现，算法思想大概是这样的</p><ul><li>建立入度表，入度为 0 的节点先入队</li><li>当队列不为空，进行循环判断<ul><li>节点出队，添加到结果 list 当中</li><li>将该节点的邻居入度减 1</li><li>若邻居课程入度为 0，加入队列</li></ul></li><li>若结果 list 与所有节点数量相等，则证明不存在环。否则，存在环</li></ul><h3 id="多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？"><a href="#多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？" class="headerlink" title="多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？"></a>多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？</h3><p>这里要解决的主要有三个问题</p><ol><li>首先我们要解决一个问题，它有哪些前置任务，这个可以用 list 存储，代表它依赖的任务 list。当它所依赖的任务 list 没有执行完毕，当前任务需要等待。</li><li>当前任务执行完毕之后，所有依赖它的子任务需要感知到。我们可以用一个 map 来存储这种关系，key 是当前任务，value 是依赖于当前任务的集合（list）</li><li>多线程当中，等待和唤醒功能，有多种方式可以实现。wait、notify 机制，ReentrantLock Condition 机制，CountDownLatch 机制。这里我们选择 CountDownLatch 机制，因为 CountDownLatch 有点类似于计数器，特别适合这种场景。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="IAnchorTask"><a href="#IAnchorTask" class="headerlink" title="IAnchorTask"></a>IAnchorTask</h3><p>首先，我们定义一个 IAnchorTask 接口，主要有一个方法</p><ul><li><code>isRunOnMainThread(): Boolean</code> 表示是否在主线程运行，默认值是 false</li><li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li><li> <code> needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li><li> <code>fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</code> 方法返回前置任务依赖，默认值是返回 null.</li><li> <code> fun run()</code> 方法，表示任务执行的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前任务的前置任务，可以用来确定顶点的入度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它有一个实现类 AnchorTask，增加了 await 和 countdown 方法</p><ul><li>await 方法，调用它，当前任务会等待</li><li>countdown() 方法，如果当前计数器值 &gt; 0,会减一，否则，什么也不操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">abstract class AnchorTask : IAnchorTask &#123;</span><br><span class="line"></span><br><span class="line">    private val countDownLatch: CountDownLatch &#x3D; CountDownLatch(getListSize())</span><br><span class="line">    private fun getListSize() &#x3D; getDependsTaskList()?.size ?: 0</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TAG &#x3D; &quot;AnchorTask&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * self call,await</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun await() &#123;</span><br><span class="line">        countDownLatch.await()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * parent call, countDown</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun countdown() &#123;</span><br><span class="line">        countDownLatch.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序实现"><a href="#排序实现" class="headerlink" title="排序实现"></a>排序实现</h3><p>无环图的拓扑排序，这里采用的是 BFS 算法。具体的可以见 <code>AnchorTaskUtils#getSortResult</code> 方法，它有三个参数</p><ul><li>list 存储所有的任务</li><li><code> taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt; = HashMap()</code>存储所有的任务,key 是 Class<out AnchorTask>，value 是 AnchorTask</li><li>`taskChildMap: MutableMap&lt;Class<out AnchorTask>, ArrayList&lt;Class<out AnchorTask>&gt;?&gt; =<pre><code>  HashMap()`,储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list</code></pre></li></ul><p>算法思想</p><ol><li>首先找出所有入度为 0 的队列，用 queue 变量存储</li><li>当队列不为空，进行循环判断。<ul><li>从队列 pop 出，添加到结果队列</li><li>遍历当前任务的子任务，通知他们的入度减一（其实是遍历 taskChildMap），如果入度为 0，添加到队列 queue 里面</li></ul></li><li>当结果队列和 list size 不相等试，证明有环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@JvmStatic</span><br><span class="line">fun getSortResult(</span><br><span class="line">    list: MutableList&lt;AnchorTask&gt;, taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt;,</span><br><span class="line">    taskChildMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;?&gt;</span><br><span class="line">): MutableList&lt;AnchorTask&gt; &#123;</span><br><span class="line">    val result &#x3D; ArrayList&lt;AnchorTask&gt;()</span><br><span class="line">    &#x2F;&#x2F; 入度为 0 的队列</span><br><span class="line">    val queue &#x3D; ArrayDeque&lt;AnchorTask&gt;()</span><br><span class="line">    val taskIntegerHashMap &#x3D; HashMap&lt;Class&lt;out AnchorTask&gt;, Int&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 建立每个 task 的入度关系</span><br><span class="line">    list.forEach &#123; anchorTask: AnchorTask -&gt;</span><br><span class="line">        val clz &#x3D; anchorTask.javaClass</span><br><span class="line">        if (taskIntegerHashMap.containsKey(clz)) &#123;</span><br><span class="line">            throw AnchorTaskException(&quot;anchorTask is repeat, anchorTask is $anchorTask, list is $list&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val size &#x3D; anchorTask.getDependsTaskList()?.size ?: 0</span><br><span class="line">        taskIntegerHashMap[clz] &#x3D; size</span><br><span class="line">        taskMap[clz] &#x3D; anchorTask</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            queue.offer(anchorTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 建立每个 task 的 children 关系</span><br><span class="line">    list.forEach &#123; anchorTask: AnchorTask -&gt;</span><br><span class="line">        anchorTask.getDependsTaskList()?.forEach &#123; clz: Class&lt;out AnchorTask&gt; -&gt;</span><br><span class="line">            var list &#x3D; taskChildMap[clz]</span><br><span class="line">            if (list &#x3D;&#x3D; null) &#123;</span><br><span class="line">                list &#x3D; ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;()</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(anchorTask.javaClass)</span><br><span class="line">            taskChildMap[clz] &#x3D; list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 BFS 方法获得有向无环图的拓扑排序</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        val anchorTask &#x3D; queue.pop()</span><br><span class="line">        result.add(anchorTask)</span><br><span class="line">        val clz &#x3D; anchorTask.javaClass</span><br><span class="line">        taskChildMap[clz]?.forEach &#123; &#x2F;&#x2F; 遍历所有依赖这个顶点的顶点，移除该顶点之后，如果入度为 0，加入到改队列当中</span><br><span class="line">            var result &#x3D; taskIntegerHashMap[it] ?: 0</span><br><span class="line">            result--</span><br><span class="line">            if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                queue.offer(taskMap[it])</span><br><span class="line">            &#125;</span><br><span class="line">            taskIntegerHashMap[it] &#x3D; result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; size 不相等，证明有环</span><br><span class="line">    if (list.size !&#x3D; result.size) &#123;</span><br><span class="line">        throw AnchorTaskException(&quot;Ring appeared，Please check.list is $list, result is $result&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnchorTaskDispatcher"><a href="#AnchorTaskDispatcher" class="headerlink" title="AnchorTaskDispatcher"></a>AnchorTaskDispatcher</h3><p>AnchorTaskDispatcher 这个类很重要，有向无环图的拓扑排序和多线程的依赖唤醒，都是借助这个核心类完成的。</p><p>它主要有几个成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 存储所有的任务</span><br><span class="line">    private val list: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 存储所有的任务,key 是 Class&lt;out AnchorTask&gt;，value 是 AnchorTask</span><br><span class="line">    private val taskMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, AnchorTask&gt; &#x3D; HashMap()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list</span><br><span class="line">    private val taskChildMap: MutableMap&lt;Class&lt;out AnchorTask&gt;, ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;?&gt; &#x3D;</span><br><span class="line">        HashMap()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拓扑排序之后的主线程任务</span><br><span class="line">    private val mainList: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 拓扑排序之后的子线程任务</span><br><span class="line">    private val threadList: MutableList&lt;AnchorTask&gt; &#x3D; ArrayList()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要等待的任务总数，用于阻塞</span><br><span class="line">    private lateinit var countDownLatch: CountDownLatch</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要等待的任务总数，用于CountDownLatch</span><br><span class="line">    private val needWaitCount: AtomicInteger &#x3D; AtomicInteger()</span><br></pre></td></tr></table></figure><p>它有一个比较重要的方法 <code>setNotifyChildren(anchorTask: AnchorTask)</code> ，有一个方法参数 AnchorTask，它的作用是通知该任务的子任务，当前任务执行完毕，入度数减一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  通知 child countdown,当前的阻塞任务书也需要 countdown</span><br><span class="line"> *&#x2F;</span><br><span class="line">fun setNotifyChildren(anchorTask: AnchorTask) &#123;</span><br><span class="line">    taskChildMap[anchorTask::class.java]?.forEach &#123;</span><br><span class="line">        taskMap[it]?.countdown()</span><br><span class="line">    &#125;</span><br><span class="line">    if (anchorTask.needWait()) &#123;</span><br><span class="line">        countDownLatch.countDown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下 start 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">fun start(): AnchorTaskDispatcher &#123;</span><br><span class="line">        if (Looper.myLooper() !&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">            throw AnchorTaskException(&quot;start method should be call on main thread&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        startTime &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">        val sortResult &#x3D; AnchorTaskUtils.getSortResult(list, taskMap, taskChildMap)</span><br><span class="line">        LogUtils.i(TAG, &quot;start: sortResult is $sortResult&quot;)</span><br><span class="line">        sortResult.forEach &#123;</span><br><span class="line">            if (it.isRunOnMainThread()) &#123;</span><br><span class="line">                mainList.add(it)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                threadList.add(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch &#x3D; CountDownLatch(needWaitCount.get())</span><br><span class="line"></span><br><span class="line">        val threadPoolExecutor &#x3D;</span><br><span class="line">            this.threadPoolExecutor ?: TaskExecutorManager.instance.cpuThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">        threadList.forEach &#123;</span><br><span class="line">            threadPoolExecutor.execute(AnchorTaskRunnable(this, anchorTask &#x3D; it))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mainList.forEach &#123;</span><br><span class="line">            AnchorTaskRunnable(this, anchorTask &#x3D; it).run()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它主要干几件事</p><ul><li>检测是否在主线程，不是抛出异常，这里为什么要检测在主线程呢？主要是构建有向无环图的过程，我们必须保证是线程安全的</li><li>获取有向无环图的拓扑排序</li><li>根据拓扑排序的排序结果，执行相应的任务。可以看到在执行任务的时候，我们使用 <code>AnchorTaskRunnable</code> 包裹起来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskRunnable(</span><br><span class="line">    private val anchorTaskDispatcher: AnchorTaskDispatcher,</span><br><span class="line">    private val anchorTask: AnchorTask</span><br><span class="line">) : Runnable &#123;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        Process.setThreadPriority(anchorTask.priority())</span><br><span class="line">        &#x2F;&#x2F;  前置任务没有执行完毕的话，等待，执行完毕的话，往下走</span><br><span class="line">        anchorTask.await()</span><br><span class="line">        anchorTask.onStart()</span><br><span class="line">        &#x2F;&#x2F; 执行任务</span><br><span class="line">        anchorTask.run()</span><br><span class="line">        anchorTask.onFinish()</span><br><span class="line">        &#x2F;&#x2F; 通知子任务，当前任务执行完毕了，相应的计数器要减一。</span><br><span class="line">        anchorTaskDispatcher.setNotifyChildren(anchorTask)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnchorTaskRunnable 有点类似于装饰者模式，多线程依赖的执行关系在这里都得到体现，只有几行代码</p><ol><li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li><li>执行任务</li><li> 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。</p><ol><li>根据 BFS 构建出有向无环图，并得到它的拓扑排序</li><li>在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的<ol><li>前置任务没有执行完毕的话，等待，执行完毕的话，往下走</li><li>执行任务</li><li>通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。</li></ol></li></ol><p>AnchorTask 源码已经更新到 github，<a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a>。<br>我的微信公众号<strong>程序员徐公</strong>，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（四） - 手把手教你实现 AnchorTask
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（三） - AnchorTask 使用说明</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/01/25/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89-%20AnchorTask%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/01/25/Android 启动优化（三）- AnchorTask 使用说明/</id>
    <published>2021-01-25T15:47:15.000Z</published>
    <updated>2021-04-22T09:18:47.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>**微信公众号：程序员徐公(stormjun94)**，本文首发我的微信公众号，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p></blockquote><p><strong>如果觉得对你有所帮助的，可以关注我的微信公众号，程序员徐公。主要更新 Android 技术，算法，职场相关的。</strong></p><p><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/qrcode_for_gh_f0b7a2d93f70_430%20(2).jpg"></p><p>前两篇博客介绍了 Android 启动优化多线程异步加载依赖问题的解决方案 - 有向无环图，以及如何实现有它。今天，让我们一起来看一下，在 Android 实战中，怎么实现。</p><p><a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://juejin.cn/post/6930805971673415694">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p><p>多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p><p>这时候就可以使用 AnchorTask 解决，它的实现原理是构建一个有向无环图，拓扑排序之后，如果任务 B 依赖任务 A，那么 A 一定排在任务 B 之后。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>第一步：在 moulde build.gradle 配置远程依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.xj.android:anchortask:0.1.0&#39;</span><br></pre></td></tr></table></figure><p>最新的版本号可以看这里 <a href="https://dl.bintray.com/xujun94/maven/com/xj/android/anchortask/">lastedt version</a></p><p>第二步：自定义 AnchorTaskB，继承 AnchorTask，重写相应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskB : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 在这里进行操作，这里通过睡眠模拟耗时操作</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        com.xj.anchortask.library.log.LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回依赖的任务，这里是通过 class name 去找到对应的 task</span><br><span class="line">    override fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;? &#123;</span><br><span class="line">        return ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;().apply &#123;</span><br><span class="line">            add(AnchorTaskA::class.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果任务 C 依赖任务 B，任务 A，可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskC : AnchorTask() &#123;</span><br><span class="line">   </span><br><span class="line">    override fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;? &#123;</span><br><span class="line">        return ArrayList&lt;Class&lt;out AnchorTask&gt;&gt;().apply &#123;</span><br><span class="line">            add(AnchorTaskA::class.java)</span><br><span class="line">            add(AnchorTaskB::class.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，通过 <code>AnchorTaskDispatcher.instance .addTask(AnchorTaskFive())</code>  添加任务，并调用 start() 方法启动， await() 方法表示阻塞等待所有任务执行完毕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnchorTaskDispatcher.instance.setContext(this).setLogLevel(LogUtils.LogLevel.DEBUG).setTimeOutMillion(1000L).</span><br><span class="line">            .addTask(AnchorTaskZero())</span><br><span class="line">            .addTask(AnchorTaskOne())</span><br><span class="line">            .addTask(AnchorTaskTwo())</span><br><span class="line">            .addTask(AnchorTaskThree())</span><br><span class="line">            .addTask(AnchorTaskFour())</span><br><span class="line">            .addTask(AnchorTaskFive())</span><br><span class="line">            .start()</span><br><span class="line">            .await()</span><br></pre></td></tr></table></figure><h2 id="AnchorTaskDispatcher-介绍"><a href="#AnchorTaskDispatcher-介绍" class="headerlink" title="AnchorTaskDispatcher 介绍"></a>AnchorTaskDispatcher 介绍</h2><ol><li><code>AnchorTaskDispatcher start</code> 方法必须在主线程调用，子线程调用会抛出异常。</li><li><code>setTimeOutMillion</code> 方法是配合 await() 方法使用的，单独调用没有任何效果，表示 await 等待的超时时间</li><li><code>await</code> 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走</li><li><code>await()</code> 方法必须在 start 方法之后调用</li><li><code>setThreadPoolExecutor</code> 设置 task 执行的线程池</li></ol><h2 id="AnchorTask-介绍"><a href="#AnchorTask-介绍" class="headerlink" title="AnchorTask 介绍"></a>AnchorTask 介绍</h2><p>AnchorTask 实现了 IAnchorTask 接口，主要有几个方法</p><ul><li><code>isRunOnMainThread(): Boolean</code> 表示是否在主线程运行，默认值是 false</li><li> <code>priority(): Int</code> 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND</li><li> <code> needWait()</code> 表示当我们调用 <code>AnchorTaskDispatcher await</code> 时，是否需要等待，return true，表示需要等待改任务执行结束，<code>AnchorTaskDispatcher await</code> 方法才能继续往下执行。</li><li> <code>fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</code> 方法返回前置任务依赖，默认值是返回 null.</li><li> <code> fun run()</code> 方法，表示任务执行的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface IAnchorTask : IAnchorCallBack &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 是否在主线程执行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun isRunOnMainThread(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务优先级别</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @IntRange(</span><br><span class="line">        from &#x3D; Process.THREAD_PRIORITY_FOREGROUND.toLong(),</span><br><span class="line">        to &#x3D; Process.THREAD_PRIORITY_LOWEST.toLong()</span><br><span class="line">    )</span><br><span class="line">    fun priority(): Int</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调用 await 方法，是否需要等待改任务执行完成</span><br><span class="line">     * true 不需要</span><br><span class="line">     * false 需要</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun needWait(): Boolean</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前任务的前置任务，可以用来确定顶点的入度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun getDependsTaskList(): List&lt;Class&lt;out AnchorTask&gt;&gt;?</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 任务被执行的时候回调</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class AnchorTaskOne : AnchorTask() &#123;</span><br><span class="line">    override fun isRunOnMainThread(): Boolean &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val start &#x3D; System.currentTimeMillis()</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300)</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.i(</span><br><span class="line">            TAG, &quot;AnchorTaskOne: &quot; + (System.currentTimeMillis() - start)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听任务的回调"><a href="#监听任务的回调" class="headerlink" title="监听任务的回调"></a>监听任务的回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">val anchorTask &#x3D; AnchorTaskTwo()</span><br><span class="line">        anchorTask.addCallback(object : IAnchorCallBack &#123;</span><br><span class="line">            override fun onAdd() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onAdd: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onRemove() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onRemove: $anchorTask&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStart() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onStart:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFinish() &#123;</span><br><span class="line">                com.xj.anchortask.LogUtils.i(TAG, &quot;onFinish:$anchorTask &quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇博客介绍了 AnchorTask 的使用，<br>AnchorTask 源码已经更新到 github，<a href="https://github.com/gdutxiaoxu/AnchorTask">AnchorTask</a>，下一篇，将输出 <strong>Android 启动优化（四）- 手把手教你实现 AnchorTask</strong>，敬请期待。</p><p>我的微信公众号<strong>程序员徐公</strong>，有兴趣的可以<a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9363c4e7614b16aa5ae9cf62cfe5de~tplv-k3u1fbpfcp-zoom-1.image">点击扫码关注</a></p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（三） - AnchorTask 使用说明
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（二） - 拓扑排序的原理以及解题思路</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/01/25/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%20-%20%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%20/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/01/25/Android 启动优化（二） -  拓扑排序的原理以及解题思路 /</id>
    <published>2021-01-25T15:47:15.000Z</published>
    <updated>2021-04-22T09:19:39.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>在上一篇文章中 <a href="https://juejin.cn/post/6926794003794903048">Android 启动优化（一） - 有向无环图</a>，我们介绍了有向无环图，以及拓扑排序的两种解法。今天，让我们一起来实战一下。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>拓扑排序的英文名是 Topological sorting。</p><p><strong>拓扑排序要解决的问题是给一个图的所有节点排序。有向无环图才有拓扑排序，非有向无环图没有。</strong></p><p>换句话说，拓扑排序必须满足以下条件</p><p>图必须是一个无环有向图。序列必须满足的条件：</p><ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>我们已 leetcode 上面的一道算法题目作为切入点进行讲解。</p><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">leeocode 210</a>: <a href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p><p><strong>eg</strong>: 现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p>示例 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p>示例 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p>这道题，很明显，看起来可以有有向无环图的解法来解决</p><h2 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>我们首先引入有向图 描述依赖关系</p><p>示例：假设 n = 6，先决条件表：[ [3, 0], [3, 1], [4, 1], [4, 2], [5, 3], [5, 4] ]</p><ul><li>0, 1, 2 没有先修课，可以直接选。其余的，都要先修 2 门课</li><li>我们用 有向图 描述这种 依赖关系 (做事的先后关系)：<br><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/20210219104449.png"></li></ul><p>在有向图中，我们知道，有<strong>入度</strong>和<strong>出度</strong>概念：</p><p>如果存在一条有向边 A –&gt; B，则这条边给 A 增加了 1 个出度，给 B 增加了 1 个入度。所以顶点 0、1、2 的 入度为 0。 顶点 3、4、5 的 入度为 2</p><h3 id="BFS-前准备工作"><a href="#BFS-前准备工作" class="headerlink" title="BFS 前准备工作"></a>BFS 前准备工作</h3><ul><li>我们关心 课程的入度 —— 该值要被减，要被监控</li><li>我们关心 课程之间的依赖关系 —— 选这门课会减小哪些课的入度</li><li>因此我们需要合适的数据结构，去存储这些关系,这个可以通过哈希表</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>维护一个 queue，里面都是入度为 0 的课程</li><li>选择一门课，就让它出列，同时 <strong>查看哈希表</strong>，看它 对应哪些后续课</li><li>将这些后续课的 入度 - 1，如果有减至 0 的，就将它推入 queue</li><li>不再有新的入度 0 的课入列 时，此时 queue 为空，退出循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private  class Solution &#123;</span><br><span class="line">    public int[] findOrder(int num, int[][] prerequisites) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计算所有节点的入度，这里用数组代表哈希表，key 是 index， value 是 inDegree[index].实际开发当中，用 HashMap 比较灵活</span><br><span class="line">        int[] inDegree &#x3D; new int[num];</span><br><span class="line">        for (int[] array : prerequisites) &#123;</span><br><span class="line">            inDegree[array[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 找出所有入度为 0 的点，加入到队列当中</span><br><span class="line">        Queue&lt;Integer&gt; queue &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; inDegree.length; i++) &#123;</span><br><span class="line">            if (inDegree[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Integer key &#x3D; queue.poll();</span><br><span class="line">            result.add(key);</span><br><span class="line">            &#x2F;&#x2F; 遍历所有课程</span><br><span class="line">            for (int[] p : prerequisites) &#123;</span><br><span class="line">                &#x2F;&#x2F; 改课程依赖于当前课程 key</span><br><span class="line">                if (key &#x3D;&#x3D; p[1]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 入度减一</span><br><span class="line">                    inDegree[p[0]]--;</span><br><span class="line">                    if (inDegree[p[0]] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        queue.offer(p[0]); &#x2F;&#x2F; 加入到队列当中</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 数量不相等，说明存在环</span><br><span class="line">        if (result.size() !&#x3D; num) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] array &#x3D; new int[num];</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for (int i : result) &#123;</span><br><span class="line">            array[index++] &#x3D; i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS-解法"><a href="#DFS-解法" class="headerlink" title="DFS 解法"></a>DFS 解法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>对图执行深度优先搜索。</li><li>在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。</li><li>最后得到栈中顺序的逆序即为拓扑排序顺序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法 2：邻接矩阵 + DFS   由于用的数组，每次都要遍历，效率比较低</span><br><span class="line">    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if (numCourses &#x3D;&#x3D; 0) return new int[0];</span><br><span class="line">        &#x2F;&#x2F; 建立邻接矩阵</span><br><span class="line">        int[][] graph &#x3D; new int[numCourses][numCourses];</span><br><span class="line">        for (int[] p : prerequisites) &#123;</span><br><span class="line">            graph[p[1]][p[0]] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录访问状态的数组，访问过了标记 -1，正在访问标记 1，还未访问标记 0</span><br><span class="line">        int[] status &#x3D; new int[numCourses];</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();  &#x2F;&#x2F; 用栈保存访问序列</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (!dfs(graph, status, i, stack)) return new int[0]; &#x2F;&#x2F; 只要存在环就返回</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res &#x3D; new int[numCourses];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            res[i] &#x3D; stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean dfs(int[][] graph, int[] status, int i, Stack&lt;Integer&gt; stack) &#123;</span><br><span class="line">        if (status[i] &#x3D;&#x3D; 1) return false; &#x2F;&#x2F; 当前节点在此次 dfs 中正在访问，说明存在环</span><br><span class="line">        if (status[i] &#x3D;&#x3D; -1) return true;</span><br><span class="line"></span><br><span class="line">        status[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; graph.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; dfs 访问当前课程的后续课程，看是否存在环</span><br><span class="line">            if (graph[i][j] &#x3D;&#x3D; 1 &amp;&amp; !dfs(graph, status, j, stack)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        status[i] &#x3D; -1;  &#x2F;&#x2F; 标记为已访问</span><br><span class="line">        stack.push(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客从实战的角度出发，介绍了有向无环图的两种解法，入度表法和 DFS 法。其中，入度表法很重要，必须掌握。下一篇，我们将从 项目实战的角度来讲解，怎样搭建一个有向无环图的通用框架，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      Android 启动优化（二） - 拓扑排序的原理以及解题思路
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 启动优化（一） - 有向无环图</title>
    <link href="https://gdutxiaoxu.gitee.io/2021/01/18/Android%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%20-%20%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE/"/>
    <id>https://gdutxiaoxu.gitee.io/2021/01/18/Android 启动优化（一） - 有向无环图/</id>
    <published>2021-01-18T15:47:15.000Z</published>
    <updated>2021-04-22T09:21:47.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到 Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。</p><p>多线程异步加载方案确实是 ok 的。但如果遇到<strong>前后依赖</strong>的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。</p><p><em>最简单的方案是将任务1 丢到主线程加载，然后再启动多线程异步加载。</em></p><p>如果遇到更复杂的依赖呢。</p><p>任务3 依赖于任务 2， 任务 2 依赖于任务 1 呢，这时候你要怎么解决。更复杂的依赖关系呢</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p><p>总不能将任务 2，任务 3 都放到主线程加载吧，这样多线程加载的意义就不大了。</p><p>有没有更好的方案呢？</p><p><strong>答案肯定是有的，使用有向无环图。它可以完美解决先后依赖关系。</strong></p><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p><strong>有向无环图（Directed Acyclic Graph, DAG</strong>）是有向图的一种，字面意思的理解就是图中没有环。常常被用来表示事件之间的驱动依赖关系，管理任务之间的调度。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p><p><strong>顶点</strong>：图中的一个点，比如顶点 1，顶点 2。</p><p><strong>边</strong>：连接两个顶点的线段叫做边，edge。</p><p><strong>入度</strong>：代表当前有多少边指向它。</p><p>在上图中，顶掉 1 的入度是 0，因为没有任何边指向它。 顶掉 2 的入度是 1， 因为 顶掉 1 指向 顶掉 2. 同理可得出 5 的入度是 2，因为顶掉 4 和顶点 3 指向它</p><p><strong>拓扑排序</strong>：拓扑排序是对一个有向图构造拓扑序列的过程。它具有如下特点。</p><ul><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li></ul><p>由于有这个特点，因此常常用有向无环图的数据结构用来解决依赖关系。</p><p>上图中，拓扑排序之后，任务2肯定排在任务1之后，因为任务2依赖 任务1， 任务3肯定在任务2之后，因为任务3依赖任务2。</p><p>拓扑排序一般有两种算法，第一种是入度表法，第二种是 DFS 方法。下面，让我们一起来看一下怎么实现它。</p><h2 id="入度表法"><a href="#入度表法" class="headerlink" title="入度表法"></a>入度表法</h2><p>入度表法是根据顶点的入度来判断是否有依赖关系的。若顶点的入度不为 0，则表示它有前置依赖。它也常常被称作 BFS 算法</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>建立入度表，入度为 0 的节点先入队</li><li>当队列不为空，进行循环判断<ul><li>节点出队，添加到结果 list 当中</li><li>将该节点的邻居入度减 1</li><li>若邻居节点入度为 0，加入队列</li></ul></li><li>若结果 list 与所有节点数量相等，则证明不存在环。否则，存在环</li></ul><h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>下图所示的有向无环图，采用入度表的方法获取拓扑排序过程。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p><p>首先，我们选择入度为 0 的顶点，这里顶点 1 的入度为 0，删除顶点 1 之后，图变成如下。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214904.png"></p><p>这时候，顶点 2 和顶点 4 的入度都为 0，我们可以随便删除一个顶点。（<strong>这也就是为什么图的拓扑排序不是唯一的原因</strong>）。这里我们删除顶点 2，图变成如下：</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214917.png"></p><p>这时候，我们再删除顶点 4，图变成如下：</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114214928.png"></p><p>选择入度为 0 的顶点 3，删除顶点 3 之后，图标称如下，</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114215037.png"></p><p>最后剩余顶点5，输出顶点5，拓扑排序过程结束。最终的输出结果为：</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114215654.png"></p><p>到此，优先无环图的入度法的流程已经讲解完毕。你清楚了嘛。</p><p>代码的话，下期会一起给出。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>设 AOE 网有 n 个事件，e 个活动，则算法的主要执行是：</p><ul><li>求每个事件的ve值和vl值：时间复杂度是O(n+e) ；</li><li>根据ve值和vl值找关键活动：时间复杂度是O(n+e) ；</li></ul><p>因此，整个算法的时间复杂度是O(n+e)</p><h2 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h2><p>从上面的入度表法，我们可以知道，要得到有向无环图的拓扑排序，我们的关键点要找到入度为 0 的顶点。然后接着删除该结点的相邻所有边。再遍历所有结点。直到入度为 0 的队列为空。这种方法其实是 BFS。</p><p>说到 BFS，我们第一时间就想到 DFS。<strong>与 BFS 不同的是，DFS 的关键点在于找到，出度为0的顶点。</strong></p><p>总结如下，深度优先搜索过程中，当到达出度为0的顶点时，需要进行回退。在执行回退时记录出度为0的顶点，将其入栈。则最终出栈顺序的逆序即为拓扑排序序列。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>对图执行深度优先搜索。</li><li>在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。</li><li>最后得到栈中顺序的逆序即为拓扑排序顺序。</li></ul><h3 id="实例讲解-1"><a href="#实例讲解-1" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>同样，以下图讲解 DFS 算法的过程。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/offer/20210114210524.png"></p><p>(1) 从顶点 1 开始出发，开始执行深度优先搜索。顺序为1-&gt;2-&gt;3-&gt;5。</p><p>（2）深度优先搜索到达顶点5时，顶点5出度为0。将顶点5入栈。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224006.png"></p><p>（3）深度优先搜索执行回退，回退至顶点3。此时顶点3的出度为0，将顶点3入栈。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224021.png"></p><p>（4）回退至顶点2，顶点2出度为0，顶点2入栈。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224230.png"></p><p>（5）回退至顶点1，顶点1可以前进位置为顶点4，顺序为1-&gt;4。</p><p>（6）顶点4出度为0，顶点4入栈。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224240.png"></p><p>（7）回退至顶点1，顶点1出度为0，顶点1入栈。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224247.png"></p><p>（8）栈的逆序为1-&gt;4-&gt;2-&gt;3-&gt;5。此顺序为拓扑排序结果。</p><p><img src="https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/21/0120210116224253.png"></p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度分析：首先深度优先搜索的时间复杂度为O(V+E)，而每次只需将完成访问的顶点存入数组中，需要O(1)，因而总复杂度为O(V+E)。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有向无环图的拓扑排序其实并不难，难度中等。通常，我们一般使用 BFS 算法来解决，DFS 算法比较少用。</p><p>对于 BFS（入度表法），它的核心思想是</p><ol><li>选择一个没有输入边（入度为0）的源顶点（若有多个则任选一个），</li><li>将它和它的输出边删除。重复源顶点的删除操作，直到不存在入度为0的源顶点为止。</li><li>最终，检测图中的顶点个数，若还有顶点存在则算法无解，否则顶点的删除顺序就是拓扑排序的输出顺序。</li></ol>]]></content>
    
    <summary type="html">
    
      Android 启动优化（一） - 有向无环图
    
    </summary>
    
    
      <category term="Android 启动优化" scheme="https://gdutxiaoxu.gitee.io/tags/Android-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>面试官， 怎样实现 Router 框架？</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/07/18/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%20Router%20%E6%A1%86%E6%9E%B6%EF%BC%9F/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/07/18/面试官，怎样实现 Router 框架？/</id>
    <published>2019-07-18T08:26:32.000Z</published>
    <updated>2021-04-18T01:59:17.585Z</updated>
    
    <content type="html"><![CDATA[<p>Android 开发中，组件化，模块化是一个老生常谈的问题。随着项目复杂性的增长，模块化是一个必然的趋势。除非你能忍受改一下代码，就需要六七分钟的漫长时间。</p><p>模块化，组件化随之带来的另外一个问题是页面的跳转问题，由于代码的隔离，代码之间有时候会无法互相访问。于是，路由（Router）框架诞生了。</p><p>目前用得比较多的有阿里的 ARouter，美团的 WMRouter，ActivityRouter 等。</p><p>今天，就让我们一起来看一下怎样实现一个路由框架。<br>实现的功能有。</p><ol><li>基于编译时注解，使用方便</li><li>结果回调，每次跳转 Activity 都会回调跳转结果</li><li>除了可以使用注解自定义路由，还支持手动分配路由</li><li>支持多模块使用，支持组件化使用</li></ol><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>第一步，在要跳转的 activity 上面注明 path，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Route(path &#x3D; &quot;activity&#x2F;main&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在要跳转的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;main&quot;).navigation(this);</span><br></pre></td></tr></table></figure><h3 id="如果想在多-moule-中使用"><a href="#如果想在多-moule-中使用" class="headerlink" title="如果想在多 moule 中使用"></a>如果想在多 moule 中使用</h3><p>第一步，使用 <code>@Modules(&#123;&quot;app&quot;, &quot;sdk&quot;&#125;)</code> 注明总共有多少个 moudle，并分别在 moudle 中注明当前 moudle 的 名字，使用 <code>@Module(&quot;&quot;)</code> 注解。注意 @Modules({“app”, “sdk”}) 要与 @Module(“”) 一一对应。</p><p>在主 moudle 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Modules(&#123;&quot;app&quot;, &quot;moudle1&quot;&#125;)</span><br><span class="line">@Module(&quot;app&quot;)</span><br><span class="line">public class RouterApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        Router.getInstance().init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 moudle1 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Route(path &#x3D; &quot;my&#x2F;activity&#x2F;main&quot;)</span><br><span class="line">@Module(&quot;moudle1&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以支持多模块使用了。</p><h3 id="自定义注入-router"><a href="#自定义注入-router" class="headerlink" title="自定义注入 router"></a>自定义注入 router</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().add(&quot;activity&#x2F;three&quot;, ThreeActivity.class);</span><br></pre></td></tr></table></figure><p>跳转的时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;three&quot;).navigation(this);</span><br></pre></td></tr></table></figure><h3 id="结果回调"><a href="#结果回调" class="headerlink" title="结果回调"></a>结果回调</h3><p>路由跳转结果回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().build(&quot;my&#x2F;activity&#x2F;main&quot;, new RouterCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean beforeOpen(Context context, Uri uri) &#123; </span><br><span class="line">    &#x2F;&#x2F; 在打开路由之前</span><br><span class="line">        Log.i(TAG, &quot;beforeOpen: uri&#x3D;&quot; + uri);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 在打开路由之后（即打开路由成功之后会回调）</span><br><span class="line">    @Override</span><br><span class="line">    public void afterOpen(Context context, Uri uri) &#123;</span><br><span class="line">        Log.i(TAG, &quot;afterOpen: uri&#x3D;&quot; + uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有找到改 uri</span><br><span class="line">    @Override</span><br><span class="line">    public void notFind(Context context, Uri uri) &#123;</span><br><span class="line">        Log.i(TAG, &quot;notFind: uri&#x3D;&quot; + uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发生错误</span><br><span class="line">    @Override</span><br><span class="line">    public void error(Context context, Uri uri, Throwable e) &#123;</span><br><span class="line">        Log.i(TAG, &quot;error: uri&#x3D;&quot; + uri + &quot;;e&#x3D;&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).navigation(this);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>startActivityForResult 跳转结果回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;two&quot;).navigation(this, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onActivityResult: requestCode&#x3D;&quot; + requestCode + &quot;;resultCode&#x3D;&quot; + resultCode + &quot;;data&#x3D;&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>实现一个 Router 框架，涉及到的主要的知识点如下：</p><ol><li>注解的处理</li><li>怎样解决多个 module 之间的依赖问题，以及如何支持多 module 使用</li><li>router 跳转及 activty startActivityForResult 的处理</li></ol><p>我们带着这三个问题，一起来探索一下。</p><p>总共分为四个部分,router-annotion, router-compiler,router-api,stub</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTIzMTYwMjA3LnBuZw?x-oss-process=image/format,png"></p><p>router-annotion 主要是定义注解的，用来存放注解文件</p><p>router-compiler 主要是用来处理注解的，自动帮我们生成代码</p><p>router-api 是对外的 api，用来处理跳转的。</p><p>stub 这个是存放一些空的 java 文件，提前占坑。不会打包进 jar。</p><h2 id="router-annotion"><a href="#router-annotion" class="headerlink" title="router-annotion"></a>router-annotion</h2><p>主要定义了三个注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Route &#123;</span><br><span class="line">    String path();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Modules &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Module &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Route 注解主要是用来注明跳转的 path 的。</p><p>Modules 注解，注明总共有多少个 moudle。</p><p>Module 注解，注明当前 moudle 的名字。</p><p>Modules，Module 注解主要是为了解决支持多 module 使用的。</p><hr><h2 id="router-compiler"><a href="#router-compiler" class="headerlink" title="router-compiler"></a>router-compiler</h2><p>router-compiler 只有一个类 RouterProcessor，他的原理其实也是比较简单的，扫描那些类用到注解，并将这些信息存起来，做相应的处理。这里是会生成相应的 java 文件。</p><p>主要包括以下两个步骤</p><ol><li>根据是否有 <code>@Modules</code> <code>@Module</code> 注解，然后生成相应的 <code>RouterInit</code> 文件</li><li>扫描 <code>@Route</code> 注解，并根据 <code>moudleName</code> 生成相应的 java 文件</li></ol><h3 id="注解基本介绍"><a href="#注解基本介绍" class="headerlink" title="注解基本介绍"></a>注解基本介绍</h3><p>在讲解 RouterProcessor 之前，我们先来了解一下注解的基本知识。</p><p>如果对于自定义注解还不熟悉的话，可以先看我之前写的这两篇文章。<a href="https://xujun.blog.csdn.net/article/details/70244169">Android 自定义编译时注解1 - 简单的例子</a>，<a href="https://blog.csdn.net/gdutxiaoxu/article/details/70822023">Android 编译时注解 —— 语法详解</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class RouterProcessor extends AbstractProcessor &#123;</span><br><span class="line">    private static final boolean DEBUG &#x3D; true;</span><br><span class="line">    private Messager messager;</span><br><span class="line">    private Filer mFiler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">        messager &#x3D; processingEnv.getMessager();</span><br><span class="line">        mFiler &#x3D; processingEnv.getFiler();</span><br><span class="line">        UtilManager.getMgr().init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义你的注解处理器注册到哪些注解上</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; annotations &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(Route.class.getCanonicalName());</span><br><span class="line">        annotations.add(Module.class.getCanonicalName());</span><br><span class="line">        annotations.add(Modules.class.getCanonicalName());</span><br><span class="line">        return annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * java版本</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 首先我们先来看一下 <code>getSupportedAnnotationTypes</code> 方法,这个方法返回的是我们支持扫描的注解。</p><h3 id="注解的处理"><a href="#注解的处理" class="headerlink" title="注解的处理"></a>注解的处理</h3><p> 接下来我们再一起来看一下 <code>process</code> 方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">    &#x2F;&#x2F; 注解为 null，直接返回</span><br><span class="line">    if (annotations &#x3D;&#x3D; null || annotations.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UtilManager.getMgr().getMessager().printMessage(Diagnostic.Kind.NOTE, &quot;process&quot;);</span><br><span class="line">    boolean hasModule &#x3D; false;</span><br><span class="line">    boolean hasModules &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; module</span><br><span class="line">    String moduleName &#x3D; &quot;RouterMapping&quot;;</span><br><span class="line">    Set&lt;? extends Element&gt; moduleList &#x3D; roundEnv.getElementsAnnotatedWith(Module.class);</span><br><span class="line">    if (moduleList !&#x3D; null &amp;&amp; moduleList.size() &gt; 0) &#123;</span><br><span class="line">        Module annotation &#x3D; moduleList.iterator().next().getAnnotation(Module.class);</span><br><span class="line">        moduleName &#x3D; moduleName + &quot;_&quot; + annotation.value();</span><br><span class="line">        hasModule &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; modules</span><br><span class="line">    String[] moduleNames &#x3D; null;</span><br><span class="line">    Set&lt;? extends Element&gt; modulesList &#x3D; roundEnv.getElementsAnnotatedWith(Modules.class);</span><br><span class="line">    if (modulesList !&#x3D; null &amp;&amp; modulesList.size() &gt; 0) &#123;</span><br><span class="line">        Element modules &#x3D; modulesList.iterator().next();</span><br><span class="line">        moduleNames &#x3D; modules.getAnnotation(Modules.class).value();</span><br><span class="line">        hasModules &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug(&quot;generate modules RouterInit annotations&#x3D;&quot; + annotations + &quot; roundEnv&#x3D;&quot; + roundEnv);</span><br><span class="line">    debug(&quot;generate modules RouterInit hasModules&#x3D;&quot; + hasModules + &quot; hasModule&#x3D;&quot; + hasModule);</span><br><span class="line">    &#x2F;&#x2F; RouterInit</span><br><span class="line">    if (hasModules) &#123; &#x2F;&#x2F; 有使用 @Modules 注解，生成 RouterInit 文件，适用于多个 moudle</span><br><span class="line">        debug(&quot;generate modules RouterInit&quot;);</span><br><span class="line">        generateModulesRouterInit(moduleNames);</span><br><span class="line">    &#125; else if (!hasModule) &#123; &#x2F;&#x2F; 没有使用 @Modules 注解，并且有使用 @Module，生成相应的 RouterInit 文件，使用与单个 moudle</span><br><span class="line">        debug(&quot;generate default RouterInit&quot;);</span><br><span class="line">        generateDefaultRouterInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 扫描 Route 注解</span><br><span class="line">    Set&lt;? extends Element&gt; elements &#x3D; roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">    List&lt;TargetInfo&gt; targetInfos &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Element element : elements) &#123;</span><br><span class="line">        System.out.println(&quot;elements &#x3D;&quot; + elements);</span><br><span class="line">        &#x2F;&#x2F; 检查类型</span><br><span class="line">        if (!Utils.checkTypeValid(element)) continue;</span><br><span class="line">        TypeElement typeElement &#x3D; (TypeElement) element;</span><br><span class="line">        Route route &#x3D; typeElement.getAnnotation(Route.class);</span><br><span class="line">        targetInfos.add(new TargetInfo(typeElement, route.path()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据 module 名字生成相应的 java 文件</span><br><span class="line">    if (!targetInfos.isEmpty()) &#123;</span><br><span class="line">        generateCode(targetInfos, moduleName);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>，首先判断是否有注解需要处理，没有的话直接返回 <code>annotations == null || annotations.size() == 0</code> 。</p><p> 接着我们会判断是否有 <code>@Modules</code> 注解（这种情况是多个 moudle 使用），有的话会调用 <code>generateModulesRouterInit(String[] moduleNames)</code> 方法生成 RouterInit java 文件，当没有 <code>@Modules</code> 注解，并且没有 <code>@Module</code> （这种情况是单个 moudle 使用），会生成默认的 RouterInit 文件。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> private void generateModulesRouterInit(String[] moduleNames) &#123;</span><br><span class="line">    MethodSpec.Builder initMethod &#x3D; MethodSpec.methodBuilder(&quot;init&quot;)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC);</span><br><span class="line">    for (String module : moduleNames) &#123;</span><br><span class="line">        initMethod.addStatement(&quot;RouterMapping_&quot; + module + &quot;.map()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeSpec routerInit &#x3D; TypeSpec.classBuilder(&quot;RouterInit&quot;)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(initMethod.build())</span><br><span class="line">            .build();</span><br><span class="line">    try &#123;</span><br><span class="line">        JavaFile.builder(Constants.ROUTE_CLASS_PACKAGE, routerInit)</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(mFiler);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设说我们有”app”,”moudle1” 两个 moudle，那么我们最终生成的代码是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final class RouterInit &#123;</span><br><span class="line">  public static final void init() &#123;</span><br><span class="line">    RouterMapping_app.map();</span><br><span class="line">    RouterMapping_moudle1.map();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们都没有使用 @Moudles 和 @Module 注解，那么生成的 RouterInit 文件大概是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class RouterInit &#123;</span><br><span class="line">  public static final void init() &#123;</span><br><span class="line">    RouterMapping.map();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是为什么有 stub module 的原因。因为默认情况下，我们需要借助 RouterInit 去初始化 map。如果没有这两个文件，ide 编辑器 在 compile 的时候就会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly project(path: &#39;:stub&#39;)</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTIzMTczODQzLnBuZw?x-oss-process=image/format,png"></p><p>我们引入的方式是使用 compileOnly，这样的话再生成 jar 的时候，不会包括这两个文件，但是可以在 ide 编辑器中运行。这也是一个小技巧。</p><h3 id="Route-注解的处理"><a href="#Route-注解的处理" class="headerlink" title="Route 注解的处理"></a>Route 注解的处理</h3><p>我们回过来看 process 方法连对 Route 注解的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 扫描 Route 自己注解</span><br><span class="line">Set&lt;? extends Element&gt; elements &#x3D; roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">List&lt;TargetInfo&gt; targetInfos &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for (Element element : elements) &#123;</span><br><span class="line">    System.out.println(&quot;elements &#x3D;&quot; + elements);</span><br><span class="line">    &#x2F;&#x2F; 检查类型</span><br><span class="line">    if (!Utils.checkTypeValid(element)) continue;</span><br><span class="line">    TypeElement typeElement &#x3D; (TypeElement) element;</span><br><span class="line">    Route route &#x3D; typeElement.getAnnotation(Route.class);</span><br><span class="line">    targetInfos.add(new TargetInfo(typeElement, route.path()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据 module 名字生成相应的 java 文件</span><br><span class="line">if (!targetInfos.isEmpty()) &#123;</span><br><span class="line">    generateCode(targetInfos, moduleName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会扫描所有的 Route 注解，并添加到 targetInfos list 当中，接着调用 <code>generateCode</code> 方法生成相应的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void generateCode(List&lt;TargetInfo&gt; targetInfos, String moduleName) &#123;</span><br><span class="line">      </span><br><span class="line">        MethodSpec.Builder methodSpecBuilder &#x3D; MethodSpec.methodBuilder(&quot;map&quot;)</span><br><span class="line">&#x2F;&#x2F;                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(Modifier.STATIC)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                .addParameter(parameterSpec);</span><br><span class="line">        for (TargetInfo info : targetInfos) &#123;</span><br><span class="line">            methodSpecBuilder.addStatement(&quot;com.xj.router.api.Router.getInstance().add($S, $T.class)&quot;, info.getRoute(), info.getTypeElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TypeSpec typeSpec &#x3D; TypeSpec.classBuilder(moduleName)</span><br><span class="line">&#x2F;&#x2F;                .addSuperinterface(ClassName.get(interfaceType))</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addMethod(methodSpecBuilder.build())</span><br><span class="line">                .addJavadoc(&quot;Generated by Router. Do not edit it!\n&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            JavaFile.builder(Constants.ROUTE_CLASS_PACKAGE, typeSpec)</span><br><span class="line">                    .build()</span><br><span class="line">                    .writeTo(UtilManager.getMgr().getFiler());</span><br><span class="line">            System.out.println(&quot;generateCode: &#x3D;&quot; + Constants.ROUTE_CLASS_PACKAGE + &quot;.&quot; + Constants.ROUTE_CLASS_NAME);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;generateCode:e  &#x3D;&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是使用 javapoet 生成 java 文件，关于 javaposet 的使用可以见<a href="https://github.com/square/javapoet">官网文档</a>,生成的 java 文件是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.xj.router.impl;</span><br><span class="line"></span><br><span class="line">import com.xj.arounterdemo.MainActivity;</span><br><span class="line">import com.xj.arounterdemo.OneActivity;</span><br><span class="line">import com.xj.arounterdemo.TwoActivity;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Generated by Router. Do not edit it!</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RouterMapping_app &#123;</span><br><span class="line">  public static void map() &#123;</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;main&quot;, MainActivity.class);</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;one&quot;, OneActivity.class);</span><br><span class="line">    com.xj.router.api.Router.getInstance().add(&quot;activity&#x2F;two&quot;, TwoActivity.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们定义的注解信息，最终都会调用 <code>Router.getInstance().add()</code> 方法存放起来。</p><hr><h2 id="router-api"><a href="#router-api" class="headerlink" title="router-api"></a>router-api</h2><p>这个 module 主要是多外暴露的 api，最主要的一个文件是 Router。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Router &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;ARouter&quot;;</span><br><span class="line"></span><br><span class="line">    private static final Router instance &#x3D; new Router();</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Class&lt;? extends Activity&gt;&gt; routeMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private boolean loaded;</span><br><span class="line"></span><br><span class="line">    private Router() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Router getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if (loaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        RouterInit.init();</span><br><span class="line">        loaded &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要初始化  Router 的时候，代用 init 方法即可。 init 方法会先判断是否初始化过，没有初始化过，会调用 RouterInit#init 方法区初始化。</p><p>而在 RouterInit#init 中，会调用 RouterMap_{@moduleName}#map 方法初始化，改方法又调用 <code>Router.getInstance().add()</code> 方法，从而完成初始化</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTU0NDAwLnBuZw?x-oss-process=image/format,png"></p><h3 id="router-跳转回调"><a href="#router-跳转回调" class="headerlink" title="router 跳转回调"></a>router 跳转回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface RouterCallback &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在跳转 router 之前</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean beforeOpen(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在跳转 router 之后</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void afterOpen(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 没有找到改 router</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void notFind(Context context, Uri uri);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 跳转 router 错误</span><br><span class="line">     * @param context</span><br><span class="line">     * @param uri</span><br><span class="line">     * @param e</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void error(Context context, Uri uri, Throwable e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void navigation(Activity context, int requestCode, Callback callback) &#123;</span><br><span class="line">    beforeOpen(context);</span><br><span class="line">    boolean isFind &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        Activity activity &#x3D; (Activity) context;</span><br><span class="line">        Intent intent &#x3D; new Intent();</span><br><span class="line">        intent.setComponent(new ComponentName(context.getPackageName(), mActivityName));</span><br><span class="line">        intent.putExtras(mBundle);</span><br><span class="line">        getFragment(activity)</span><br><span class="line">                .setCallback(callback)</span><br><span class="line">                .startActivityForResult(intent, requestCode);</span><br><span class="line">        isFind &#x3D; true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        errorOpen(context, e);</span><br><span class="line">        tryToCallNotFind(e, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isFind) &#123;</span><br><span class="line">        afterOpen(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void tryToCallNotFind(Exception e, Context context) &#123;</span><br><span class="line">    if (e instanceof ClassNotFoundException &amp;&amp; mRouterCallback !&#x3D; null) &#123;</span><br><span class="line">        mRouterCallback.notFind(context, mUri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要看 navigation 方法，在跳转 activity 的时候，首先会会调用<br>beforeOpen 方法回调 RouterCallback#beforeOpen。接着 catch exception 的时候，如果发生错误，会调用 errorOpen 方法回调 RouterCallback#errorOpen 方法。同时调用 tryToCallNotFind 方法判断是否是 ClassNotFoundException，是的话回调 RouterCallback#notFind。</p><p>如果没有发生 eception，会回调 RouterCallback#afterOpen。</p><h3 id="Activity-的-startActivityForResult-回调"><a href="#Activity-的-startActivityForResult-回调" class="headerlink" title="Activity 的 startActivityForResult 回调"></a>Activity 的 startActivityForResult 回调</h3><p>可以看到我们的 Router 也是支持 startActivityForResult 的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router.getInstance().build(&quot;activity&#x2F;two&quot;).navigation(this, new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onActivityResult: requestCode&#x3D;&quot; + requestCode + &quot;;resultCode&#x3D;&quot; + resultCode + &quot;;data&#x3D;&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它的实现原理其实很简单，是借助一个空白 fragment 实现的，原理的可以看我之前的这一篇文章。</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果觉得效果不错的话，请到 github 上面 star， 谢谢。 <a href="https://github.com/gdutxiaoxu/Router">Router</a></p><p>我们的 Router 框架，流程大概是这样的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTQ1NjA3LnBuZw?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dkdXR4aWFveHUvYmxvZ19waWMvbWFzdGVyLzE5XzA5LzIwMTkxMTI2MTU0NDAwLnBuZw?x-oss-process=image/format,png"></p><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>看了上面的文章，文章一开头提到的三个问题，你懂了吗，欢迎在评论区留言评论。</p><ol><li>注解的处理</li><li>怎样解决多个 module 之间的依赖问题，以及如何支持多 module 使用</li><li>router 跳转及 activty startActivityForResult 的处理</li></ol><p>其实，现在很多 router 框架都借助 gradle 插件来实现。这样有一个好处，就是在多 moudle 使用的时候，我们只需要 <code>apply plugin</code> 就 ok,对外屏蔽了一些细节。但其实，他的原理跟我们上面的原理都是差不多的。</p><p>接下来，我也会写 gradle plugin 相关的文章，并借助 gradle 实现 Router 框架。有兴趣的话可以关注我的微信公众号，徐公码字，谢谢。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/68926515">java Type 详解</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/68947735">java 反射机制详解</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52017033">注解使用入门（一）</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/70244169">Android 自定义编译时注解1 - 简单的例子</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/70822023">Android 编译时注解 —— 语法详解</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71512754">带你读懂 ButterKnife 的源码</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p><p><a href="https://xujun.blog.csdn.net/article/details/100998987">Android 点九图机制讲解及在聊天气泡中的应用</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/103263744">面试官，怎样实现 Router 框架？</a></p><p>扫一扫，欢迎关注我的微信公众号 <strong>stormjun94（徐公码字）</strong>， 目前是一名程序员，不仅分享 Android开发相关知识，同时还分享技术人成长历程，包括个人总结，职场经验，面试经验等，希望能让你少走一点弯路。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE4LzE2ZDQ0OGIwNzI4ZGQ3MTY?x-oss-process=image/format,png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 开发中，组件化，模块化是一个老生常谈的问题。随着项目复杂性的增长，模块化是一个必然的趋势。除非你能忍受改一下代码，就需要六七分钟的漫长时间。&lt;/p&gt;
&lt;p&gt;模块化，组件化随之带来的另外一个问题是页面的跳转问题，由于代码的隔离，代码之间有时候会无法互相访问。于
      
    
    </summary>
    
    
      <category term="面试" scheme="https://gdutxiaoxu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官，https 真的安全吗，可以抓包吗，如何防止抓包</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/05/18/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%B3%BB%E5%88%97%20-%20https%20%E7%9C%9F%E7%9A%84%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8A%93%E5%8C%85%E5%90%97%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%8A%93%E5%8C%85%E5%90%97/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/05/18/面试官系列 - https 真的安全吗，可以抓包吗，如何防止抓包吗/</id>
    <published>2019-05-18T08:26:32.000Z</published>
    <updated>2021-04-18T01:58:45.939Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br> <strong>往期文章</strong></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97885526">Android 面试必备 - http 与 https 协议</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97618598">Android 面试必备 - 计算机网络基本知识（TCP，UDP，Http，https）</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/98475465">Android 面试必备 - 线程</a></p><p><a href="https://xujun.blog.csdn.net/article/details/98896053">Android 面试必备 - JVM 及 类加载机制</a></p><p><a href="https://xujun.blog.csdn.net/article/details/99006458">Android 面试必备 - 系统、App、Activity 启动过程</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/107349652">面试官系列- 你真的了解 http 吗</a></p><p><a href="https://xujun.blog.csdn.net/article/details/107393249">面试官问， https 真的安全吗，可以抓包吗，如何防止抓包吗</a></p><p><strong><a href="https://github.com/gdutxiaoxu/Android_interview">Android_interview github 地址</a></strong></p><blockquote><p> 我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br> 我的掘金：<a href="https://juejin.im/user/58aa8508570c35006bbd9e03">https://juejin.im/user/58aa8508570c35006bbd9e03</a>  <br><br> github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br> 微信公众号：徐公码字(stormjun94)  <br><br> 知乎：<a href="https://www.zhihu.com/people/xujun94">https://www.zhihu.com/people/xujun94</a>  <br></p></blockquote><p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94),第一时间会在上面更新</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLWMxMmNjNGUyYjEwMWI5NGE?x-oss-process=image/format,png" alt="image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间，2020 年已过去一大半了，2020 年很难，各企业裁员的消息蛮多的，降职，不发年终奖等等。2020 年确实是艰难的一年。然而生活总是要继续，时间不给你丧的机会！如果我们能坚持下来，不断提高自己，说不定会有新的机会。</p><p>面试中，网络（http， https， tcp， udp）， jvm， 类加载机制等这些基础的知识点是高频出现的，每个程序员都能说上好多。但不一定说到重点，以及理解背后的原理。</p><p>我在面试的过程中也经常被问到，于是总结记录了下来。千万不要小瞧这些基础，有时候，你算法，项目经验都过了，但是基础答得不太好。结果可能会通过，但这肯定会影响你的评级，这是特别吃亏的。所以，不如花点时间背一下，理解一下背后的原理。</p><p>举一个简单的例子， https 连接过程是怎样的，使用了了哪种加密方式，可以抓包吗，怎样防止抓包，你是否能够对答如下。</p><p>废话不多说，开始进入正文。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道，http 通信存在以下问题：</p><ul><li>通信使用明文可能会被窃听</li><li>不验证通信方的身份可能遭遇伪装</li><li>无法证明报文的完整型，可能已遭篡改</li></ul><p>使用 https 可以解决数据安全问题，但是你真的理解 https 吗？</p><p><strong>当面试官连续对你发出灵魂追问的时候，你能对答如流吗</strong></p><ol><li>什么是 https，为什么需要 https</li><li>https 的连接过程</li><li>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密</li><li>https 是绝对安全的吗</li><li>https 可以抓包吗</li></ol><p>如果你能对答自如，恭喜你，https 你已经掌握得差不多了，足够应付面试了。</p><h2 id="什么是-https"><a href="#什么是-https" class="headerlink" title="什么是 https"></a>什么是 https</h2><p>简单来说， https 是 http + ssl，对 http  通信内容进行加密，是HTTP的安全版，是使用TLS/SSL加密的HTTP协议</p><p>Https的作用：</p><ol><li>内容加密 建立一个信息安全通道，来保证数据传输的安全；</li><li>身份认证 确认网站的真实性</li><li>数据完整性 防止内容被第三方冒充或者篡改</li></ol><h3 id="什么是SSL"><a href="#什么是SSL" class="headerlink" title="什么是SSL"></a>什么是SSL</h3><p>SSL 由 Netscape 公司于1994年创建，它旨在通过Web创建安全的Internet通信。它是一种标准协议，用于加密浏览器和服务器之间的通信。它允许通过Internet安全轻松地传输账号密码、银行卡、手机号等私密信息。</p><p>SSL证书就是遵守SSL协议，由受信任的CA机构颁发的数字证书。</p><p>SSL/TLS的工作原理:</p><p>需要理解SSL/TLS的工作原理，我们需要掌握加密算法。加密算法有两种：对称加密和非对称加密：</p><p><strong>对称加密</strong>：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。</p><p><strong>非对称加密</strong>：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。</p><p>公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。相信大多程序员已经对这种算法很熟悉了：我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地.ssh目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。</p><p>公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。</p><h2 id="https-的连接过程"><a href="#https-的连接过程" class="headerlink" title="https 的连接过程"></a>https 的连接过程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTJhYTQyNTg5ZDY4YmMxODYucG5n?x-oss-process=image/format,png" alt="image.png"></p><p>https 的连接过程大概分为两个阶段，证书验证阶段和数据传输阶段</p><h3 id="证书验证阶段"><a href="#证书验证阶段" class="headerlink" title="证书验证阶段"></a>证书验证阶段</h3><p>大概分为三个步骤</p><ol><li>浏览器发起请求</li><li>服务器接收到请求之后，会返回证书，包括公钥</li><li>浏览器接收到证书之后，会检验证书是否合法，不合法的话，会弹出告警提示（怎样验证合法，下文会详细解析，这里先忽略）</li></ol><h3 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h3><p>证书验证合法之后</p><ol><li>浏览器会生成一个随机数，</li><li>使用公钥进行加密，发送给服务端</li><li>服务器收到浏览器发来的值，使用私钥进行解密</li><li>解析成功之后，使用对称加密算法进行加密，传输给客户端</li></ol><p>之后双方通信就使用第一步生成的随机数进行加密通信。</p><h2 id="https-的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计"><a href="#https-的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计" class="headerlink" title="https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计"></a>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计</h2><p>从上面我们可以知道，https 加密是采用对称加密和非对称机密一起结合的。</p><p>在证书验证阶段，使用非对称加密。<br>在数据传输阶段，使用对称机密。</p><p>这样设计有一个好处，能最大程度得兼顾安全效率。</p><p>在证书验证阶段，使用非对称加密，需要公钥和私钥，假如浏览器的公钥泄漏了，我们还是能够确保随机数的安全，因为加密的数据只有用私钥才能解密。这样能最大程度确保随机数的安全。</p><p>在内容传输阶段，使用对称机密，可以大大提高加解密的效率。</p><h3 id="内容传输为什么要使用对称机密"><a href="#内容传输为什么要使用对称机密" class="headerlink" title="内容传输为什么要使用对称机密"></a>内容传输为什么要使用对称机密</h3><ol><li>对称加密效率比较高</li><li>一对公私钥只能实现单向的加解密。只有服务端保存了私钥。如果使用非对称机密，相当于客户端必须有自己的私钥，这样设计的话，每个客户端都有自己的私钥，这很明显是不合理的，因为私钥是需要申请的。</li></ol><h2 id="https-是绝对安全的吗"><a href="#https-是绝对安全的吗" class="headerlink" title="https 是绝对安全的吗"></a>https 是绝对安全的吗</h2><p>不是绝对安全的，可以通过中间人攻击。</p><h3 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h3><p>中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p><p>HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，拦截客户端的请求，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTM1ZjE1YzFhNjllZTZiMDYucG5n?x-oss-process=image/format,png" alt="image.png"></p><p>过程原理：</p><ol><li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li><li>中间人服务器返回中间人自己的证书</li><li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li><li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li><li>中间人以客户端的请求内容再向正规网站发起请求</li><li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li><li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li><li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li><li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li></ol><p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p><h3 id="https-是如何防止中间人攻击的"><a href="#https-是如何防止中间人攻击的" class="headerlink" title="https 是如何防止中间人攻击的"></a>https 是如何防止中间人攻击的</h3><p>在https中需要证书，证书的作用是为了防止”中间人攻击”的。 如果有个中间人M拦截客户端请求,然后M向客户端提供自己的公钥，M再向服务端请求公钥,作为”中介者” 这样客户端和服务端都不知道,信息已经被拦截获取了。这时候就需要证明服务端的公钥是正确的.</p><p>怎么证明呢?</p><p>就需要权威第三方机构来公正了.这个第三方机构就是CA. 也就是说CA是专门对公钥进行认证，进行担保的，也就是专门给公钥做担保的担保公司。 全球知名的CA也就100多个，这些CA都是全球都认可的，比如VeriSign、GlobalSign等，国内知名的CA有WoSign。</p><h3 id="浏览器是如何确保CA证书的合法性？"><a href="#浏览器是如何确保CA证书的合法性？" class="headerlink" title="浏览器是如何确保CA证书的合法性？"></a>浏览器是如何确保CA证书的合法性？</h3><p>一、证书包含什么信息？</p><p>颁发机构信息、公钥、公司信息、域名、有效期、指纹……</p><p>二、证书的合法性依据是什么？</p><p>首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。</p><p>三、浏览器如何验证证书的合法性？</p><p>浏览器发起HTTPS请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p><ol><li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行校验；</li><li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与CA服务器的交互，提高验证效率。</li></ol><p>以上任意一步都满足的情况下浏览器才认为证书是合法的。</p><h2 id="https-可以抓包吗"><a href="#https-可以抓包吗" class="headerlink" title="https 可以抓包吗"></a>https 可以抓包吗</h2><p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。</p><p>但是，我们可以通过抓包工具来抓包。它的原理其实是模拟一个中间人。</p><p>通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>关于 httpps 抓包的原理可以看这一篇文章。</p><p><a href="https://juejin.im/post/5cc313755188252d6f11b463">Android平台HTTPS抓包解决方案及问题分析</a></p><p><strong>有人可能会问了，既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</strong></p><p>HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="如何防止抓包？"><a href="#如何防止抓包？" class="headerlink" title="如何防止抓包？"></a>如何防止抓包？</h3><p>对于HTTPS API接口，如何防止抓包呢？既然问题出在证书信任问题上，那么解决方法就是在我们的APP中预置证书。在TLS/SSL握手时，用预置在本地的证书中的公钥校验服务器的数字签名，只有签名通过才能成功握手。由于数字签名是使用私钥生成的，而私钥只掌握在我们手上，中间人无法伪造一个有效的签名，因此攻击失败，无法抓包。</p><p>同时，为了防止预置证书被替换，在证书存储上，可以将证书进行加密后进行「嵌入存储」，如嵌入在图片中或一段语音中。这涉及到信息隐写的领域，这个话题我们有空了详细说。</p><p>关于 Android 中Https 请求如何防止中间人攻击和Charles抓包，可以看一下这一篇文章。</p><p><a href="https://www.jianshu.com/p/1dd77e56cc3c">Android中Https请求如何防止中间人攻击和Charles抓包原理</a></p><h3 id="预置证书-公钥更新问题"><a href="#预置证书-公钥更新问题" class="headerlink" title="预置证书/公钥更新问题"></a>预置证书/公钥更新问题</h3><p>这样做虽然解决了抓包问题，但是也带来了另外一个问题：我们购买的证书都是有有效期的，到期前需要对证书进行更新。主要有两种方式：</p><p>提供预置证书更新接口。在当前证书快过期时，APP请求获取新的预置证书，这过渡时期，两个证书同时有效，直到安全完成证书切换。这种方式有一定的维护成本，且不易测试。<br>在APP中只预埋公钥，这样只要私钥不变，即使证书更新也不用更新该公钥。但是，这样不太符合周期性更新私钥的安全审计需求。一个折中的方法是，一次性预置多个公钥，只要任意一个公钥验证通过即可。考虑到我们的证书一般购买周期是3-5年，那么3个公钥，可以使用9-15年，同时，我们在此期间还可以发布新版本废弃老公钥，添加新公钥，这样可以使公钥一直更新下去。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>开头说到的几个问题，你能对答如流了吗</p><ol><li>什么是 https，为什么需要 https</li><li>https 的连接过程</li><li>https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密</li><li>https 是绝对安全的吗</li><li>https 可以抓包吗</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLTU5YmRkYTdhMmU3OTQ1MDg?x-oss-process=image/format,png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;br&gt; &lt;strong&gt;往期文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gdutxiaoxu/article/details/97885526&quot;&gt;Android 面试必备 - http 与 https 协
      
    
    </summary>
    
    
      <category term="面试" scheme="https://gdutxiaoxu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官，你真的了解 http 吗</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/05/12/%E9%9D%A2%E8%AF%95%E5%AE%98%E7%B3%BB%E5%88%97-%20%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20http%20%E5%90%97/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/05/12/面试官系列- 你真的了解 http 吗/</id>
    <published>2019-05-12T08:26:32.000Z</published>
    <updated>2021-04-18T01:58:05.359Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p> 我的 CSDN 博客:<a href="https://blog.csdn.net/gdutxiaoxu">https://blog.csdn.net/gdutxiaoxu</a> <br><br> 我的掘金：<a href="https://juejin.im/user/58aa8508570c35006bbd9e03">https://juejin.im/user/58aa8508570c35006bbd9e03</a>  <br><br> github: <a href="https://github.com/gdutxiaoxu/">https://github.com/gdutxiaoxu/</a>  <br><br> 微信公众号：徐公码字(stormjun94)  <br><br> 知乎：<a href="https://www.zhihu.com/people/xujun94">https://www.zhihu.com/people/xujun94</a>  <br></p></blockquote><h2 id="往期文章"><a href="#往期文章" class="headerlink" title="往期文章"></a>往期文章</h2><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97885526">Android 面试必备 - http 与 https 协议</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/97618598">Android 面试必备 - 计算机网络基本知识（TCP，UDP，Http，https）</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/98475465">Android 面试必备 - 线程</a></p><p><a href="https://xujun.blog.csdn.net/article/details/98896053">Android 面试必备 - JVM 及 类加载机制</a></p><p><a href="https://xujun.blog.csdn.net/article/details/99006458">Android 面试必备 - 系统、App、Activity 启动过程</a></p><p><strong><a href="https://github.com/gdutxiaoxu/Android_interview">Android_interview github 地址</a></strong></p><p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94),第一时间会在上面更新</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQyYmNkMjg?x-oss-process=image/format,png" alt="image"></p><h2 id="面试常见"><a href="#面试常见" class="headerlink" title="面试常见"></a>面试常见</h2><h3 id="一道经典的面试题"><a href="#一道经典的面试题" class="headerlink" title="一道经典的面试题"></a>一道经典的面试题</h3><p>还记得这道经典的面试题目吗？从 URL 在浏览器被被输入到页面展现的过程中发生了什么？</p><p>总体来说分为以下几个过程:</p><ul><li>DNS 解析:将域名解析成 IP 地址</li><li>TCP 连接：TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接：TCP 四次挥手</li></ul><p>完整的可以看以下下面的图片</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQxN2I1OGQ?x-oss-process=image/format,png" alt="image"></p><h2 id="http-必备基础知识"><a href="#http-必备基础知识" class="headerlink" title="http 必备基础知识"></a>http 必备基础知识</h2><p>HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQzYmYxNTk?x-oss-process=image/format,png" alt="image"></p><p>HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。</p><ul><li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。</li><li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。</li><li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</li></ul><h3 id="什么是无状态协议，HTTP-是无状态协议吗，怎么解决"><a href="#什么是无状态协议，HTTP-是无状态协议吗，怎么解决" class="headerlink" title="什么是无状态协议，HTTP 是无状态协议吗，怎么解决"></a>什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h3><p>无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。<br>如果你的浏览器允许 cookie 的话，查看方式 chrome://settings/content/cookies</p><h3 id="几种方法"><a href="#几种方法" class="headerlink" title="几种方法"></a>几种方法</h3><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</p><ul><li>GET: 通常用于请求服务器发送某些资源</li><li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</li><li>OPTIONS: 用于获取目的资源所支持的通信选项</li><li>POST: 发送数据给服务器，是<strong>非幂等</strong>的</li><li>PUT: 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST不需要置顶资源在服务器的位置，是<strong>幂等</strong>的</li><li>DELETE: 用于删除指定的资源</li><li>PATCH: 用于对资源进行部分修改</li><li>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li><li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li></ul><h3 id="http-get-和-post-区别"><a href="#http-get-和-post-区别" class="headerlink" title="http get 和 post 区别"></a>http get 和 post 区别</h3><table><thead><tr><th>Post一般用于更新或者添加资源信息</th><th align="center">Get一般用于查询操作，而且应该是安全和幂等的</th></tr></thead><tbody><tr><td>Post更加安全</td><td align="center">Get会把请求的信息放到URL的后面</td></tr><tr><td>Post传输量一般无大小限制</td><td align="center">Get不能大于2KB</td></tr><tr><td>Post执行效率低</td><td align="center">Get执行效率略高</td></tr></tbody></table><h3 id="http-put-和-post-区别"><a href="#http-put-和-post-区别" class="headerlink" title="http put 和 post 区别"></a>http put 和 post 区别</h3><p><strong>举一个简单的例子</strong></p><p>POST:用于提交请求，可以更新或者创建资源，是非幂等的</p><p>举个例子，在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST</p><p>PUT: 用于向指定的URI传送更新资源，是幂等的</p><p>还是那个例子，用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码</p><p><strong>如果从 RESTful API 的角度来理解，PUT 方法是这么工作的：</strong></p><p>把一个对象 V 绑定到地址 K 上；今后请求地址 K 时，就会返回对象 V。</p><p>如果地址 K 之前曾绑定过另一个对象，比如 V0，那么 V0 会被 V 替换。</p><p>举一个简单的例子，假设我的博客后台支持 RESTful API，我可以通过下面的请求发布这篇文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT https:&#x2F;&#x2F;gdutxiao.github.io&#x2F;2018&#x2F;04&#x2F;16&#x2F;http-put-vs-post HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 文章内容正文 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用 PUT 方法时，客户端需要在 HTTP 请求中明确指定地址 K。</p><p>正如 Java 的例子一样，PUT 方法应当支持幂等性。如果是同一个对象 V，PUT 多次与 PUT 一次返回的结果应该是相同的。客户端可以利用 PUT 的幂等性安全地重试请求，保证客户端的请求至少被服务端处理一次。</p><p>如果把上面发布文章的例子用 HTTP POST 方法重写，它可能会是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST https:&#x2F;&#x2F;gdutxiao.github.io&#x2F;post-article HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* 文章内容正文 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，地址 K 不是由客户端指定的，而是由服务端生成的。比如，服务端可能会根据日期和文章标题，为本文分配一个地址。</p><p>另外，与 PUT 方法不同，POST 方法是不支持幂等性的。同一个请求被处理两次，应当生成两份对象。换句话说，客户端应该只发送一次 POST 请求，而客户端的请求至多会被服务端处理一次。</p><blockquote><p>现在问题来了，如果真的遇到了网络故障，客户端应该如何重试 POST 请求呢？解决方法其实很简单，我们可以在 POST 请求中隐藏一个唯一的 token，服务端在处理请求后把 token 存入数据库，如果这个 token 之前遇到过，服务端就知道这是重复的 POST 请求，可以不再处理了。</p></blockquote><h2 id="http-版本"><a href="#http-版本" class="headerlink" title="http 版本"></a>http 版本</h2><h3 id="1-0-与-1-1"><a href="#1-0-与-1-1" class="headerlink" title="1.0 与 1.1"></a>1.0 与 1.1</h3><ul><li>http1.0一次只能处理一个请求，不能同时收发数据</li><li>http1.1可以处理多个请求，能同时收发数据</li><li>http1.1增加可更多字段，如cache-control,keep-alive.</li></ul><h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><ul><li>http 2.0采用二进制的格式传送数据，不再使用文本格式传送数据</li><li>http2.0对消息头采用hpack压缩算法，http1.x的版本消息头带有大量的冗余消息</li><li>http2.0 采用多路复用，即用一个tcp连接处理所有的请求，真正意义上做到了并发请求，流还支持优先级和流量控制（HTTP/1.x 虽然通过 pipeline也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。）</li><li>http2.0支持server push，服务端可以主动把css，jsp文件主动推送到客户端，不需要客户端解析HTML，再发送请求，当客户端需要的时候，它已经在客户端了。</li></ul><p><strong>缺点</strong></p><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题， <strong>主要是底层支撑的 TCP 协议造成的</strong><br>。HTTP/2的缺点主要有以下几点：</p><ul><li>TCP 以及 TCP+TLS建立连接的延时</li></ul><p>HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，<br><strong>这样就需要有两个握手延迟过程</strong> ：</p><p>①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。</p><p>②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。</p><p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</p><ul><li>TCP的队头阻塞并没有彻底解决</li></ul><p>上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1<br>了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP<br>都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP<br>连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQ1MTVlNzg?x-oss-process=image/format,png" alt="image"></p><h3 id="Http-3-0"><a href="#Http-3-0" class="headerlink" title="Http 3.0"></a>Http 3.0</h3><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。<br>而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzQ3MGZmZWM?x-oss-process=image/format,png" alt="image"></p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。</p><h4 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h4><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p><ul><li>实现了类似TCP的流量控制、传输可靠性的功能。</li></ul><p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p><ul><li>实现了快速握手功能。</li></ul><p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<br><strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong> 。</p><ul><li>集成了TLS加密功能。</li></ul><p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p><ul><li>多路复用，彻底解决TCP中队头阻塞的问题</li></ul><p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyNzUxNmVhMzc?x-oss-process=image/format,png" alt="image"></p><p>关于 http 3.0 的，如果想了解更多，可以查看这一篇文章。<a href="https://juejin.im/post/5d9abde7e51d4578110dc77f">解密HTTP/2与HTTP/3 的新特性</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</li><li>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议</li></ul><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><table><thead><tr><th>Http 状态码</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>请求成功</td></tr><tr><td>206</td><td>支持断点下载（range = byte = 0 -1024)</td></tr><tr><td>301</td><td>永远移动</td></tr><tr><td>302</td><td>临时移动</td></tr><tr><td>303</td><td>See Other    查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>无更新</td></tr><tr><td>400</td><td>Bad request,服务器无法识别</td></tr><tr><td>403</td><td>禁止访问</td></tr><tr><td>404</td><td>not found</td></tr><tr><td>405</td><td>Method Not Allowed    客户端请求中的方法被禁止</td></tr><tr><td>500</td><td>Internal Server Error    服务器内部错误，无法完成请求</td></tr></tbody></table><p>关于更详细的可以查看 </p><p><a href="https://www.runoob.com/http/http-status-codes.html">http 状态码</a></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>下一篇预告，将会推出 面试官系列 - https 真的安全吗，可以抓包吗，如何防止抓包。</p><p><strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94）</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkZGUyYTE3NGY5ZWI?x-oss-process=image/format,png" alt="image"></p><p> <strong>目前从事于 Android 开发，除了分享 Android开发相关知识，还有职场心得，面试经验，学习心得，人生感悟等等。希望通过该公众号，让你看到程序猿不一样的一面，我们不只会敲代码，我们还会。。。。。。，期待你的参与</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 我的 CSDN 博客:&lt;a href=&quot;https://blog.csdn.net/gdutxiaoxu&quot;&gt;https://blog.csdn.net/gdutxiaoxu&lt;/a&gt; &lt;br&gt;&lt;br&gt; 我的掘金：&lt;a h
      
    
    </summary>
    
    
      <category term="面试" scheme="https://gdutxiaoxu.gitee.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android LiveData 源码分析</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/01/14/Android%20livedata%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/01/14/Android livedata 源码解剖/</id>
    <published>2019-01-14T08:26:32.000Z</published>
    <updated>2021-04-18T01:47:37.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><p><strong>Android 技术人，一位不羁的码农。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/81273649f00c4d30340a268b8613286b.png" alt="Android 技术人"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面三篇博客中，我们已经介绍了 lifecycle 的使用及原理，livedata ,ViewModel 的常用用法，今天，让我们一起来学习 livedata  的原理。</p><p>我们先来回顾一下 LiveData  的特点：</p><p>LiveData 是一个可以被观察的数据持有类，它可以感知 Activity、Fragment或Service 等组件的生命周期。</p><ol><li>它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI。</li><li>不用担心发生内存泄漏</li><li>当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。内部已经帮我们封装好了。</li><li>当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调 obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver</li></ol><p>下面，让我们一步步解剖它</p><hr><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我们知道 livedata 的使用很简单，它是采用观察者模式实现的</p><ol><li>添加观察者</li><li>在数据改变的时候设置 value，这样会回调 Observer 的 onChanged 方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MutableLiveData&lt;<span class="built_in">String</span>&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="observe-方法"><a href="#observe-方法" class="headerlink" title="observe 方法"></a>observe 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">observe</span>(<span class="params">@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否已经销毁</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line"><span class="comment">// observer 已经添加过了，并且缓存的 observer 跟 owner 的 observer 不一致，状态异常，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 已经添加过 Observer 了，返回回去</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 observer</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，我们先来看一下它的 observe 方法，首先通过 owner.getLifecycle().getCurrentState() 获取状态，判断是否已经被销毁，如果已经被销毁，直接返回。接着用 LifecycleBoundObserver 包装起来。然后从缓存的 mObservers 中读取 observer，如果有，证明已经添加过了。</p><p>observe 方法，小结起来就是</p><ol><li>判断是否已经销毁，如果销毁，直接移除</li><li>用 LifecycleBoundObserver 包装传递进来的 observer</li><li>是否已经添加过，添加过，直接返回</li><li>将包装后的 LifecycleBoundObserver 添加进去</li></ol><p>因此，当 owner 你（Activity 或者 fragment） 生命周期变化的时候，会回调 LifecycleBoundObserver 的 onStateChanged 方法，onStateChanged 方法又会回调  observer 的 onChange 方法</p><h3 id="LifecycleBoundObserver"><a href="#LifecycleBoundObserver" class="headerlink" title="LifecycleBoundObserver"></a>LifecycleBoundObserver</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="title">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    @NonNull final LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">LifecycleBoundObserver</span>(<span class="params">@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean <span class="function"><span class="title">shouldBeActive</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean <span class="function"><span class="title">isAttachedTo</span>(<span class="params">LifecycleOwner owner</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">void</span> <span class="function"><span class="title">detachObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看一下 LifecycleBoundObserver，继承 ObserverWrapper，实现了 GenericLifecycleObserver 接口。而 GenericLifecycleObserver 接口又实现了 LifecycleObserver 接口。 它包装了我们外部的 observer，有点类似于代理模式。</p><p>GenericLifecycleObserver#onStateChanged</p><p>Activity 回调周期变化的时候，会回调 onStateChanged ，会先判断 mOwner.getLifecycle().getCurrentState() 是否已经 destroy 了，如果。已经 destroy，直接移除观察者。<strong>这也就是为什么我们不需要手动 remove observer 的原因</strong>。</p><p>如果不是销毁状态，会调用 activeStateChanged 方法 ，携带的参数为 shouldBeActive() 返回的值。<br>而当 lifecycle 的 state 为 started 或者 resume 的时候，shouldBeActive 方法的返回值为 true，即表示激活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">   <span class="comment">// owner</span></span><br><span class="line">   mActive = newActive;</span><br><span class="line">   <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">   LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">       onActive();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">       onInactive();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">       dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>}</p><p>activeStateChanged 方法中，，当 newActive 为 true，并且不等于上一次的值，会增加 LiveData 的 mActiveCount 计数。接着可以看到，onActive 会在 mActiveCount 为 1 时触发，onInactive 方法则只会在 mActiveCount 为 0 时触发。<strong>即回调 onActive 方法的时候活跃的 observer 恰好为 1，回调 onInactive 方法的时候，没有一个 Observer 处于激活状态。</strong></p><p>当 mActive 为 true 时，会促发 dispatchingValue 方法。</p><p>dispatchingValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果正在处理，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// initiator 不为 null，调用 considerNotify 方法</span></span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 为 null 的时候，遍历所有的 obsever，进行分发</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line"><span class="comment">// 分发完成，设置为 false</span></span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mDispatchingValue, mDispatchInvalidated 只在 dispatchingValue 方法中使用，显然这两个变量是为了防止重复分发相同的内容。当 initiator 不为 null，只处理当前 observer，为 null 的时候，遍历所有的 obsever，进行分发</p><p>considerNotify 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果状态不是在活跃中，直接返回</span><br><span class="line">    if (!observer.mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Check latest state b4 dispatch. Maybe it changed state but we didn&#39;t get the event yet.</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; we still first check observer.active to keep it as the entrance for events. So even if</span><br><span class="line">    &#x2F;&#x2F; the observer moved to an active state, if we&#39;ve not received that event, we better not</span><br><span class="line">    &#x2F;&#x2F; notify for a more predictable notification order.</span><br><span class="line">    if (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (observer.mLastVersion &gt;&#x3D; mVersion) &#123;</span><br><span class="line">&#x2F;&#x2F; 数据已经是最新，返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 将上一次的版本号置为最新版本号</span><br><span class="line">    observer.mLastVersion &#x3D; mVersion;</span><br><span class="line">    &#x2F;&#x2F;noinspection unchecked</span><br><span class="line">&#x2F;&#x2F; 调用外部的 mObserver 的 onChange 方法</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>  如果状态不是在活跃中，直接返回，这也就是为什么当我们的 Activity 处于 onPause， onStop， onDestroy 的时候，不会回调 observer 的 onChange 方法的原因。</li><li>  判断数据是否是最新，如果是最新，返回，不处理</li><li>数据不是最新，回调 mObserver.onChanged 方法。并将 mData 传递过去</li></ol><h3 id="setValue"><a href="#setValue" class="headerlink" title="setValue"></a>setValue</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">setValue</span>(<span class="params">T value</span>)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setValue 方法中，首先，断言是主线程，接着  mVersion + 1; 并将 value 赋值给 mData，接着调用 dispatchingValue 方法。dispatchingValue 传递 null，代表处理所有 的 observer。</p><p><strong>这个时候如果我们依附的 activity 处于 onPause 或者 onStop 的时候，虽然在 dispatchingValue 方法中直接返回，不会调用 observer 的 onChange 方法。但是当所依附的 activity 重新回到前台的时候，会促发  LifecycleBoundObserver onStateChange 方法，onStateChange 又会调用 dispatchingValue 方法，在该方法中，因为 mLastVersion &lt; mVersion。所以会回调 obsever 的 onChange 方法，这也就是 LiveData 设计得比较巧妙的一个地方</strong></p><p>同理，当 activity 处于后台的时候，您多次调用 livedata 的 setValue 方法，最终只会回调 livedata observer 的 onChange 方法一次。</p><h3 id="postValue"><a href="#postValue" class="headerlink" title="postValue"></a>postValue</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">postValue</span>(<span class="params">T value</span>)</span> &#123;</span><br><span class="line">   boolean postTask;</span><br><span class="line">   <span class="comment">// 锁住</span></span><br><span class="line">   synchronized (mDataLock) &#123;</span><br><span class="line">      <span class="comment">// 当前没有人在处理 post 任务</span></span><br><span class="line">       postTask = mPendingData == NOT_SET;</span><br><span class="line">       mPendingData = value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   AppToolkitTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line">private final Runnable mPostValueRunnable = <span class="keyword">new</span> <span class="function"><span class="title">Runnable</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">Object</span> newValue;</span><br><span class="line">       synchronized (mDataLock) &#123;</span><br><span class="line">           newValue = mPendingData;</span><br><span class="line">   <span class="comment">// 处理完毕之后将 mPendingData 置为 NOT_SET</span></span><br><span class="line">           mPendingData = NOT_SET;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//noinspection unchecked</span></span><br><span class="line">       setValue((T) newValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>首先，采用同步机制，通过 postTask = mPendingData == NOT_SET 有没有人在处理任务。 true，没人在处理任务， false ，有人在处理任务，有人在处理任务的话，直接返回</li><li>调用  AppToolkitTaskExecutor.getInstance().postToMainThread 到主线程执行 mPostValueRunnable 任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">    AlwaysActiveObserver wrapper = <span class="keyword">new</span> AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing <span class="keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AlwaysActiveObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为 AlwaysActiveObserver 没有实现 GenericLifecycleObserver 方法接口，所以在 Activity o生命周期变化的时候，不会回调 onStateChange 方法。从而也不会主动 remove 掉 observer。因为我们的 obsever 被 remove 掉是依赖于 Activity 生命周期变化的时候，回调 GenericLifecycleObserver 的 onStateChange 方法。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>liveData 当我们 addObserver 的时候，会用 LifecycleBoundObserver 包装 observer，而 LifecycleBoundObserver 可以感应生命周期，当 activity 生命周期变化的时候，如果不是处于激活状态，判断是否需要 remove 生命周期，需要 remove，不需要，直接返回</li><li>当处于激活状态的时候，会判断是不是 mVersion最新版本，不是的话需要将上一次缓存的数据通知相应的 observer，并将 mLastVsersion 置为最新</li><li>当我们调用 setValue 的时候，mVersion +1，如果处于激活状态，直接处理，如果不是处理激活状态，返回，等到下次处于激活状态的时候，在进行相应的处理</li><li>如果你想 livedata setValue 之后立即回调数据，而不是等到生命周期变化的时候才回调数据，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。因为 AlwaysActiveObserver 没有实现 GenericLifecycleObserver 接口，不能感应生命周期。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/6010e8b1224400ad1cf93012b51df699.png"></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Android  Architecture Components    已经写了四篇文章了，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后再更新了，欢迎关注我的公众号，有更新的话会第一时间在公众好上面更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifec
      
    
    </summary>
    
    
      <category term="Android LiveData" scheme="https://gdutxiaoxu.gitee.io/tags/Android-LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Android LiveData 使用详解</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/01/13/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/01/13/Android LiveData 使用详解/</id>
    <published>2019-01-13T08:26:32.000Z</published>
    <updated>2021-04-18T01:47:15.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p><p>目录大概如下</p><blockquote><p>1 LiveData 基本使用<br>2 自定义 Livedata<br>3  Livedata 共享数据<br>4 Livedata  小结</p></blockquote><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><p><strong>程序员徐公，一位不羁的码农。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e6df41528ff27a085a266dd18b707a8.png"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博客中，我们讲解了 lifecycle 的使用及优点。这篇博客让我们一起来了解一下 LiveData 是怎样使用的？</p><hr><h2 id="为什么要引进-LiveData"><a href="#为什么要引进-LiveData" class="headerlink" title="为什么要引进 LiveData"></a>为什么要引进 LiveData</h2><p>LiveData 是一个可以被观察的数据持有类，它可以感知 Activity、Fragment或Service 等组件的生命周期。简单来说，他主要有一下优点。</p><ol><li><strong>它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI</strong>。</li><li><strong>不用担心发生内存泄漏</strong></li><li><strong>当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。它已经帮我们封装好了</strong>。</li><li>当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调  obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。</li></ol><p>回想一下，在你的项目中，是不是经常会碰到这样的问题，当网络请求结果回来的时候，你经常需要判断 Activity 或者 Fragment 是否已经 Destroy， 如果不是 destroy，才更新 UI。</p><p>而当你如果使用 Livedata 的话，因为它是在 Activity 处于 onStart 或者 onResume 的状态时，他才会进行相应的回调，因而可以很好得处理这个问题，不必写一大堆的 activity.isDestroyed()。接下来，让我们一起来看一下 LiveData  的使用</p><hr><h2 id="LiveData-使用"><a href="#LiveData-使用" class="headerlink" title="LiveData 使用"></a>LiveData 使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>引入相关的依赖包</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModel and LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:viewmodel:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:livedata:1.1.0&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在代码中使用</li></ol><p>LiveData 是一个抽象类，它的实现子类有 <strong>MutableLiveData</strong> ，<strong>MediatorLiveData</strong>。在实际使用中，用得比较多的是 MutableLiveData。他常常结合 ViewModel 一起使用。下面，让我们一起来看一下怎样使用它？</p><p>首先，我们先写一个类继承我们的 ViewModel，里面持有 mNameEvent。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private MutableLiveData&lt;<span class="built_in">String</span>&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MutableLiveData&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">getNameEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们在 Activity 中创建  ViewModel，并监听 ViewModel 里面 mNameEvent 数据的变化，当数据改变的时候，我们打印相应的 log，并设置给 textView，显示在界面上。这样我们就完成了对 mNameEvent 数据源的观察。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mTestViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;String&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> String s)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后当我们数据源改变的时候，我们需要调用 livedata 的 setValue 或者 postvalue 方法。他们之间的区别是， 调用 setValue 方法，Observer 的 onChanged 方法会在调用 serValue 方法的线程回调。而<br>postvalue 方法，Observer 的 onChanged 方法将会在主线程回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTestViewModel.getNameEvent().setValue(name);</span><br></pre></td></tr></table></figure><p>可能部分同学有这样的疑问了，<strong>我们的 ViewModel 是通过 ViewModelProviders.of(this).get(TestViewModel.class); 方法创建出来的，如果我们要携带参数，怎么办？</strong></p><p>其实，官方也替我们考虑好了，同样是调用 ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) 方法，只不过，需要多传递一个 factory 参数。</p><p>Factory 是一个接口，它只有一个 create 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a newly created ViewModel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际当中，我们的做法是：实现 Factory 接口，重写 create 方法，在create 方法里面调用相应的构造函数，返回相应的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mKey;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;String&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getNameEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestViewModel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        mKey = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String mKey;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            mKey = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> TestViewModel(mKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModelProviders.of(this, new TestViewModel.Factory(mkey)).get(TestViewModel.class)</p><hr><h2 id="自定义-Livedata"><a href="#自定义-Livedata" class="headerlink" title="自定义 Livedata"></a>自定义 Livedata</h2><p>Livedata 主要有几个方法</p><ol><li>observe</li><li>onActive</li><li>onInactive </li><li>observeForever </li></ol><p> void observe (LifecycleOwner owner,     Observer<T> observer)</p><blockquote><p>Adds the given observer to the observers list within the lifespan of the given owner. The events are dispatched on the main thread. If LiveData already has data set, it will be delivered to the observer.</p></blockquote><p>void onActive ()</p><blockquote><p>Called when the number of active observers change to 1 from 0.<br>This callback can be used to know that this LiveData is being used thus should be kept up to date.</p></blockquote><p>当回调该方法的时候，表示该 liveData 正在背使用，因此应该保持最新</p><p> void onInactive ()</p><blockquote><p>Called when the number of active observers change from 1 to 0.<br>This does not mean that there are no observers left, there may still be observers but their lifecycle states aren’t STARTED or RESUMED (like an Activity in the back stack).<br>You can check if there are observers via hasObservers().</p></blockquote><p>当该方法回调时，表示他所有的 obervers 没有一个状态处理 STARTED 或者 RESUMED，注意，这不代表没有 observers。</p><p>Void observeForever </p><p>跟 observe 方法不太一样的是，它在 Activity 处于 onPause ，onStop， onDestroy 的时候，都可以回调 obsever 的 onChange 方法，但是有一点需要注意的是，我们必须手动 remove obsever，否则会发生内存泄漏。</p><p>这里我们以观察网络状态变化为例子讲解</p><ol><li>首先我们自定义一个 Class NetworkLiveData，继承 LiveData，重写它的 onActive 方法和 onInactive 方法</li><li>在 onActive 方法中，我们注册监听网络变化的广播，即ConnectivityManager.CONNECTIVITY_ACTION。在 onInactive 方法的时候，我们注销广播。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">NetworkInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">static</span> NetworkLiveData mNetworkLiveData;</span><br><span class="line">    <span class="keyword">private</span> NetworkReceiver mNetworkReceiver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntentFilter mIntentFilter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;NetworkLiveData&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetworkLiveData</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        mNetworkReceiver = <span class="keyword">new</span> NetworkReceiver();</span><br><span class="line">        mIntentFilter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkLiveData <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mNetworkLiveData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNetworkLiveData = <span class="keyword">new</span> NetworkLiveData(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mNetworkLiveData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onActive:&quot;</span>);</span><br><span class="line">        mContext.registerReceiver(mNetworkReceiver, mIntentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInactive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onInactive: &quot;</span>);</span><br><span class="line">        mContext.unregisterReceiver(mNetworkReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            ConnectivityManager manager = (ConnectivityManager) context</span><br><span class="line">                    .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            NetworkInfo activeNetwork = manager.getActiveNetworkInfo();</span><br><span class="line">            getInstance(context).setValue(activeNetwork);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们想监听网络变化的时候，我们只需要调用相应的 observe 方法即可，方便又快捷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NetworkLiveData.getInstance(<span class="built_in">this</span>).observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;NetworkInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable NetworkInfo networkInfo</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: networkInfo=&quot;</span> +networkInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><a href="https://www.jianshu.com/p/4b7945475a6f">https://www.jianshu.com/p/4b7945475a6f</a></p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><h3 id="Fragment-Activity-之间共享数据"><a href="#Fragment-Activity-之间共享数据" class="headerlink" title="Fragment Activity 之间共享数据"></a>Fragment Activity 之间共享数据</h3><p>我们回过头来再来看一下 ViewModelProvider 的 of 方法，他主要有四个方法，分别是</p><ol><li>ViewModelProvider of(@NonNull Fragment fragment)</li><li>ViewModelProvider of(@NonNull FragmentActivity activity)</li><li>ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory)</li><li> ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory)</li></ol><p>1,2 方法之间的主要区别是传入 Fragment 或者 FragmentActivity。而我们知道，通过 ViewModel of 方法创建的 ViewModel 实例， 对于同一个 fragment 或者 fragmentActivity 实例，ViewModel 实例是相同的，因而我们可以利用该特点，在 Fragment 中创建  ViewModel  的时候，传入的是 Fragment 所依附的 Activity。因而他们的 ViewModel 实例是相同的，从而可以做到共享数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// LiveDataSampleActivity(TestFragment 依赖的 Activity）</span></span><br><span class="line">mTestViewModel = ViewModelProviders.of(<span class="built_in">this</span>, <span class="keyword">new</span> TestViewModel.Factory(mkey)).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;<span class="built_in">String</span>&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestFragment 中</span></span><br><span class="line">mViewModel = ViewModelProviders.of(mActivity).get(TestViewModel.class);</span><br><span class="line">mViewModel.getNameEvent().observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s =&quot;</span> + s + <span class="string">&quot; mViewModel.getKey() =&quot;</span> + mViewModel.getKey());</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">        boolean result = mViewModel == ((LiveDataSampleActivity) mListener).mTestViewModel;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s result =&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，LiveDataSampleActivity 和 TestFragment 中的 ViewModel 是同一个实例。即 Activity 和 Fragment 共享数据。</p><h3 id="全局共享数据"><a href="#全局共享数据" class="headerlink" title="全局共享数据"></a>全局共享数据</h3><p>说到全局共享数据，我们想一下我们的应用全景，比如说我的账户数据，这个对于整个 App 来说，肯定是全局共享的。有时候，当我们的数据变化的时候，我们需要通知我们相应的界面，刷新 UI。如果用传统的方式来实现，那么我们一般才采取观察者的方式来实现，这样，当我们需要观察数据的时候，我们需要添加 observer，在界面销毁的时候，我们需要移除 observer。</p><p>但是，如果我们用 LiveData 来实现的话，它内部逻辑都帮我们封装好了，我们只需要保证 AccountLiveData 是单例的就ok，在需要观察的地方调用 observer 方法即可。也不需要手动移除 observer，不会发生内存泄漏，方便快捷。</p><p>这里 AccountLiveData 的实现就不贴出来了，可以参考上面的 NetworkLiveData 实现</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里说一点关于 LiveData 与 ViewModel 的应用场景，我尽量说得通俗一点，不要说得那么官方，这样对新手很难理解。</p><p>觉得不错的，请点个赞，让我们看到你们的欢呼声。你们的支持就是我写作的最大动力。</p><ol><li> LiveData 内部已经实现了观察者模式，如果你的数据要同时通知几个界面，可以采取这种方式</li><li> 我们知道 LiveData 数据变化的时候，会回调 Observer 的 onChange 方法，但是回调的前提是 lifecycleOwner（即所依附的 Activity 或者 Fragment） 处于 started 或者 resumed 状态，它才会回调，否则，必须等到 lifecycleOwner 切换到前台的时候，才回调。</li><li>因此，这对性能方面确实是一个不小的提升。但是，对于你想做一些类似与在后台工作的（黑科技）， liveData 就不太适合了，你可以使用 observeForever  方法，或者自己实现观察者模式去吧。</li></ol><p><strong>Lifecycle，LiveData， ViewModel 的基本使用到此已经讲解完毕，想了解他们的实现原理的话可以阅读这两篇文章。</strong></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p><p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifec
      
    
    </summary>
    
    
      <category term="Android LiveData" scheme="https://gdutxiaoxu.gitee.io/tags/Android-LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Android lifecyle 源码解剖</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/01/12/Android%20lifecyle%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/01/12/Android lifecyle 源码解剖/</id>
    <published>2019-01-12T08:26:32.000Z</published>
    <updated>2021-04-18T01:46:45.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><p><strong>徐公码字，一位不羁的码农。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMC84LzE2ZGFhZTAwZDUyNmMxNTM?x-oss-process=image/format,png"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇博客，我们已经讲解了 lifecycle ，liveData， ViewModel 的使用，这一篇博客，让我们一起来看一下 lifecycle 的原理。</p><hr><h2 id="从自定义的-lifecycle-说起"><a href="#从自定义的-lifecycle-说起" class="headerlink" title="从自定义的 lifecycle 说起"></a>从自定义的 lifecycle 说起</h2><p>首先我们先来复习一下，如果要自定义 lifecycle，我们要这样做。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomLifecycleActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> <span class="title">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;CustomLifecycleActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_custom_lifecycle);</span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="built_in">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event = &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.RESUMED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.DESTROYED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle <span class="function"><span class="title">getLifecycle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>第一步:先实现  LifecycleOwner 接口，并返回 mLifecycleRegistry</li><li>第二步：在 Activity 生命周期变化的时候，调用   mLifecycleRegistry.markState() 方法标记相应的状态</li><li>如果想添加 observer，调用 addObserver 方法添加观察者，这样会在 activity 生命周期变化的时候，回调 observer 的 onchange 方法。</li></ol><p>我们先来看一下 getLifecycle() 方法， getLifecycle() 它返回的是一个 Lifecycle 的实例，sdk 中默认的实现类为 LifecycleRegistry。</p><p>接下来，我们一起来看一下它的 observer 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断是否是 DESTROYED，如果是将初始状态置为 DESTROYED，否则为 INITIALIZED</span><br><span class="line">    State initialState &#x3D; mState &#x3D;&#x3D; DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line"> &#x2F;&#x2F; ObserverWithState 包装</span><br><span class="line">    ObserverWithState statefulObserver &#x3D; new ObserverWithState(observer, initialState);</span><br><span class="line">&#x2F;&#x2F;  将 observer 作为key，在缓存的 mObserverMap 中查找是否存在</span><br><span class="line">    ObserverWithState previous &#x3D; mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F; 存在，直接返回回去，证明该 observer 已经添加过了。否则，证明还没有添加过该 observer</span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    LifecycleOwner lifecycleOwner &#x3D; mLifecycleOwner.get();</span><br><span class="line">    if (lifecycleOwner &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; it is null we should be destroyed. Fallback quickly</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里 mAddingObserverCounter 为 0 ，mHandlingEvent 为 false</span><br><span class="line">    boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">    State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        &#x2F;&#x2F; mState &#x2F; subling may have been changed recalculate</span><br><span class="line">        targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isReentrance) &#123;</span><br><span class="line">        &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 addObserver 方法中，它主要干这几件事情</p><ol><li>首先，先初始化状态， 判断当前 mState 是否是 DESTROYED，如果是将初始状态置为 DESTROYED，否则为 INITIALIZED，接着用 ObserverWithState 包装 observer 和 初始化状态 initialState</li><li> 将 observer 作为 key，在缓存的 mObserverMap 中查找是否存在，如果存在，证明该 observer 已经添加过，直接返回回去，不必再进行处理。</li><li> addObserver 方法中第 21 行 ， isReentrance 一般情况下为 false，什么情况 为 true，暂时未想到，</li></ol><p>接下来我们先来看 calculateTargetState 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private State calculateTargetState(LifecycleObserver observer) &#123;</span><br><span class="line">   &#x2F;&#x2F; 取出 mObserverMap 的上一个 entry，previous</span><br><span class="line">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous &#x3D; mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果不为空，获取它的状态</span><br><span class="line">    State siblingState &#x3D; previous !&#x3D; null ? previous.getValue().mState : null;</span><br><span class="line">&#x2F;&#x2F; 判断 mParentStates 是否为 null，不为 null，去最后的一个状态，否则，为 null</span><br><span class="line">    State parentState &#x3D; !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)</span><br><span class="line">            : null;</span><br><span class="line">    &#x2F;&#x2F; 取最小的状态</span><br><span class="line">    return min(min(mState, siblingState), parentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，取出 mObserverMap 中上一个的 entry，该 LifecycleRegistry 实例如果是第一次调用 addObserver 实例的话，那么是 null，否则是上一个 observer 的 entry</li><li>根据 previous 是否为 null，设置 siblingState 的值</li><li>判断 mParentStates 是否为 null，不为 null，取 mParentStates 最后一次的状态</li><li>取 mState, siblingState 最小的状态 a，再取  a 与 parentState 的状态 b</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">   </span><br><span class="line">    DESTROYED,</span><br><span class="line"></span><br><span class="line">    INITIALIZED,</span><br><span class="line"></span><br><span class="line">    CREATED,</span><br><span class="line"></span><br><span class="line">    STARTED,</span><br><span class="line"></span><br><span class="line">    RESUMED;</span><br><span class="line"></span><br><span class="line">    public boolean isAtLeast(@NonNull State state) &#123;</span><br><span class="line">        return compareTo(state) &gt;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>State 中，他们排序的顺序是 DESTROYED &lt; INITIALIZED &lt; CREATED &lt; STARTED &lt; RESUMED。</p><p>我们知道，我们在 activity 的 onCreate 方法中初始化 LifecycleRegistry，并标记它的状态为 CREATED。当我们第一次在 onCreate 方法调用 addObserver 的时候，在 calculateTargetState 方法中，若是首次调用 previous 为 null，则 siblingState，parentState 为 null， 而 mState 为 CREATED，所以最终的状态为 CREATED，即 State targetState = calculateTargetState(observer); 中 targetState 为 CREATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取最小的状态</span></span><br><span class="line"><span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br></pre></td></tr></table></figure><p>看完 calculateTargetState 方法，我们回过头再来看一下 addObserver 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">     &#x2F;&#x2F; 省略若干行</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里 mAddingObserverCounter 为 0 ，mHandlingEvent 为 false</span><br><span class="line">    boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">    State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        &#x2F;&#x2F; mState &#x2F; subling may have been changed recalculate</span><br><span class="line">        targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!isReentrance) &#123;</span><br><span class="line">        &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里 statefulObserver.mState 为 DESTROYED 或者 INITIALIZED，肯定比  CREATED 小。而 mObserverMap.contains(observer) 必定为 true，除非我们手动移除掉 mObserverMap。因而，会走进 while循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushParentState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    mParentStates.add(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>pushParentState(statefulObserver.mState);  很简单，只是将 statefulObserver 的状态添加到 mParentStates 集合中。</p><p>继续往下走，接着会调用  statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_START;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected state value &quot;</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upEvent 方法也很简单，只是返回它的下一个 event。这里因为他们的 state为 INITIALIZED，所以它会返回 ON_CREATE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected event value &quot;</span> + event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里 event 为 ON_CREATE，所以 newState 也为 CREATED。   mState = min(mState, newState); mState newState，两者状态相同，所以 mState 也为 CREATED。接着回调 mLifecycleObserver 的 onStateChanged 方法。所以，这里，会收到我们的 onCreate 事件，与我们的预想相符。</p><p><strong>但是我们并没有在 onStart，onResume, onPause , onStop 和 onDestroy 方法中调用 mLifecycleRegistry.handleLifecycleEvent 方法，它又是怎样促发 Observer 的 onStateChanged 方法的。这里先不揭晓，我们先来看一下 26.1.0 以后的 AppCompatActivity，待会你就明白了，会感叹 google 真的牛逼！</strong></p><hr><h2 id="从-26-1-0-以后-AppCompatActivity-的设计说起"><a href="#从-26-1-0-以后-AppCompatActivity-的设计说起" class="headerlink" title="从 26.1.0 以后 AppCompatActivity 的设计说起"></a>从 26.1.0 以后 AppCompatActivity 的设计说起</h2><p> 我们知道，在 26.1.0 以后，如果我们要使用 lifecycle，我们只需要调用以下的方法即可。</p><h3 id="SupportActivity"><a href="#SupportActivity" class="headerlink" title="SupportActivity"></a>SupportActivity</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟踪 getLifecycle() 方法，它会跳转到 SupportActivity 的 getLifecycle 方法 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span>, <span class="title">Component</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SupportActivity 中，它默认为我们初始化 mLifecycleRegistry，作为一个成员变量。接着，他在<br>onCreate 方法中调用了  ReportFragment.injectIfNeededIn(this); 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 injectIfNeededIn 方法中，它会判断我们是否已经添加 ReportFragment，没有的话，添加进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchCreate</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchStart</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> <span class="function"><span class="title">dispatchResume</span>(<span class="params">ActivityInitializationListener listener</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onActivityCreated</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onPause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>然后，它在 onCreat ，onStart， onResume， onPause， onStop， onDestroy 方法中分别调用 dispatch 方法进行分发生命周期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">dispatch</span>(<span class="params">Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 dispatch 方法中，会先判断 activity 是不是实现了 LifecycleRegistryOwner ，如果是，直接分发，不过不是，判断是否实现 LifecycleOwner，获取它的 lifecycle，调用它 的 handleLifecycleEvent 进行分发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span>, <span class="title">Component</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span></span><br></pre></td></tr></table></figure><p>而很明显，高版本的 SupportActivity 实现了 LifecycleOwner 接口，并写 LifecycleOwner.getLifecycle() 是 LifecycleRegistry </p><h3 id="普通的-Activity"><a href="#普通的-Activity" class="headerlink" title="普通的 Activity"></a>普通的 Activity</h3><p>对于 26.1.0 以后的版本，你会发现，对于普通的 Activity，如果你想要使用 lifecycle，你只需要实现<br>LifecycleOwner 接口即可。当生命周期变化的时候，它也可以回调 Observer 的 onStateChanged 方法。</p><p>回到我们前面的问题：</p><p><strong>我们并没有在 onStart，onResume, onPause , onStop 和 onDestroy 方法中调用 mLifecycleRegistry.handleLifecycleEvent 方法，它又是怎样促发 onStateChanged 方法的</strong></p><p><strong>我们猜想它也是通过 ReportFragment 实现的。</strong>但是在 Activity 的 onCreate 方法中，我们并没有发现它有添加 ReportFragment，我们在 As 全局搜一下，看哪些地方使用到 ReportFragment。如下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL2xhcmdlLzlmZTRhZmEwZ3kxZnpoenFuam5nMGoyMGt6MDVlZ2xyLmpwZw?x-oss-process=image/format,png"></p><p>从图中可以看到，有几个地方使用到他。我们先来看一下 LifecycleDispatcher</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> REPORT_FRAGMENT_TAG = <span class="string">&quot;android.arch.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> AtomicBoolean sInitialized = <span class="keyword">new</span> AtomicBoolean(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInitialized.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 在 init 方法中，监听全局 activity 的创建，从而来添加 fragment</span></span><br><span class="line">        ((Application) context.getApplicationContext())</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> DispatcherActivityCallback());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">&quot;WeakerAccess&quot;</span>)</span><br><span class="line">    @VisibleForTesting</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherActivityCallback</span> <span class="keyword">extends</span> <span class="title">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">        private final FragmentCallback mFragmentCallback;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">DispatcherActivityCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            mFragmentCallback = <span class="keyword">new</span> FragmentCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivityCreated</span>(<span class="params">Activity activity, Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                ((FragmentActivity) activity).getSupportFragmentManager()</span><br><span class="line">                        .registerFragmentLifecycleCallbacks(mFragmentCallback, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ReportFragment.injectIfNeededIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivityStopped</span>(<span class="params">Activity activity</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public <span class="keyword">void</span> <span class="function"><span class="title">onActivitySaveInstanceState</span>(<span class="params">Activity activity, Bundle outState</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略若干代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它 在 init 方法中，通过 context.getApplicationContext() .registerActivityLifecycleCallbacks 监听全局 activity 的创建，在 activity oncreate 的时候，调用 ReportFragment.injectIfNeededIn(activity) ，从而来添加 fragment，进而分发相应的事件。</p><p>那 LifecycleDispatcher 的 init 方法又是在哪里调用的呢？ 我们全局搜索一下 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean <span class="function"><span class="title">onCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到它是在 ProcessLifecycleOwnerInitializer 的 onCreate 方法中调用的。而 ProcessLifecycleOwnerInitializer 是一个 ContentProvider。我们知道 ContentProvider 一般是在 AndroidManifest 中生命的。</p><p>果然，在 extensions-1.1.1.aar 中，我们惊喜地发现，它在 Manifest 里面注册了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;android.arch.lifecycle.extensions&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-sdk android:minSdkVersion=<span class="string">&quot;14&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        &lt;provider</span><br><span class="line">            android:name=<span class="string">&quot;android.arch.lifecycle.ProcessLifecycleOwnerInitializer&quot;</span></span><br><span class="line">            android:authorities=<span class="string">&quot;$&#123;applicationId&#125;.lifecycle-trojan&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;false&quot;</span></span><br><span class="line">            android:multiprocess=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>而 ContentProvider 的 onCreate 方法优先于 Application 的 onCreate 执行，所以在 Application 之前我们就调用了  ProcessLifecycleOwnerInitializer init 方法，监听了 Activity 的创建，当 Actiivty 创建的时候，会尝试为 Activity 添加 ReportFragment。而 ReportFragment 会在 Activity 生命周期变化的时候帮助我们分发生命周期。</p><p>ContentProvider 的 onCreate 方法优先于 Application 的 onCreate 执行，可以查看这一篇博客 <a href="https://blog.csdn.net/long117long/article/details/66477562">Android系统中的Application和四大组件一些方法的启动顺序和一些坑</a></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ok，我们来梳理一下。</p><p><strong>对于 26.1.0 以后的 SupportActivity</strong></p><p>它在 Activity onCreate 的时候添加了 ReportFragment，这个 ReportFragment 相当于一个代理，它在 onActivityCreated 的时候  dispatch(Lifecycle.Event.ON_CREATE) 进行分发生命周期，onStart， onResume, onPause, onStop,  onDestroy 的时候也是如此。而 在  dispatch 中 它调用了 LifecycleRegistry handleLifecycleEvent 的方法。而 LifecycleRegistry 方法中经过一系列处理，它又调用了 observer 的 onStateChange 方法，去通知相应的 observer。</p><p><strong>对于普通的 Activity</strong></p><p>它利用了 ContentProvide 的特征，它是在 Application onCreate 之前初始化的，他在 ProcessLifecycleOwnerInitializer oncreate 的时候监听 Activity 的创建，在 Activity 创建的时候，判断是否已经添加过 ReportFragment，没有的话，添加进去。<em><strong>这是一个很巧妙的设计，隐式初始化了 lifecycle。</strong></em></p><p>用流程图表示如下：</p><p>该图片引用自  <a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374">Android 架构组件（一）——Lifecycle</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnppenp0OHVvdmoyMHlnMWthd240LmpwZw?x-oss-process=image/format,png"></p><h3 id="Lifecycle-设计借鉴"><a href="#Lifecycle-设计借鉴" class="headerlink" title="Lifecycle 设计借鉴"></a>Lifecycle 设计借鉴</h3><ol><li>利用 ProcessLifecycleOwnerInitializer contentProvider 来隐式加载</li></ol><p>想一下，如果 ProcessLifecycleOwnerInitializer 不利用 contentProvider 来隐式加载的话，对于 普通的 Activity，旧版本等，如果想使用 lifecycle，那必须在基类中，手动调用  ReportFragment.injectIfNeededIn(activity) 的方法。</p><ol start="2"><li>利用 fragment 来分发生命周期</li></ol><p>利用  fragment 来分发生命周期有两个优点</p><ul><li>将逻辑从 Activity 中剥离出来，减少耦合，方便复用</li><li>可以做到在 Activity onCreate 之后才回调 observer 的 CREATED Event 事件。如果是通过 Application registerActivityLifecycleCallbacks 方法来分发生命周期的话，因为 ActivityLifecycleCallbacks 的 onActivityCreated 是在 Activity oncreate 之前调用的。</li></ul><p>下一篇：<a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><strong>推荐阅读：</strong></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/81394050">java 代理模式详解</a><br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/51824769">观察者设计模式 Vs 事件委托（java）</a><br><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86498647">Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifec
      
    
    </summary>
    
    
      <category term="Android lifecycle" scheme="https://gdutxiaoxu.gitee.io/tags/Android-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Android lifecycle 使用详解</title>
    <link href="https://gdutxiaoxu.gitee.io/2019/01/11/Android%20lifecycle%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://gdutxiaoxu.gitee.io/2019/01/11/Android lifecycle 使用详解/</id>
    <published>2019-01-11T08:26:32.000Z</published>
    <updated>2021-04-18T01:46:49.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><p><img src="https://img-blog.csdnimg.cn/20210406234353804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://developer.android.com/topic/libraries/architecture/">Architecture Components   </a></p><p>lifecycle 是 2107 年 google 大会推出来的，它属于 architecture compoment 里面的一个组件，它可以干什么用呢？ 简单得来说，它可以用来检查 Activity 的生命周期，而不必强依赖  Activity。</p><hr><h2 id="为什么要引进-lifecycle"><a href="#为什么要引进-lifecycle" class="headerlink" title="为什么要引进 lifecycle"></a>为什么要引进 lifecycle</h2><p>举一下我们最常用的 MVP 例子，没引进 lifecycle 之前，我们需要在 Activity 或者 Fragment 销毁的时候，即 onDestroy 的时候手动调用 onDestroy 方法，这里会带来一些问题，每一次在 Activity 或者 Fragment 销毁的烧开后都要调用 presenter.destory() 方法，这样的代码枯燥，毫无意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPresenter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPresenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        presenter= <span class="keyword">new</span> MyPresenter ();</span><br><span class="line">        presenter.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        presenter.destory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以定义一些 IBasePresenter 的接口，在 BaseActivity 的时候调用 IBasePresenter 的 onDestroy 方法，这样也确实能做到。只不过稍微繁琐一点。</p><p>那如果是别的类的呢，比如 MediaCompoment，在 Activity 的时候，我们需要销毁一些资源，按照传统的方法，我们还是需要在 Activity onDestroy 的时候手动调用 onDestroy 方法。那有没有更好的方法呢?当然是有的，lifecycle 就可以解决这个问题。接下来，我们先来看一下 Lifycycle 的基本使用。</p><hr><h2 id="Lifycycle-的基本使用"><a href="#Lifycycle-的基本使用" class="headerlink" title="Lifycycle 的基本使用"></a>Lifycycle 的基本使用</h2><ol><li>引入相关的依赖包</li></ol><p>Lifecycle 已经是稳定版，它包含在 support library 26.1.0 及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModel and LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:viewmodel:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:livedata:1.1.0&quot;</span></span><br></pre></td></tr></table></figure><p>support library在26.1.0 之前，lifecycle 并没有集成进去，需要我们引入另外的包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.0.0-alpha4&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol><p>这里同样分为几种情况</p><ol><li>support library 26.1.0  之后，且继承 FragmentActivity，那么我们直接调用  getLifecycle().addObserver 方法即可，当 Activity 的生命周期变化的时候，将会回调 onStateChanged 的方法，状态分别是一一对应的</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">   </span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> support library 26.1.0 之后，不是继承 FragmentActivity，只是简单地继承 Actiivty</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleLifecycleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="title">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;SimpleLifecycleActivity&quot;</span>;</span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params">Bundle savedInstanceState</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_simple_lifecycle);</span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="built_in">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged: event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle <span class="function"><span class="title">getLifecycle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li> support library 26.1.0  之前</li></ol><p>（现在的 support library 基本都在 26.1.0 之后了，这个可以忽略）</p><p>第一步：实现 LifecycleOwner 接口，并返回响应的  Lifecycle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface LifecycleOwner &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return </span>The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @NonNull</span><br><span class="line">    Lifecycle getLifecycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：在 Activity 生命周期变化的时候，调用  mLifecycleRegistry.handleLifecycleEvent 方法，分发相应的生命周期。</p><p>第三步：调用 Lifecycle 的 addObserver 方法添加相应的 Observer。</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> GenericLifecycleObserver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onStateChanged:event =&quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.RESUMED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mRegistry.markState(Lifecycle.State.DESTROYED);</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们回过头来看一下我们上面提出的问题？</p><p>MediaCompoment 在 Activity ondestroy 的时候，我们需要销毁一些资源，用传统的方法，我们需要在 Activity onDestroy 的时候手动调用 onDestroy 方法。这样会存在一个问题，调用者必须知道比较清楚得知道 MediaCompoment 的设计，否则可能会忘记调用 onDestroy 的方法。</p><p>那有没有一种方法， 当 Activity 生命周期变化的时候，MediaCompoment 自身能够检测到 Activity 的 生命周期变化，从而做相应的处理。</p><p>答案当然是有的，使用 lifycycle。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MediaCompoment</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> final <span class="built_in">String</span> TAG = <span class="string">&quot;MediaCompoment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    private final LifecycleOwner mLifecycleOwner;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">MediaCompoment</span>(<span class="params">LifecycleOwner lifecycleOwner</span>)</span> &#123;</span><br><span class="line">        mLifecycleOwner = lifecycleOwner;</span><br><span class="line">        mLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> <span class="function"><span class="title">GenericLifecycleObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> <span class="function"><span class="title">onStateChanged</span>(<span class="params">LifecycleOwner source, final Lifecycle.Event event</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">                    onCreate();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_START) &#123;</span><br><span class="line">                    onStart();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_RESUME) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_PAUSE) &#123;</span><br><span class="line">                    onPause();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_STOP) &#123;</span><br><span class="line">                    onStop();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    onDestroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onResume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onPause</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onStop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>lifycycle 其实是用观察者模式实现的，当 Activity 生命周期变化的时候，通知相应的 Observers 即观察者。</li><li>使用 lifecycle，我们可以将释放资源的动作内聚在自身，减少与调用者之间的耦合。</li></ol><p>下一篇博客：<a href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p><p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifec
      
    
    </summary>
    
    
      <category term="Android lifecycle" scheme="https://gdutxiaoxu.gitee.io/tags/Android-lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Android Hook 机制之简单实战</title>
    <link href="https://gdutxiaoxu.gitee.io/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/"/>
    <id>https://gdutxiaoxu.gitee.io/2018/05/12/Android Hook 机制之简单实战/</id>
    <published>2018-05-12T08:26:32.000Z</published>
    <updated>2021-04-18T01:57:33.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-Hook"><a href="#什么是-Hook" class="headerlink" title="什么是 Hook"></a>什么是 Hook</h3><p><strong>Hook 又叫“钩子”</strong>，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入。</p><p>这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p><h3 id="Hook-分类"><a href="#Hook-分类" class="headerlink" title="Hook 分类"></a>Hook 分类</h3><p>1.根据Android开发模式，Native模式（C/C++）和Java模式（Java）区分，在Android平台上 </p><ul><li>Java层级的Hook； </li><li>Native层级的Hook； </li></ul><p>2.根 Hook 对象与 Hook 后处理事件方式不同，Hook还分为： </p><ul><li>消息Hook； </li><li>API Hook； </li></ul><p>3.针对Hook的不同进程上来说，还可以分为： </p><ul><li>全局Hook； </li><li>单个进程Hook； </li></ul><h3 id="常见-Hook-框架"><a href="#常见-Hook-框架" class="headerlink" title="常见 Hook 框架"></a>常见 Hook 框架</h3><p>在Android开发中，有以下常见的一些Hook框架：</p><ol><li><strong>Xposed</strong></li></ol><p>通过替换 /system/bin/app_process 程序控制 Zygote 进程，使得 app_process 在启动过程中会加载 XposedBridge.jar 这个 Jar 包，从而完成对 Zygote 进程及其创建的 Dalvik 虚拟机的劫持。 </p><p>Xposed 在开机的时候完成对所有的 Hook Function 的劫持，在原 Function 执行的前后加上自定义代码。</p><ol start="2"><li><strong>Cydia Substrate</strong></li></ol><p>Cydia Substrate 框架为苹果用户提供了越狱相关的服务框架，当然也推出了 Android 版 。Cydia Substrate 是一个代码修改平台，它可以修改任何进程的代码。</p><p>不管是用 Java 还是 C/C++（native代码）编写的，而 Xposed 只支持 Hook app_process 中的 Java 函数。</p><ol start="3"><li>Legend</li></ol><p>Legend 是 Android 免 Root 环境下的一个 Apk Hook 框架，该框架代码设计简洁，通用性高，适合逆向工程时一些 Hook 场景。大部分的功能都放到了 Java 层，这样的兼容性就非常好。 </p><p>原理是这样的，直接构造出新旧方法对应的虚拟机数据结构，然后替换信息写到内存中即可。</p><h3 id="Hook-必须掌握的知识"><a href="#Hook-必须掌握的知识" class="headerlink" title="Hook 必须掌握的知识"></a>Hook 必须掌握的知识</h3><ul><li>反射 </li></ul><p>如果你对反射还不是很熟悉的话，建议你先复习一下 java 反射的相关知识。有兴趣的，可以看一下我的这一篇博客 <a href="https://blog.csdn.net/gdutxiaoxu/article/details/68947735">Java 反射机制详解</a></p><ul><li>java 的动态代理</li></ul><p>动态代理是指在运行时动态生成代理类，不需要我们像静态代理那个去手动写一个个的代理类。在 java 中，我们可以使用 InvocationHandler 实现动态代理，有兴趣的，可以查看我的这一篇博客 <a href="https://blog.csdn.net/gdutxiaoxu/article/details/81394050">java  代理模式详解</a></p><p>本文的主要内容是讲解单个进程的 Hook，以及怎样 Hook。有兴趣的可以关注我的微信公众号：<strong>程序员徐公</strong><br><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="Hook-使用实例"><a href="#Hook-使用实例" class="headerlink" title="Hook 使用实例"></a>Hook 使用实例</h2><h3 id="Hook-选择的关键点"><a href="#Hook-选择的关键点" class="headerlink" title="Hook 选择的关键点"></a>Hook 选择的关键点</h3><ul><li><p>Hook 的选择点：尽量静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。</p></li><li><p>Hook 过程：</p><ul><li>寻找 Hook 点，原则是尽量静态变量或者单例对象，尽量 Hook public 的对象和方法。</li><li>选择合适的代理方式，如果是接口可以用动态代理。</li><li>偷梁换柱——用代理对象替换原始对象。</li></ul></li><li><p>Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。</p></li></ul><h3 id="简单案例一-使用-Hook-修改-View-OnClickListener-事件"><a href="#简单案例一-使用-Hook-修改-View-OnClickListener-事件" class="headerlink" title="简单案例一: 使用 Hook 修改 View.OnClickListener 事件"></a>简单案例一: 使用 Hook 修改 View.OnClickListener 事件</h3><p>首先，我们先分析 View.setOnClickListener 源码，找出合适的 Hook 点。可以看到 OnClickListener 对象被保存在了一个叫做 ListenerInfo 的内部类里，其中 mListenerInfo 是 View 的成员变量。ListeneInfo 里面保存了 View 的各种监听事件。因此，我们可以想办法 hook ListenerInfo 的 mOnClickListener 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">    if (!isClickable()) &#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener &#x3D; l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class ListenerInfo &#123;</span><br><span class="line"></span><br><span class="line">     ---</span><br><span class="line"></span><br><span class="line">    ListenerInfo getListenerInfo() &#123;</span><br><span class="line">        if (mListenerInfo !&#x3D; null) &#123;</span><br><span class="line">            return mListenerInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        mListenerInfo &#x3D; new ListenerInfo();</span><br><span class="line">        return mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们一起来看一下怎样 Hook View.OnClickListener 事件？</p><p>大概分为三步：</p><ul><li>第一步：获取 ListenerInfo 对象</li></ul><p>从 View 的源代码，我们可以知道我们可以通过 getListenerInfo 方法获取，于是，我们利用反射得到 ListenerInfo 对象</p><ul><li>第二步：获取原始的 OnClickListener事件方法</li></ul><p>从上面的分析，我们知道 OnClickListener 事件被保存在 ListenerInfo 里面，同理我们利用反射获取</p><ul><li>第三步：偷梁换柱，用 Hook代理类 替换原始的 OnClickListener</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void hookOnClickListener(View view) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步：反射得到 ListenerInfo 对象</span><br><span class="line">    Method getListenerInfo &#x3D; View.class.getDeclaredMethod(&quot;getListenerInfo&quot;);</span><br><span class="line">    getListenerInfo.setAccessible(true);</span><br><span class="line">    Object listenerInfo &#x3D; getListenerInfo.invoke(view);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到原始的 OnClickListener事件方法</span><br><span class="line">    Class&lt;?&gt; listenerInfoClz &#x3D; Class.forName(&quot;android.view.View$ListenerInfo&quot;);</span><br><span class="line">    Field mOnClickListener &#x3D; listenerInfoClz.getDeclaredField(&quot;mOnClickListener&quot;);</span><br><span class="line">    mOnClickListener.setAccessible(true);</span><br><span class="line">    View.OnClickListener originOnClickListener &#x3D; (View.OnClickListener) mOnClickListener.get(listenerInfo);</span><br><span class="line">    &#x2F;&#x2F; 第三步：用 Hook代理类 替换原始的 OnClickListener</span><br><span class="line">    View.OnClickListener hookedOnClickListener &#x3D; new HookedClickListenerProxy(originOnClickListener);</span><br><span class="line">    mOnClickListener.set(listenerInfo, hookedOnClickListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HookedClickListenerProxy implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private View.OnClickListener origin;</span><br><span class="line"></span><br><span class="line">    public HookedClickListenerProxy(View.OnClickListener origin) &#123;</span><br><span class="line">        this.origin &#x3D; origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Toast.makeText(v.getContext(), &quot;Hook Click Listener&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        if (origin !&#x3D; null) &#123;</span><br><span class="line">            origin.onClick(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下代码，将会看到当我们点击该按钮的时候，会弹出 toast “Hook Click Listener”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mBtn1 &#x3D; (Button) findViewById(R.id.btn_1);</span><br><span class="line">mBtn1.setOnClickListener(this);</span><br><span class="line">try &#123;</span><br><span class="line">    HookHelper.hookOnClickListener(mBtn1);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单案例二：-HooK-Notification"><a href="#简单案例二：-HooK-Notification" class="headerlink" title="简单案例二： HooK Notification"></a>简单案例二： HooK Notification</h3><p>发送消息到通知栏的核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">notificationManager.notify(id, builder.build());</span><br></pre></td></tr></table></figure><p>跟踪 notify 方法发现最终会调用到 notifyAsUser 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void notify(String tag, int id, Notification notification)</span><br><span class="line">&#123;</span><br><span class="line">    notifyAsUser(tag, id, notification, new UserHandle(UserHandle.myUserId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在 notifyAsUser 方法中，我们惊喜地发现 service 是一个单例，因此，我们可以想方法 hook 住这个 service，而 notifyAsUser 最终会调用到 service 的 enqueueNotificationWithTag 方法。因此 hook 住 service 的 enqueueNotificationWithTag 方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    INotificationManager service &#x3D; getService();</span><br><span class="line">    String pkg &#x3D; mContext.getPackageName();</span><br><span class="line">    &#x2F;&#x2F; Fix the notification as best we can.</span><br><span class="line">    Notification.addFieldsFromContext(mContext, notification);</span><br><span class="line">    if (notification.sound !&#x3D; null) &#123;</span><br><span class="line">        notification.sound &#x3D; notification.sound.getCanonicalUri();</span><br><span class="line">        if (StrictMode.vmFileUriExposureEnabled()) &#123;</span><br><span class="line">            notification.sound.checkFileUriExposed(&quot;Notification.sound&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fixLegacySmallIcon(notification, pkg);</span><br><span class="line">    if (mContext.getApplicationInfo().targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">        if (notification.getSmallIcon() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid notification (no valid small icon): &quot;</span><br><span class="line">                    + notification);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (localLOGV) Log.v(TAG, pkg + &quot;: notify(&quot; + id + &quot;, &quot; + notification + &quot;)&quot;);</span><br><span class="line">    final Notification copy &#x3D; Builder.maybeCloneStrippedForDelivery(notification);</span><br><span class="line">    try &#123;</span><br><span class="line">        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id,</span><br><span class="line">                copy, user.getIdentifier());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static INotificationManager sService;</span><br><span class="line"></span><br><span class="line">static public INotificationManager getService()</span><br><span class="line">&#123;</span><br><span class="line">    if (sService !&#x3D; null) &#123;</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b &#x3D; ServiceManager.getService(&quot;notification&quot;);</span><br><span class="line">    sService &#x3D; INotificationManager.Stub.asInterface(b);</span><br><span class="line">    return sService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上，要 Hook  Notification，大概需要三步：</p><ul><li>第一步：得到 NotificationManager 的 sService</li><li>第二步：因为 sService 是接口，所以我们可以使用动态代理，获取动态代理对象</li><li>第三步：偷梁换柱，使用动态代理对象 proxyNotiMng 替换系统的 sService</li></ul><p>于是，我们可以写出如下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void hookNotificationManager(final Context context) throws Exception &#123;</span><br><span class="line">    NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">    Method getService &#x3D; NotificationManager.class.getDeclaredMethod(&quot;getService&quot;);</span><br><span class="line">    getService.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 sService</span><br><span class="line">    final Object sOriginService &#x3D; getService.invoke(notificationManager);</span><br><span class="line"></span><br><span class="line">    Class iNotiMngClz &#x3D; Class.forName(&quot;android.app.INotificationManager&quot;);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到我们的动态代理对象</span><br><span class="line">    Object proxyNotiMng &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;iNotiMngClz&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            Log.d(TAG, &quot;invoke: name&#x3D;&quot; + name);</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Toast.makeText(context.getApplicationContext(), &quot;检测到有人发通知了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(sOriginService, args);</span><br><span class="line">            &#x2F;&#x2F; 拦截通知，什么也不做</span><br><span class="line">            &#x2F;&#x2F;                    return null;</span><br><span class="line">            &#x2F;&#x2F; 或者是根据通知的 Tag 和 ID 进行筛选</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 sService</span><br><span class="line">    Field sServiceField &#x3D; NotificationManager.class.getDeclaredField(&quot;sService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(notificationManager, proxyNotiMng);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Hook-使用进阶"><a href="#Hook-使用进阶" class="headerlink" title="Hook 使用进阶"></a>Hook 使用进阶</h2><h3 id="Hook-ClipboardManager"><a href="#Hook-ClipboardManager" class="headerlink" title="Hook ClipboardManager"></a>Hook ClipboardManager</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><p>从上面的 hook NotificationManager 例子中，我们可以得知 NotificationManager 中有一个静态变量 sService，这个变量是远端的 service。因此，我们尝试查找 ClipboardManager 中是不是也存在相同的类似静态变量。</p><p>查看它的源码发现它存在 mService 变量，该变量是在 ClipboardManager 构造函数中初始化的，而 ClipboardManager 的构造方法用 @hide 标记，表明该方法对调用者不可见。</p><p>而我们知道 ClipboardManager，NotificationManager 其实这些都是单例的，即系统只会创建一次。因此我们也可以认为<br>ClipboardManager 的 mService 是单例的。因此 mService 应该是可以考虑 hook 的一个点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ClipboardManager extends android.text.ClipboardManager &#123;</span><br><span class="line">    private final Context mContext;</span><br><span class="line">    private final IClipboard mService;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#123;@hide&#125; *&#x2F;</span><br><span class="line">    public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mService &#x3D; IClipboard.Stub.asInterface(</span><br><span class="line">                ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们再来一个看一下 ClipboardManager 的相关方法 setPrimaryClip ， getPrimaryClip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void setPrimaryClip(ClipData clip) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (clip !&#x3D; null) &#123;</span><br><span class="line">            clip.prepareToLeaveProcess(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.setPrimaryClip(clip, mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current primary clip on the clipboard.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ClipData getPrimaryClip() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return mService.getPrimaryClip(mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这些方法最终都会调用到 mService 的相关方法。因此，ClipboardManager 的 mService 确实是一个可以 hook 的一个点。</p><p><strong>hook ClipboardManager.mService  的实现</strong></p><p>大概需要三个步骤</p><ul><li>第一步：得到 ClipboardManager 的 mService</li><li>第二步：初始化动态代理对象</li><li>第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void hookClipboardService(final Context context) throws Exception &#123;</span><br><span class="line">    ClipboardManager clipboardManager &#x3D; (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line">    Field mServiceFiled &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    mServiceFiled.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 mService</span><br><span class="line">    final Object mService &#x3D; mServiceFiled.get(clipboardManager);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二步：初始化动态代理对象</span><br><span class="line">    Class aClass &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">    Object proxyInstance &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;aClass&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;setPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Object arg &#x3D; args[0];</span><br><span class="line">                if (arg instanceof ClipData) &#123;</span><br><span class="line">                    ClipData clipData &#x3D; (ClipData) arg;</span><br><span class="line">                    int itemCount &#x3D; clipData.getItemCount();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; itemCount; i++) &#123;</span><br><span class="line">                        ClipData.Item item &#x3D; clipData.getItemAt(i);</span><br><span class="line">                        Log.i(TAG, &quot;invoke: item&#x3D;&quot; + item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人设置粘贴板内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; else if (&quot;getPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人要获取粘贴板的内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(mService, args);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</span><br><span class="line">    Field sServiceField &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(clipboardManager, proxyInstance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnR4ajVleWl6aWcyMGM3MG9wcTdyLmdpZg"></p><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>对 Android 源码有基本了解的人都知道，Android 中的各种 Manager 都是通过 ServiceManager 获取的。因此，我们可以通过 ServiceManager hook 所有系统 Manager，ClipboardManager 当然也不例外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老套路</p><ul><li>第一步：通过反射获取剪切板服务的远程Binder对象，这里我们可以通过 ServiceManager getService 方法获得</li><li>第二步：创建我们的动态代理对象，动态代理原来的Binder对象</li><li>第三步：偷梁换柱，把我们的动态代理对象设置进去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void hookClipboardService() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取剪切板服务的远程Binder对象</span><br><span class="line">    Class serviceManager &#x3D; Class.forName(&quot;android.os.ServiceManager&quot;);</span><br><span class="line">    Method getServiceMethod &#x3D; serviceManager.getMethod(&quot;getService&quot;, String.class);</span><br><span class="line">    IBinder remoteBinder &#x3D; (IBinder) getServiceMethod.invoke(null, Context.CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新建一个我们需要的Binder，动态代理原来的Binder对象</span><br><span class="line">    IBinder hookBinder &#x3D; (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">            new Class[]&#123;IBinder.class&#125;, new ClipboardHookRemoteBinderHandler(remoteBinder));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取ServiceManger存储Binder对象的缓存集合,把我们新建的代理Binder放进缓存</span><br><span class="line">    Field sCacheField &#x3D; serviceManager.getDeclaredField(&quot;sCache&quot;);</span><br><span class="line">    sCacheField.setAccessible(true);</span><br><span class="line">    Map&lt;String, IBinder&gt; sCache &#x3D; (Map&lt;String, IBinder&gt;) sCacheField.get(null);</span><br><span class="line">    sCache.put(Context.CLIPBOARD_SERVICE, hookBinder);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ClipboardHookRemoteBinderHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private IBinder remoteBinder;</span><br><span class="line">    private Class iInterface;</span><br><span class="line">    private Class stubClass;</span><br><span class="line"></span><br><span class="line">    public ClipboardHookRemoteBinderHandler(IBinder remoteBinder) &#123;</span><br><span class="line">        this.remoteBinder &#x3D; remoteBinder;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.iInterface &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">            this.stubClass &#x3D; Class.forName(&quot;android.content.IClipboard$Stub&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Log.d(&quot;RemoteBinderHandler&quot;, method.getName() + &quot;() is invoked&quot;);</span><br><span class="line">        if (&quot;queryLocalInterface&quot;.equals(method.getName())) &#123;</span><br><span class="line">            &#x2F;&#x2F;这里不能拦截具体的服务的方法，因为这是一个远程的Binder，还没有转化为本地Binder对象</span><br><span class="line">            &#x2F;&#x2F;所以先拦截我们所知的queryLocalInterface方法，返回一个本地Binder对象的代理</span><br><span class="line">            return Proxy.newProxyInstance(remoteBinder.getClass().getClassLoader(),</span><br><span class="line">                    new Class[]&#123;this.iInterface&#125;,</span><br><span class="line">                    new ClipboardHookLocalBinderHandler(remoteBinder, stubClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return method.invoke(remoteBinder, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook-Activity"><a href="#Hook-Activity" class="headerlink" title="Hook Activity"></a>Hook Activity</h3><p>关于怎样 hook activity，以及怎样启动没有在 AndroidManifet 注册的 activity，可以查看我的这一篇博客。</p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/81459910">Android Hook Activity 的几种姿势</a></p><p><strong>源码下载地址</strong>： <a href="https://github.com/gdutxiaoxu/HookDemo">HookDemo</a></p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p><p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;什么是-Hook&quot;&gt;&lt;a href=&quot;#什么是-Hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hook&quot;
      
    
    </summary>
    
    
      <category term="hook" scheme="https://gdutxiaoxu.gitee.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>自定义-Behavior-仿新浪微博发现页的实现</title>
    <link href="https://gdutxiaoxu.gitee.io/2017/05/12/%E8%87%AA%E5%AE%9A%E4%B9%89-Behavior-%E4%BB%BF%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%8F%91%E7%8E%B0%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gdutxiaoxu.gitee.io/2017/05/12/自定义-Behavior-仿新浪微博发现页的实现/</id>
    <published>2017-05-12T05:03:58.000Z</published>
    <updated>2021-05-08T06:57:51.298Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/52858598">使用CoordinatorLayout打造各种炫酷的效果</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53453958">自定义Behavior —— 仿知乎，FloatActionButton隐藏与展示</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71553411">NestedScrolling 机制深入解析</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71616547"> 一步步带你读懂 CoordinatorLayout 源码</a></p><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/71732642">自定义 Behavior -仿新浪微博发现页的实现</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/52939127">ViewPager，ScrollView 嵌套ViewPager滑动冲突解决</a></p><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/88383135">自定义 behavior - 完美仿 QQ 浏览器首页，美团商家详情页</a></p><p>  <strong>重磅消息：小编我开始运营自己的公众号了， 目前从事于 Android 开发，除了分享 Android开发相关知识，还有职场心得，面试经验，学习心得，人生感悟等等。希望通过该公众号，让你看到程序猿不一样的一面，我们不只会敲代码，我们还会。。。。。。</strong></p><p>  <strong>有兴趣的话可以关注我的公众号 徐公码字（stormjun94），或者拿起你的手机扫一扫，期待你的参与</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmUyMjk5MGU?x-oss-process=image/format,png" alt="Android 技术人"></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>我们先来看一下新浪微博发现页的效果：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmYzMzFjY2E?x-oss-process=image/format,png"></p><p>接下来我们在来看一下我们仿照新浪微博实现的效果</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YmY0NTFhNDg?x-oss-process=image/format,png" alt="仿新浪微博效果图"></p><h2 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h2><p>我们这里先定义两种状态，open 和  close 状态。</p><ul><li>open 状态指 Tab+ViewPager 还没有滑动到顶部的时候，header 还 没有被完全移除屏幕的时候</li><li>close 状态指 Tab+ViewPager 滑动到顶部的时候，Header 被移除屏幕的时候 </li></ul><p>从效果图，我们可以看到 在 open 状态下，我们向上滑动 ViewPager 里面的 RecyclerView  的 时候，<strong>RecyclerView 并不会向上移动（RecyclerView 的滑动事件交给 外部的容器处理，被被全部消费掉了），而是整个布局（指 Header + Tab +ViewPager）会向上偏移</strong> 。当 Tab 滑动到顶部的时候，我们向上滑动 ViewPager 里面的 RecyclerView 的时候，<strong>RecyclerView  可以正常向上滑动，即此时外部容器没有拦截滑动事件</strong>。</p><p>同时我们可以看到在 open 状态的时候，我们是不支持下拉刷新的，这个比较容易实现，监听页面的状态，如果是 open 状态，我们设置 SwipeRefreshLayout setEnabled 为 false，这样不会 拦截事件，在页面 close 的时候，设置 SwipeRefreshLayout setEnabled 为 TRUE，这样就可以支持下拉刷新了。</p><p>基于上面的分析，我们这里可以把整个效果划分为两个部分，第一部分为 Header，第二部分为 Tab+ViewPager。<strong>下文统一把第一部分称为 Header，第二部分称为 Content 。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzA5ZDJjZWU?x-oss-process=image/format,png"></p><p>需要实现的效果为：在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView  的 滑动事件。</p><p>在上一篇博客 <a href="http://blog.csdn.net/gdutxiaoxu/article/details/71616547">一步步带你读懂 CoordinatorLayout 源码</a> 中，我们有提到在 CoordinatorLayout中，我们可以通过 给子 View 自定义 Behavior 来处理事件。它是一个容器，实现了 NestedScrollingParent 接口。它并不会直接处理事件，而是会尽可能地交给子 View 的 Behavior 进行处理。因此，为了减少依赖，<strong>我们把这两部分的关系定义为 Content 依赖于  Header。Header 移动的时候，Content 跟着 移动。所以，我们在处理滑动事件的时候，只需要处理好 Header 部分的 Behavior 就oK了，Content 部分的 Behavior 不需要处理滑动事件，只需依赖于  Header ，跟着做相应的移动即可。</strong></p><hr><h2 id="Header-部分的实现"><a href="#Header-部分的实现" class="headerlink" title="Header 部分的实现"></a>Header 部分的实现</h2><p>Header 部分实现的两个关键点在于</p><ol><li>在页面状态为 open 的时候，ViewPager 里面的 RecyclerView 向上滑动的时候，消费其滑动事件，并整体向上移动。在页面状态为 close 的时候，不消耗 RecyclerView  的 滑动事件</li><li>在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。</li></ol><h3 id="第一个关键点的实现"><a href="#第一个关键点的实现" class="headerlink" title="第一个关键点的实现"></a>第一个关键点的实现</h3><p>这里区分页面状态是 open 还是  close 状态是通过 Header 是否移除屏幕来区分的，即 child.getTranslationY() == getHeaderOffsetRange() 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private boolean isClosed(View child) &#123;</span><br><span class="line">    boolean isClosed &#x3D; child.getTranslationY() &#x3D;&#x3D; getHeaderOffsetRange();</span><br><span class="line">    return isClosed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<a href="http://blog.csdn.net/gdutxiaoxu/article/details/71553411">NestedScrolling 机制深入解析</a>博客中，我们对 NestedScrolling 机制做了如下的总结。</p><ul><li>在 Action_Down 的时候，Scrolling child 会调用 startNestedScroll 方法，通过 childHelper 回调 Scrolling Parent 的 startNestedScroll 方法。 </li><li>在 Action_move 的时候，Scrolling Child 要开始滑动的时候，会调用dispatchNestedPreScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否要先于 Child 进行 滑动，若需要的话，会调用 Parent 的 onNestedPreScroll 方法，协同 Child 一起进行滑动</li><li>当 ScrollingChild 滑动完成的时候，会调用 dispatchNestedScroll 方法，通过 ChildHelper 询问 Scrolling Parent 是否需要进行滑动，需要的话，会 调用 Parent 的 onNestedScroll 方法</li><li>在 Action_down,Action_move 的时候，会调用 Scrolling Child 的stopNestedScroll ，通过 ChildHelper 询问 Scrolling parent 的 stopNestedScroll 方法。</li><li>如果需要处理 Fling 动作，我们可以通过 VelocityTrackerCompat 获得相应的速度，并在 Action_up 的时候，调用 dispatchNestedPreFling 方法，通过 ChildHelper 询问 Parent 是否需要先于 child 进行 Fling 动作<br>在 Child 处理完 Fling 动作时候，如果 Scrolling Parent 还需要处理 Fling 动作，我们可以调用 dispatchNestedFling 方法，通过 ChildHelper ，调用 Parent 的 onNestedFling 方法</li></ul><p><strong>而 RecyclerView  也是 Scrolling Child （实现了 NestedScrollingChild 接口），RecyclerView 在开始滑动的 时候会先调用  CoordinatorLayout 的 startNestedScroll 方法，而 CoordinatorLayout 会 调用子 View  的 Behavior 的  startNestedScroll 方法。并且只有 boolean startNestedScroll   返回  TRUE 的 时候，才会调用接下里 Behavior 中的 onNestedPreScroll 和 onNestedScroll 方法。</strong></p><p>所以，我们在 WeiboHeaderPagerBehavior 的 onStartNestedScroll 方法可以这样写，可以确保 只拦截垂直方向上的滚动事件，且当前状态是打开的并且还可以继续向上收缩的时候还会拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View</span><br><span class="line">        directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">    if (BuildConfig.DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes&#x3D;&quot; + nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean canScroll &#x3D; canScroll(child, 0);</span><br><span class="line">    &#x2F;&#x2F;拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩</span><br><span class="line">    return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0 &amp;&amp; canScroll &amp;&amp;</span><br><span class="line">            !isClosed(child);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拦截事件之后，我们需要在 RecyclerView 滑动之前消耗事件，并且移动 Header，让其向上偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                              int dx, int dy, int[] consumed) &#123;</span><br><span class="line">    super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">    &#x2F;&#x2F;dy&gt;0 scroll up;dy&lt;0,scroll down</span><br><span class="line">    Log.i(TAG, &quot;onNestedPreScroll: dy&#x3D;&quot; + dy);</span><br><span class="line">    float halfOfDis &#x3D; dy;</span><br><span class="line">    &#x2F;&#x2F;    不能滑动了，直接给 Header 设置 终值，防止出错</span><br><span class="line">    if (!canScroll(child, halfOfDis)) &#123;</span><br><span class="line">        child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.setTranslationY(child.getTranslationY() - halfOfDis);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;consumed all scroll behavior after we started Nested Scrolling</span><br><span class="line">    consumed[1] &#x3D; dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，我们也需要处理 Fling 事件，在页面没有完全关闭的 时候，消费所有 fling 事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                float velocityX, float velocityY) &#123;</span><br><span class="line">    &#x2F;&#x2F; consumed the flinging behavior until Closed</span><br><span class="line">    return !isClosed(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于滑动到顶部的动画，我是通过 mOverScroller + FlingRunnable 来实现的 。完整代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">public class WeiboHeaderPagerBehavior extends ViewOffsetBehavior &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;UcNewsHeaderPager&quot;;</span><br><span class="line">    public static final int STATE_OPENED &#x3D; 0;</span><br><span class="line">    public static final int STATE_CLOSED &#x3D; 1;</span><br><span class="line">    public static final int DURATION_SHORT &#x3D; 300;</span><br><span class="line">    public static final int DURATION_LONG &#x3D; 600;</span><br><span class="line"></span><br><span class="line">    private int mCurState &#x3D; STATE_OPENED;</span><br><span class="line">    private OnPagerStateListener mPagerStateListener;</span><br><span class="line"></span><br><span class="line">    private OverScroller mOverScroller;</span><br><span class="line"></span><br><span class="line">    private WeakReference&lt;CoordinatorLayout&gt; mParent;</span><br><span class="line">    private WeakReference&lt;View&gt; mChild;</span><br><span class="line"></span><br><span class="line">    public void setPagerStateListener(OnPagerStateListener pagerStateListener) &#123;</span><br><span class="line">        mPagerStateListener &#x3D; pagerStateListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboHeaderPagerBehavior() &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboHeaderPagerBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        mOverScroller &#x3D; new OverScroller(BaseAPP.getAppContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void layoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123;</span><br><span class="line">        super.layoutChild(parent, child, layoutDirection);</span><br><span class="line">        mParent &#x3D; new WeakReference&lt;CoordinatorLayout&gt;(parent);</span><br><span class="line">        mChild &#x3D; new WeakReference&lt;View&gt;(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View</span><br><span class="line">            directTargetChild, View target, int nestedScrollAxes) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onStartNestedScroll: nestedScrollAxes&#x3D;&quot; + nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean canScroll &#x3D; canScroll(child, 0);</span><br><span class="line">        &#x2F;&#x2F;拦截垂直方向上的滚动事件且当前状态是打开的并且还可以继续向上收缩</span><br><span class="line">        return (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) !&#x3D; 0 &amp;&amp; canScroll &amp;&amp;</span><br><span class="line">                !isClosed(child);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                    float velocityX, float velocityY) &#123;</span><br><span class="line">        &#x2F;&#x2F; consumed the flinging behavior until Closed</span><br><span class="line"></span><br><span class="line">        boolean coumsed &#x3D; !isClosed(child);</span><br><span class="line">        Log.i(TAG, &quot;onNestedPreFling: coumsed&#x3D;&quot; +coumsed);</span><br><span class="line">        return coumsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                 float velocityX, float velocityY, boolean consumed) &#123;</span><br><span class="line">        Log.i(TAG, &quot;onNestedFling: velocityY&#x3D;&quot; +velocityY);</span><br><span class="line">        return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY,</span><br><span class="line">                consumed);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isClosed(View child) &#123;</span><br><span class="line">        boolean isClosed &#x3D; child.getTranslationY() &#x3D;&#x3D; getHeaderOffsetRange();</span><br><span class="line">        return isClosed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isClosed() &#123;</span><br><span class="line">        return mCurState &#x3D;&#x3D; STATE_CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void changeState(int newState) &#123;</span><br><span class="line">        if (mCurState !&#x3D; newState) &#123;</span><br><span class="line">            mCurState &#x3D; newState;</span><br><span class="line">            if (mCurState &#x3D;&#x3D; STATE_OPENED) &#123;</span><br><span class="line">                if (mPagerStateListener !&#x3D; null) &#123;</span><br><span class="line">                    mPagerStateListener.onPagerOpened();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mPagerStateListener !&#x3D; null) &#123;</span><br><span class="line">                    mPagerStateListener.onPagerClosed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 表示 Header TransLationY 的值是否达到我们指定的阀值， headerOffsetRange，到达了，返回 false，</span><br><span class="line">    &#x2F;&#x2F; 否则，返回 true。注意 TransLationY 是负数。</span><br><span class="line">    private boolean canScroll(View child, float pendingDy) &#123;</span><br><span class="line">        int pendingTranslationY &#x3D; (int) (child.getTranslationY() - pendingDy);</span><br><span class="line">        int headerOffsetRange &#x3D; getHeaderOffsetRange();</span><br><span class="line">        if (pendingTranslationY &gt;&#x3D; headerOffsetRange &amp;&amp; pendingTranslationY &lt;&#x3D; 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(CoordinatorLayout parent, final View child, MotionEvent</span><br><span class="line">            ev) &#123;</span><br><span class="line"></span><br><span class="line">        boolean closed &#x3D; isClosed();</span><br><span class="line">        Log.i(TAG, &quot;onInterceptTouchEvent: closed&#x3D;&quot; + closed);</span><br><span class="line">        if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_UP &amp;&amp; !closed) &#123;</span><br><span class="line">            handleActionUp(parent,child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onInterceptTouchEvent(parent, child, ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target,</span><br><span class="line">                                  int dx, int dy, int[] consumed) &#123;</span><br><span class="line">        super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">        &#x2F;&#x2F;dy&gt;0 scroll up;dy&lt;0,scroll down</span><br><span class="line">        Log.i(TAG, &quot;onNestedPreScroll: dy&#x3D;&quot; + dy);</span><br><span class="line">        float halfOfDis &#x3D; dy;</span><br><span class="line">        &#x2F;&#x2F;    不能滑动了，直接给 Header 设置 终值，防止出错</span><br><span class="line">        if (!canScroll(child, halfOfDis)) &#123;</span><br><span class="line">            child.setTranslationY(halfOfDis &gt; 0 ? getHeaderOffsetRange() : 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            child.setTranslationY(child.getTranslationY() - halfOfDis);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;consumed all scroll behavior after we started Nested Scrolling</span><br><span class="line">        consumed[1] &#x3D; dy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    需要注意的是  Header 我们是通过 setTranslationY 来移出屏幕的，所以这个值是负数</span><br><span class="line">    private int getHeaderOffsetRange() &#123;</span><br><span class="line">        return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen</span><br><span class="line">                .weibo_header_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleActionUp(CoordinatorLayout parent, final View child) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;handleActionUp: &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">            child.removeCallbacks(mFlingRunnable);</span><br><span class="line">            mFlingRunnable &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">        if (child.getTranslationY() &lt; getHeaderOffsetRange() &#x2F; 6.0f) &#123;</span><br><span class="line">            mFlingRunnable.scrollToClosed(DURATION_SHORT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mFlingRunnable.scrollToOpen(DURATION_SHORT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void onFlingFinished(CoordinatorLayout coordinatorLayout, View layout) &#123;</span><br><span class="line">        changeState(isClosed(layout) ? STATE_CLOSED : STATE_OPENED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openPager() &#123;</span><br><span class="line">        openPager(DURATION_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param duration open animation duration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void openPager(int duration) &#123;</span><br><span class="line">        View child &#x3D; mChild.get();</span><br><span class="line">        CoordinatorLayout parent &#x3D; mParent.get();</span><br><span class="line">        if (isClosed() &amp;&amp; child !&#x3D; null) &#123;</span><br><span class="line">            if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">                child.removeCallbacks(mFlingRunnable);</span><br><span class="line">                mFlingRunnable &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">            mFlingRunnable.scrollToOpen(duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void closePager() &#123;</span><br><span class="line">        closePager(DURATION_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param duration close animation duration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void closePager(int duration) &#123;</span><br><span class="line">        View child &#x3D; mChild.get();</span><br><span class="line">        CoordinatorLayout parent &#x3D; mParent.get();</span><br><span class="line">        if (!isClosed()) &#123;</span><br><span class="line">            if (mFlingRunnable !&#x3D; null) &#123;</span><br><span class="line">                child.removeCallbacks(mFlingRunnable);</span><br><span class="line">                mFlingRunnable &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlingRunnable &#x3D; new FlingRunnable(parent, child);</span><br><span class="line">            mFlingRunnable.scrollToClosed(duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private FlingRunnable mFlingRunnable;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * For animation , Why not use &#123;@link android.view.ViewPropertyAnimator &#125; to play animation</span><br><span class="line">     * is of the</span><br><span class="line">     * other &#123;@link CoordinatorLayout.Behavior&#125; that depend on this could not receiving the</span><br><span class="line">     * correct result of</span><br><span class="line">     * &#123;@link View#getTranslationY()&#125; after animation finished for whatever reason that i don&#39;t know</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private class FlingRunnable implements Runnable &#123;</span><br><span class="line">        private final CoordinatorLayout mParent;</span><br><span class="line">        private final View mLayout;</span><br><span class="line"></span><br><span class="line">        FlingRunnable(CoordinatorLayout parent, View layout) &#123;</span><br><span class="line">            mParent &#x3D; parent;</span><br><span class="line">            mLayout &#x3D; layout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void scrollToClosed(int duration) &#123;</span><br><span class="line">            float curTranslationY &#x3D; ViewCompat.getTranslationY(mLayout);</span><br><span class="line">            float dy &#x3D; getHeaderOffsetRange() - curTranslationY;</span><br><span class="line">            if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed:offest:&quot; + getHeaderOffsetRange());</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur0:&quot; + curTranslationY + &quot;,end0:&quot; + dy);</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur:&quot; + Math.round(curTranslationY) + &quot;,end:&quot; + Math</span><br><span class="line">                        .round(dy));</span><br><span class="line">                Log.d(TAG, &quot;scrollToClosed: cur1:&quot; + (int) (curTranslationY) + &quot;,end:&quot; + (int) dy);</span><br><span class="line">            &#125;</span><br><span class="line">            mOverScroller.startScroll(0, Math.round(curTranslationY - 0.1f), 0, Math.round(dy +</span><br><span class="line">                    0.1f), duration);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void scrollToOpen(int duration) &#123;</span><br><span class="line">            float curTranslationY &#x3D; ViewCompat.getTranslationY(mLayout);</span><br><span class="line">            mOverScroller.startScroll(0, (int) curTranslationY, 0, (int) -curTranslationY,</span><br><span class="line">                    duration);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void start() &#123;</span><br><span class="line">            if (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">                mFlingRunnable &#x3D; new FlingRunnable(mParent, mLayout);</span><br><span class="line">                ViewCompat.postOnAnimation(mLayout, mFlingRunnable);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                onFlingFinished(mParent, mLayout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mLayout !&#x3D; null &amp;&amp; mOverScroller !&#x3D; null) &#123;</span><br><span class="line">                if (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">                    if (BuildConfig.DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, &quot;run: &quot; + mOverScroller.getCurrY());</span><br><span class="line">                    &#125;</span><br><span class="line">                    ViewCompat.setTranslationY(mLayout, mOverScroller.getCurrY());</span><br><span class="line">                    ViewCompat.postOnAnimation(mLayout, this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    onFlingFinished(mParent, mLayout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * callback for HeaderPager &#39;s state</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public interface OnPagerStateListener &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * do callback when pager closed</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void onPagerClosed();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * do callback when pager opened</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void onPagerOpened();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二个关键点的实现"><a href="#第二个关键点的实现" class="headerlink" title="第二个关键点的实现"></a>第二个关键点的实现</h3><p>在页面状态为 open 的时候，向上滑动 Header 的时候，整体向上偏移。</p><p>在第一个关键点的实现上，我们是通过自定义 Behavior 来处理 ViewPager 里面 RecyclerView 的移动的，那我们要怎样监听整个 Header 的滑动了。</p><p>那就是重写 LinearLayout，将滑动事件交给 ScrollingParent（这里是CoordinatorLayout） 去处理，CoordinatorLayout 再交给子 View 的 behavior 去处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">public class NestedLinearLayout extends LinearLayout implements NestedScrollingChild &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG &#x3D; &quot;NestedLinearLayout&quot;;</span><br><span class="line"></span><br><span class="line">    private final int[] offset &#x3D; new int[2];</span><br><span class="line">    private final int[] consumed &#x3D; new int[2];</span><br><span class="line"></span><br><span class="line">    private NestedScrollingChildHelper mScrollingChildHelper;</span><br><span class="line">    private int lastY;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NestedLinearLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        if (mScrollingChildHelper &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mScrollingChildHelper &#x3D; new NestedScrollingChildHelper(this);</span><br><span class="line">            mScrollingChildHelper.setNestedScrollingEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction())&#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                lastY &#x3D; (int) event.getRawY();</span><br><span class="line">                &#x2F;&#x2F; 当开始滑动的时候，告诉父view</span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_HORIZONTAL</span><br><span class="line">                        | ViewCompat.SCROLL_AXIS_VERTICAL);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction())&#123;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&#x3D;&quot;);</span><br><span class="line">                int y &#x3D; (int) (event.getRawY());</span><br><span class="line">                int dy &#x3D;lastY- y;</span><br><span class="line">                lastY &#x3D; y;</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: lastY&#x3D;&quot; + lastY);</span><br><span class="line">                Log.i(TAG, &quot;onTouchEvent: dy&#x3D;&quot; + dy);</span><br><span class="line">                &#x2F;&#x2F;  dy &lt; 0 下拉， dy&gt;0 赏花</span><br><span class="line">                if (dy &gt;0) &#123; &#x2F;&#x2F; 上滑的时候才交给父类去处理</span><br><span class="line">                    if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) &#x2F;&#x2F; 如果找到了支持嵌套滚动的父类</span><br><span class="line">                            &amp;&amp; dispatchNestedPreScroll(0, dy, consumed, offset)) &#123;&#x2F;&#x2F;</span><br><span class="line">                        &#x2F;&#x2F; 父类进行了一部分滚动</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if (startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL) &#x2F;&#x2F; 如果找到了支持嵌套滚动的父类</span><br><span class="line">                            &amp;&amp; dispatchNestedScroll(0, 0, 0,dy, offset)) &#123;&#x2F;&#x2F;</span><br><span class="line">                        &#x2F;&#x2F; 父类进行了一部分滚动</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private NestedScrollingChildHelper getScrollingChildHelper() &#123;</span><br><span class="line">        return mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接口实现--------------------------------------------------</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setNestedScrollingEnabled(boolean enabled) &#123;</span><br><span class="line">        getScrollingChildHelper().setNestedScrollingEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isNestedScrollingEnabled() &#123;</span><br><span class="line">        return getScrollingChildHelper().isNestedScrollingEnabled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean startNestedScroll(int axes) &#123;</span><br><span class="line">        return getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stopNestedScroll() &#123;</span><br><span class="line">        getScrollingChildHelper().stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNestedScrollingParent() &#123;</span><br><span class="line">        return getScrollingChildHelper().hasNestedScrollingParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,</span><br><span class="line">                                        int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedScroll(dxConsumed,</span><br><span class="line">                dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed,</span><br><span class="line">                                           int[] offsetInWindow) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy,</span><br><span class="line">                consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedFling(float velocityX, float velocityY,</span><br><span class="line">                                       boolean consumed) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedFling(velocityX,</span><br><span class="line">                velocityY, consumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchNestedPreFling(float velocityX, float velocityY) &#123;</span><br><span class="line">        return getScrollingChildHelper().dispatchNestedPreFling(velocityX,</span><br><span class="line">                velocityY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Content-部分的实现"><a href="#Content-部分的实现" class="headerlink" title="Content 部分的实现"></a>Content 部分的实现</h2><p>Content 部分的实现也主要有两个关键点</p><ul><li>整体置于 Header 之下</li><li>Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。</li></ul><h3 id="第一个关键点的实现-1"><a href="#第一个关键点的实现-1" class="headerlink" title="第一个关键点的实现"></a>第一个关键点的实现</h3><p>整体置于 Header 之下。这个我们可以参考 APPBarLayout 的 behavior，它是这样处理的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Copy from Android design library</span><br><span class="line"> * &lt;p&#x2F;&gt;</span><br><span class="line"> * Created by xujun</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class HeaderScrollingViewBehavior extends ViewOffsetBehavior&lt;View&gt; &#123;</span><br><span class="line">    private final Rect mTempRect1 &#x3D; new Rect();</span><br><span class="line">    private final Rect mTempRect2 &#x3D; new Rect();</span><br><span class="line"></span><br><span class="line">    private int mVerticalLayoutGap &#x3D; 0;</span><br><span class="line">    private int mOverlayTop;</span><br><span class="line"></span><br><span class="line">    public HeaderScrollingViewBehavior() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeaderScrollingViewBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">        final int childLpHeight &#x3D; child.getLayoutParams().height;</span><br><span class="line">        if (childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.MATCH_PARENT || childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; If the menu&#39;s height is set to match_parent&#x2F;wrap_content then measure it</span><br><span class="line">            &#x2F;&#x2F; with the maximum visible height</span><br><span class="line"></span><br><span class="line">            final List&lt;View&gt; dependencies &#x3D; parent.getDependencies(child);</span><br><span class="line">            final View header &#x3D; findFirstDependency(dependencies);</span><br><span class="line">            if (header !&#x3D; null) &#123;</span><br><span class="line">                if (ViewCompat.getFitsSystemWindows(header) &amp;&amp; !ViewCompat.getFitsSystemWindows(child)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If the header is fitting system windows then we need to also,</span><br><span class="line">                    &#x2F;&#x2F; otherwise we&#39;ll get CoL&#39;s compatible measuring</span><br><span class="line">                    ViewCompat.setFitsSystemWindows(child, true);</span><br><span class="line"></span><br><span class="line">                    if (ViewCompat.getFitsSystemWindows(child)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If the set succeeded, trigger a new layout and return true</span><br><span class="line">                        child.requestLayout();</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (ViewCompat.isLaidOut(header)) &#123;</span><br><span class="line">                    int availableHeight &#x3D; View.MeasureSpec.getSize(parentHeightMeasureSpec);</span><br><span class="line">                    if (availableHeight &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If the measure spec doesn&#39;t specify a size, use the current height</span><br><span class="line">                        availableHeight &#x3D; parent.getHeight();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final int height &#x3D; availableHeight - header.getMeasuredHeight() + getScrollRange(header);</span><br><span class="line">                    final int heightMeasureSpec &#x3D; View.MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            childLpHeight &#x3D;&#x3D; ViewGroup.LayoutParams.MATCH_PARENT ? View.MeasureSpec.EXACTLY : View.MeasureSpec.AT_MOST);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Now measure the scrolling view with the correct height</span><br><span class="line">                    parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed);</span><br><span class="line"></span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void layoutChild(final CoordinatorLayout parent, final View child, final int layoutDirection) &#123;</span><br><span class="line">        final List&lt;View&gt; dependencies &#x3D; parent.getDependencies(child);</span><br><span class="line">        final View header &#x3D; findFirstDependency(dependencies);</span><br><span class="line"></span><br><span class="line">        if (header !&#x3D; null) &#123;</span><br><span class="line">            final CoordinatorLayout.LayoutParams lp &#x3D; (CoordinatorLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">            final Rect available &#x3D; mTempRect1;</span><br><span class="line">            available.set(parent.getPaddingLeft() + lp.leftMargin, header.getBottom() + lp.topMargin,</span><br><span class="line">                    parent.getWidth() - parent.getPaddingRight() - lp.rightMargin,</span><br><span class="line">                    parent.getHeight() + header.getBottom() - parent.getPaddingBottom() - lp.bottomMargin);</span><br><span class="line"></span><br><span class="line">            final Rect out &#x3D; mTempRect2;</span><br><span class="line">            GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(), child.getMeasuredHeight(), available, out, layoutDirection);</span><br><span class="line"></span><br><span class="line">            final int overlap &#x3D; getOverlapPixelsForOffset(header);</span><br><span class="line"></span><br><span class="line">            child.layout(out.left, out.top - overlap, out.right, out.bottom - overlap);</span><br><span class="line">            mVerticalLayoutGap &#x3D; out.top - header.getBottom();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If we don&#39;t have a dependency, let super handle it</span><br><span class="line">            super.layoutChild(parent, child, layoutDirection);</span><br><span class="line">            mVerticalLayoutGap &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float getOverlapRatioForOffset(final View header) &#123;</span><br><span class="line">        return 1f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int getOverlapPixelsForOffset(final View header) &#123;</span><br><span class="line">        return mOverlayTop &#x3D;&#x3D; 0</span><br><span class="line">                ? 0</span><br><span class="line">                : MathUtils.constrain(Math.round(getOverlapRatioForOffset(header) * mOverlayTop),</span><br><span class="line">                0, mOverlayTop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int resolveGravity(int gravity) &#123;</span><br><span class="line">        return gravity &#x3D;&#x3D; Gravity.NO_GRAVITY ? GravityCompat.START | Gravity.TOP : gravity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract View findFirstDependency(List&lt;View&gt; views);</span><br><span class="line"></span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        return v.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The gap between the top of the scrolling view and the bottom of the header layout in pixels.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final int getVerticalLayoutGap() &#123;</span><br><span class="line">        return mVerticalLayoutGap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set the distance that this view should overlap any &#123;@link AppBarLayout&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param overlayTop the distance in px</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final void setOverlayTop(int overlayTop) &#123;</span><br><span class="line">        mOverlayTop &#x3D; overlayTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the distance that this view should overlap any &#123;@link AppBarLayout&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final int getOverlayTop() &#123;</span><br><span class="line">        return mOverlayTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个基类的代码还是很好理解的，因为之前就说过了，正常来说被依赖的 View 会优先于依赖它的 View 处理，所以需要依赖的 View 可以在 measure/layout 的时候，找到依赖的 View 并获取到它的测量/布局的信息，这里的处理就是依靠着这种关系来实现的.</p><p>我们的实现类，需要重写的除了抽象方法 findFirstDependency 外，还需要重写 getScrollRange，我们把 Header<br>的 Id id_weibo_header 定义在 ids.xml 资源文件内，方便依赖的判断.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzI1ZWZiMTA?x-oss-process=image/format,png"></p><p>至于缩放的高度，根据 结果图 得知是 0，得出如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int getFinalHeight() &#123;</span><br><span class="line">     Resources resources &#x3D; BaseAPP.getInstance().getResources();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        if (isDependOn(v)) &#123;</span><br><span class="line">            return Math.max(0, v.getMeasuredHeight() - getFinalHeight());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.getScrollRange(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第二个关键点的实现："><a href="#第二个关键点的实现：" class="headerlink" title="第二个关键点的实现："></a>第二个关键点的实现：</h3><p>Content 跟着 Header 移动。即 Header 位置发生变化的时候，Content 也需要随着调整位置。</p><p>主要的逻辑就是 在 layoutDependsOn 方法里面，判断 dependcy  是不是 HeaderView  ，是的话，返回TRUE，这样在 Header 位置发生变化的时候，会回调 onDependentViewChanged 方法，在该方法里面，做相应的偏移。TranslationY 是根据比例算出来的   translationY = (int) (-dependencyTranslationY / (getHeaderOffsetRange() * 1.0f) * getScrollRange(dependency));</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class WeiboContentBehavior extends HeaderScrollingViewBehavior &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;WeiboContentBehavior&quot;;</span><br><span class="line"></span><br><span class="line">    public WeiboContentBehavior() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public WeiboContentBehavior(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        return isDependOn(dependency);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        if (BuildConfig.DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;onDependentViewChanged&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        offsetChildAsNeeded(parent, child, dependency);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void offsetChildAsNeeded(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">        float dependencyTranslationY &#x3D; dependency.getTranslationY();</span><br><span class="line">        int translationY &#x3D; (int) (-dependencyTranslationY &#x2F; (getHeaderOffsetRange() * 1.0f) * </span><br><span class="line">                getScrollRange(dependency));</span><br><span class="line">        Log.i(TAG, &quot;offsetChildAsNeeded: translationY&#x3D;&quot; + translationY);</span><br><span class="line">        child.setTranslationY(translationY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected View findFirstDependency(List&lt;View&gt; views) &#123;</span><br><span class="line">        for (int i &#x3D; 0, z &#x3D; views.size(); i &lt; z; i++) &#123;</span><br><span class="line">            View view &#x3D; views.get(i);</span><br><span class="line">            if (isDependOn(view)) return view;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected int getScrollRange(View v) &#123;</span><br><span class="line">        if (isDependOn(v)) &#123;</span><br><span class="line">            return Math.max(0, v.getMeasuredHeight() - getFinalHeight());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.getScrollRange(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getHeaderOffsetRange() &#123;</span><br><span class="line">        return BaseAPP.getInstance().getResources().getDimensionPixelOffset(R.dimen</span><br><span class="line">                .weibo_header_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getFinalHeight() &#123;</span><br><span class="line">        Resources resources &#x3D; BaseAPP.getInstance().getResources();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isDependOn(View dependency) &#123;</span><br><span class="line">        return dependency !&#x3D; null &amp;&amp; dependency.getId() &#x3D;&#x3D; R.id.id_weibo_header;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul><li>NestedScrolling 机制，对比传统的事件分发机制真的很强大。这种仿新浪微博发现页效果， 如果用传统的事件分发机制来做，估计很难实现，处理起来会有一大堆坑。</li><li>看完了这种仿新浪微博发现页的效果，你是不是学到了什么?如果让你 模仿 仿 QQ 浏览器首页效果，你能实现话。</li></ul><p>最后，特别感谢写这篇博客 <a href="http://www.jianshu.com/p/f7989a2a3ec2">自定义Behavior的艺术探索-仿UC浏览器主页</a> 的开发者，没有这篇博客作为参考，这种效果我很大几率是实现 不了的。大家觉得效果还不错的话，顺手到 github 上面给我 star，谢谢。<a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample">github 地址</a></p><hr><p>参考文章：</p><p><a href="http://www.jianshu.com/p/f7989a2a3ec2">自定义Behavior的艺术探索-仿UC浏览器主页</a></p><p><a href="https://github.com/gdutxiaoxu/CoordinatorLayoutExample">github 地址</a></p><p>最后的最后，卖一下广告，欢迎大家关注我的微信公众号 徐公码字，扫一扫下方二维码或搜索微信号 stormjun94，即可关注。 目前专注于 Android 开发，主要分享 Android开发相关知识和一些相关的优秀文章，包括个人总结，职场经验等。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzE2LzE2ZDM5ZGI0YzM2YmMyMDc?x-oss-process=image/format,png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/gdutxiaoxu/article/details/52858598&quot;&gt;使用CoordinatorLayout打造各种炫酷的效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/
      
    
    </summary>
    
    
  </entry>
  
</feed>
