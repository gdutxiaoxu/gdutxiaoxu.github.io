<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"gdutxiaoxu.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="说在前面本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。 目录大概如下  1 LiveData 基"><meta property="og:type" content="article"><meta property="og:title" content="Android LiveData 使用详解"><meta property="og:url" content="https://gdutxiaoxu.github.io/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html"><meta property="og:site_name" content="程序员徐公"><meta property="og:description" content="说在前面本次推出 Android  Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。 目录大概如下  1 LiveData 基"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4e6df41528ff27a085a266dd18b707a8.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2019-01-13T08:26:32.000Z"><meta property="article:modified_time" content="2021-04-18T01:47:15.137Z"><meta property="article:author" content="徐公"><meta property="article:tag" content="Android LiveData"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/4e6df41528ff27a085a266dd18b707a8.png"><link rel="canonical" href="https://gdutxiaoxu.github.io/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Android LiveData 使用详解 | 程序员徐公</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4c07021d4e615e143c687345e17eb0ae";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">程序员徐公</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">微信公众号：程序员徐公</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://gdutxiaoxu.github.io/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="徐公"><meta itemprop="description" content="「Android学习+面试指南」助你升职加薪"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="程序员徐公"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Android LiveData 使用详解</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-01-13 16:26:32" itemprop="dateCreated datePublished" datetime="2019-01-13T16:26:32+08:00">2019-01-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-04-18 09:47:15" itemprop="dateModified" datetime="2021-04-18T09:47:15+08:00">2021-04-18</time> </span><span id="/Android%20LiveData%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html" class="post-meta-item leancloud_visitors" data-flag-title="Android LiveData 使用详解" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本次推出 Android Architecture Components 系列文章，目前写好了四篇，主要是关于 lifecycle，livedata 的使用和源码分析，其余的 Navigation， Paging library，Room，WorkMannager 等春节结束之后会更新，欢迎关注我的公众号，有更新的话会第一时间会在公众号上面通知。</p><p>目录大概如下</p><blockquote><p>1 LiveData 基本使用<br>2 自定义 Livedata<br>3 Livedata 共享数据<br>4 Livedata 小结</p></blockquote><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660746">Android lifecycle 使用详解</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660760">Android LiveData 使用详解</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a target="_blank" rel="noopener" href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><p><strong>程序员徐公，一位不羁的码农。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e6df41528ff27a085a266dd18b707a8.png"></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博客中，我们讲解了 lifecycle 的使用及优点。这篇博客让我们一起来了解一下 LiveData 是怎样使用的？</p><hr><h2 id="为什么要引进-LiveData"><a href="#为什么要引进-LiveData" class="headerlink" title="为什么要引进 LiveData"></a>为什么要引进 LiveData</h2><p>LiveData 是一个可以被观察的数据持有类，它可以感知 Activity、Fragment或Service 等组件的生命周期。简单来说，他主要有一下优点。</p><ol><li><strong>它可以做到在组件处于激活状态的时候才会回调相应的方法，从而刷新相应的 UI</strong>。</li><li><strong>不用担心发生内存泄漏</strong></li><li><strong>当 config 导致 activity 重新创建的时候，不需要手动取处理数据的储存和恢复。它已经帮我们封装好了</strong>。</li><li>当 Actiivty 不是处于激活状态的时候，如果你想 livedata setValue 之后立即回调 obsever 的 onChange 方法，而不是等到 Activity 处于激活状态的时候才回调 obsever 的 onChange 方法，你可以使用 observeForever 方法，但是你必须在 onDestroy 的时候 removeObserver。</li></ol><p>回想一下，在你的项目中，是不是经常会碰到这样的问题，当网络请求结果回来的时候，你经常需要判断 Activity 或者 Fragment 是否已经 Destroy， 如果不是 destroy，才更新 UI。</p><p>而当你如果使用 Livedata 的话，因为它是在 Activity 处于 onStart 或者 onResume 的状态时，他才会进行相应的回调，因而可以很好得处理这个问题，不必写一大堆的 activity.isDestroyed()。接下来，让我们一起来看一下 LiveData 的使用</p><hr><h2 id="LiveData-使用"><a href="#LiveData-使用" class="headerlink" title="LiveData 使用"></a>LiveData 使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>引入相关的依赖包</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModel and LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:extensions:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:viewmodel:1.1.0&quot;</span></span><br><span class="line"><span class="comment">// alternatively, just LiveData</span></span><br><span class="line">implementation <span class="string">&quot;android.arch.lifecycle:livedata:1.1.0&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在代码中使用</li></ol><p>LiveData 是一个抽象类，它的实现子类有 <strong>MutableLiveData</strong> ，<strong>MediatorLiveData</strong>。在实际使用中，用得比较多的是 MutableLiveData。他常常结合 ViewModel 一起使用。下面，让我们一起来看一下怎样使用它？</p><p>首先，我们先写一个类继承我们的 ViewModel，里面持有 mNameEvent。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    private MutableLiveData&lt;<span class="built_in">String</span>&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MutableLiveData&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">getNameEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们在 Activity 中创建 ViewModel，并监听 ViewModel 里面 mNameEvent 数据的变化，当数据改变的时候，我们打印相应的 log，并设置给 textView，显示在界面上。这样我们就完成了对 mNameEvent 数据源的观察。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mTestViewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;String&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="keyword">this</span>, <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> String s)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后当我们数据源改变的时候，我们需要调用 livedata 的 setValue 或者 postvalue 方法。他们之间的区别是， 调用 setValue 方法，Observer 的 onChanged 方法会在调用 serValue 方法的线程回调。而<br>postvalue 方法，Observer 的 onChanged 方法将会在主线程回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTestViewModel.getNameEvent().setValue(name);</span><br></pre></td></tr></table></figure><p>可能部分同学有这样的疑问了，<strong>我们的 ViewModel 是通过 ViewModelProviders.of(this).get(TestViewModel.class); 方法创建出来的，如果我们要携带参数，怎么办？</strong></p><p>其实，官方也替我们考虑好了，同样是调用 ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) 方法，只不过，需要多传递一个 factory 参数。</p><p>Factory 是一个接口，它只有一个 create 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a newly created ViewModel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际当中，我们的做法是：实现 Factory 接口，重写 create 方法，在create 方法里面调用相应的构造函数，返回相应的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mKey;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;String&gt; mNameEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getNameEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mNameEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestViewModel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        mKey = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String mKey;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            mKey = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> TestViewModel(mKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModelProviders.of(this, new TestViewModel.Factory(mkey)).get(TestViewModel.class)</p><hr><h2 id="自定义-Livedata"><a href="#自定义-Livedata" class="headerlink" title="自定义 Livedata"></a>自定义 Livedata</h2><p>Livedata 主要有几个方法</p><ol><li>observe</li><li>onActive</li><li>onInactive</li><li>observeForever</li></ol><p>void observe (LifecycleOwner owner, Observer<t>observer)</t></p><blockquote><p>Adds the given observer to the observers list within the lifespan of the given owner. The events are dispatched on the main thread. If LiveData already has data set, it will be delivered to the observer.</p></blockquote><p>void onActive ()</p><blockquote><p>Called when the number of active observers change to 1 from 0.<br>This callback can be used to know that this LiveData is being used thus should be kept up to date.</p></blockquote><p>当回调该方法的时候，表示该 liveData 正在背使用，因此应该保持最新</p><p>void onInactive ()</p><blockquote><p>Called when the number of active observers change from 1 to 0.<br>This does not mean that there are no observers left, there may still be observers but their lifecycle states aren’t STARTED or RESUMED (like an Activity in the back stack).<br>You can check if there are observers via hasObservers().</p></blockquote><p>当该方法回调时，表示他所有的 obervers 没有一个状态处理 STARTED 或者 RESUMED，注意，这不代表没有 observers。</p><p>Void observeForever</p><p>跟 observe 方法不太一样的是，它在 Activity 处于 onPause ，onStop， onDestroy 的时候，都可以回调 obsever 的 onChange 方法，但是有一点需要注意的是，我们必须手动 remove obsever，否则会发生内存泄漏。</p><p>这里我们以观察网络状态变化为例子讲解</p><ol><li>首先我们自定义一个 Class NetworkLiveData，继承 LiveData，重写它的 onActive 方法和 onInactive 方法</li><li>在 onActive 方法中，我们注册监听网络变化的广播，即ConnectivityManager.CONNECTIVITY_ACTION。在 onInactive 方法的时候，我们注销广播。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">NetworkInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">static</span> NetworkLiveData mNetworkLiveData;</span><br><span class="line">    <span class="keyword">private</span> NetworkReceiver mNetworkReceiver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IntentFilter mIntentFilter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;NetworkLiveData&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetworkLiveData</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        mNetworkReceiver = <span class="keyword">new</span> NetworkReceiver();</span><br><span class="line">        mIntentFilter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkLiveData <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mNetworkLiveData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNetworkLiveData = <span class="keyword">new</span> NetworkLiveData(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mNetworkLiveData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onActive:&quot;</span>);</span><br><span class="line">        mContext.registerReceiver(mNetworkReceiver, mIntentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInactive();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onInactive: &quot;</span>);</span><br><span class="line">        mContext.unregisterReceiver(mNetworkReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            ConnectivityManager manager = (ConnectivityManager) context</span><br><span class="line">                    .getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            NetworkInfo activeNetwork = manager.getActiveNetworkInfo();</span><br><span class="line">            getInstance(context).setValue(activeNetwork);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们想监听网络变化的时候，我们只需要调用相应的 observe 方法即可，方便又快捷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NetworkLiveData.getInstance(<span class="built_in">this</span>).observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;NetworkInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable NetworkInfo networkInfo</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: networkInfo=&quot;</span> +networkInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4b7945475a6f">https://www.jianshu.com/p/4b7945475a6f</a></p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><h3 id="Fragment-Activity-之间共享数据"><a href="#Fragment-Activity-之间共享数据" class="headerlink" title="Fragment Activity 之间共享数据"></a>Fragment Activity 之间共享数据</h3><p>我们回过头来再来看一下 ViewModelProvider 的 of 方法，他主要有四个方法，分别是</p><ol><li>ViewModelProvider of(@NonNull Fragment fragment)</li><li>ViewModelProvider of(@NonNull FragmentActivity activity)</li><li>ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory)</li><li>ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory)</li></ol><p>1,2 方法之间的主要区别是传入 Fragment 或者 FragmentActivity。而我们知道，通过 ViewModel of 方法创建的 ViewModel 实例， 对于同一个 fragment 或者 fragmentActivity 实例，ViewModel 实例是相同的，因而我们可以利用该特点，在 Fragment 中创建 ViewModel 的时候，传入的是 Fragment 所依附的 Activity。因而他们的 ViewModel 实例是相同的，从而可以做到共享数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// LiveDataSampleActivity(TestFragment 依赖的 Activity）</span></span><br><span class="line">mTestViewModel = ViewModelProviders.of(<span class="built_in">this</span>, <span class="keyword">new</span> TestViewModel.Factory(mkey)).get(TestViewModel.class);</span><br><span class="line">MutableLiveData&lt;<span class="built_in">String</span>&gt; nameEvent = mTestViewModel.getNameEvent();</span><br><span class="line">nameEvent.observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onChanged: s = &quot;</span> + s);</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestFragment 中</span></span><br><span class="line">mViewModel = ViewModelProviders.of(mActivity).get(TestViewModel.class);</span><br><span class="line">mViewModel.getNameEvent().observe(<span class="built_in">this</span>, <span class="keyword">new</span> Observer&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params">@Nullable <span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s =&quot;</span> + s + <span class="string">&quot; mViewModel.getKey() =&quot;</span> + mViewModel.getKey());</span><br><span class="line">        mTvName.setText(s);</span><br><span class="line">        boolean result = mViewModel == ((LiveDataSampleActivity) mListener).mTestViewModel;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onChanged: s result =&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，LiveDataSampleActivity 和 TestFragment 中的 ViewModel 是同一个实例。即 Activity 和 Fragment 共享数据。</p><h3 id="全局共享数据"><a href="#全局共享数据" class="headerlink" title="全局共享数据"></a>全局共享数据</h3><p>说到全局共享数据，我们想一下我们的应用全景，比如说我的账户数据，这个对于整个 App 来说，肯定是全局共享的。有时候，当我们的数据变化的时候，我们需要通知我们相应的界面，刷新 UI。如果用传统的方式来实现，那么我们一般才采取观察者的方式来实现，这样，当我们需要观察数据的时候，我们需要添加 observer，在界面销毁的时候，我们需要移除 observer。</p><p>但是，如果我们用 LiveData 来实现的话，它内部逻辑都帮我们封装好了，我们只需要保证 AccountLiveData 是单例的就ok，在需要观察的地方调用 observer 方法即可。也不需要手动移除 observer，不会发生内存泄漏，方便快捷。</p><p>这里 AccountLiveData 的实现就不贴出来了，可以参考上面的 NetworkLiveData 实现</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里说一点关于 LiveData 与 ViewModel 的应用场景，我尽量说得通俗一点，不要说得那么官方，这样对新手很难理解。</p><p>觉得不错的，请点个赞，让我们看到你们的欢呼声。你们的支持就是我写作的最大动力。</p><ol><li>LiveData 内部已经实现了观察者模式，如果你的数据要同时通知几个界面，可以采取这种方式</li><li>我们知道 LiveData 数据变化的时候，会回调 Observer 的 onChange 方法，但是回调的前提是 lifecycleOwner（即所依附的 Activity 或者 Fragment） 处于 started 或者 resumed 状态，它才会回调，否则，必须等到 lifecycleOwner 切换到前台的时候，才回调。</li><li>因此，这对性能方面确实是一个不小的提升。但是，对于你想做一些类似与在后台工作的（黑科技）， liveData 就不太适合了，你可以使用 observeForever 方法，或者自己实现观察者模式去吧。</li></ol><p><strong>Lifecycle，LiveData， ViewModel 的基本使用到此已经讲解完毕，想了解他们的实现原理的话可以阅读这两篇文章。</strong></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660766">Android lifecyle 源码解剖</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/86660776">Android livedata 源码解剖</a></p><p><a target="_blank" rel="noopener" href="https://github.com/gdutxiaoxu/ArchiteComponentsSample">github sample 地址： ArchiteComponentsSample</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p><p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.jpg"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Android-LiveData/" rel="tag"># Android LiveData</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Android%20lifecyle%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96.html" rel="prev" title="Android lifecyle 源码解剖"><i class="fa fa-chevron-left"></i> Android lifecyle 源码解剖</a></div><div class="post-nav-item"><a href="/Android%20livedata%20%E6%BA%90%E7%A0%81%E8%A7%A3%E5%89%96.html" rel="next" title="Android LiveData 源码分析">Android LiveData 源码分析 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">说在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E8%BF%9B-LiveData"><span class="nav-number">3.</span> <span class="nav-text">为什么要引进 LiveData</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LiveData-%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">LiveData 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">基本使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Livedata"><span class="nav-number">5.</span> <span class="nav-text">自定义 Livedata</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">6.</span> <span class="nav-text">共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragment-Activity-%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">6.1.</span> <span class="nav-text">Fragment Activity 之间共享数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.</span> <span class="nav-text">全局共享数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">8.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">徐公</p><div class="site-description" itemprop="description">「Android学习+面试指南」助你升职加薪</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><div></div><div class="wechat_OA"><br><span>扫一扫，欢迎关注我的公众号</span><br><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/qrcode_for_gh_f0b7a2d93f70_430%20(2).jpg"></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">徐公</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">194k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">2:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><script>!function(){function l(e){return e=encodeURI(e),document.getElementById(e).querySelector(".leancloud-visitors-count")}let{app_id:i,app_key:c,server_url:e}={enable:!0,app_id:"sybN87KmhJxd3H4Da6hVBgOf-gzGzoHsz",app_key:null,server_url:"7Ak1SzgvL37BJyjeMRDi6MVr",security:!0};function t(n){var r,t,e,o,s=(e,t,o)=>fetch(`${n}/1.1${t}`,{method:e,headers:{"X-LC-Id":i,"X-LC-Key":c,"Content-Type":"application/json"},body:JSON.stringify(o)});CONFIG.page.isPost?CONFIG.hostname===location.hostname&&(t=s,e=document.querySelector(".leancloud_visitors"),o=decodeURI(e.id),e.dataset.flagTitle,t("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:o}))).then(e=>e.json()).then(({results:e})=>{0<e.length?(e=e[0],l(o).innerText=e.time+1,t("put","/classes/Counter/"+e.objectId,{time:{__op:"Increment",amount:1}}).catch(e=>{console.error("Failed to save visitor count",e)})):(l(o).innerText="Counter not initialized! More info at console err msg.",console.error("ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`."))}).catch(e=>{console.error("LeanCloud Counter Error",e)})):1<=document.querySelectorAll(".post-title-link").length&&(s=s,r=[...document.querySelectorAll(".leancloud_visitors")].map(e=>decodeURI(e.id)),s("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:{$in:r}}))).then(e=>e.json()).then(({results:e})=>{for(let t of r){var o=e.find(e=>e.url===t);l(t).innerText=o?o.time:0}}).catch(e=>{console.error("LeanCloud Counter Error",e)}))}var o="-MdYXbMMI"!==i.slice(-9)?e:`https://${i.slice(0,8).toLowerCase()}.api.lncldglobal.com`;o?t(o):fetch("https://app-router.leancloud.cn/2/route?appId="+i).then(e=>e.json()).then(({api_server:e})=>{t("https://"+e)})}()</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html>