<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"gdutxiaoxu.gitee.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="简介什么是 HookHook 又叫“钩子”，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入。 这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）。 Hook 分类1.根据Android开发模式，Native模式（C&#x2F;C++）和Java模式（Java）区分，在Android平台上   Java层级的Hook；  Native层级的Ho"><meta property="og:type" content="article"><meta property="og:title" content="Android Hook 机制之简单实战"><meta property="og:url" content="https://gdutxiaoxu.gitee.io/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/index.html"><meta property="og:site_name" content="程序员徐公"><meta property="og:description" content="简介什么是 HookHook 又叫“钩子”，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入。 这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）。 Hook 分类1.根据Android开发模式，Native模式（C&#x2F;C++）和Java模式（Java）区分，在Android平台上   Java层级的Hook；  Native层级的Ho"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnR4ajVleWl6aWcyMGM3MG9wcTdyLmdpZg"><meta property="og:image" content="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"><meta property="article:published_time" content="2018-05-12T08:26:32.000Z"><meta property="article:modified_time" content="2021-04-18T01:57:33.131Z"><meta property="article:author" content="徐公"><meta property="article:tag" content="hook"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70"><link rel="canonical" href="https://gdutxiaoxu.gitee.io/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Android Hook 机制之简单实战 | 程序员徐公</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4c07021d4e615e143c687345e17eb0ae";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">程序员徐公</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">微信公众号：程序员徐公</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>文章</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://gdutxiaoxu.gitee.io/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="徐公"><meta itemprop="description" content="「Android学习+面试指南」助你升职加薪"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="程序员徐公"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Android Hook 机制之简单实战</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-05-12 16:26:32" itemprop="dateCreated datePublished" datetime="2018-05-12T16:26:32+08:00">2018-05-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-04-18 09:57:33" itemprop="dateModified" datetime="2021-04-18T09:57:33+08:00">2021-04-18</time> </span><span id="/2018/05/12/Android%20Hook%20%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/" class="post-meta-item leancloud_visitors" data-flag-title="Android Hook 机制之简单实战" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>14k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>13 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-Hook"><a href="#什么是-Hook" class="headerlink" title="什么是 Hook"></a>什么是 Hook</h3><p><strong>Hook 又叫“钩子”</strong>，它可以在事件传送的过程中截获并监控事件的传输，将自身的代码与系统方法进行融入。</p><p>这样当这些方法被调用时，也就可以执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p><h3 id="Hook-分类"><a href="#Hook-分类" class="headerlink" title="Hook 分类"></a>Hook 分类</h3><p>1.根据Android开发模式，Native模式（C/C++）和Java模式（Java）区分，在Android平台上</p><ul><li>Java层级的Hook；</li><li>Native层级的Hook；</li></ul><p>2.根 Hook 对象与 Hook 后处理事件方式不同，Hook还分为：</p><ul><li>消息Hook；</li><li>API Hook；</li></ul><p>3.针对Hook的不同进程上来说，还可以分为：</p><ul><li>全局Hook；</li><li>单个进程Hook；</li></ul><h3 id="常见-Hook-框架"><a href="#常见-Hook-框架" class="headerlink" title="常见 Hook 框架"></a>常见 Hook 框架</h3><p>在Android开发中，有以下常见的一些Hook框架：</p><ol><li><strong>Xposed</strong></li></ol><p>通过替换 /system/bin/app_process 程序控制 Zygote 进程，使得 app_process 在启动过程中会加载 XposedBridge.jar 这个 Jar 包，从而完成对 Zygote 进程及其创建的 Dalvik 虚拟机的劫持。</p><p>Xposed 在开机的时候完成对所有的 Hook Function 的劫持，在原 Function 执行的前后加上自定义代码。</p><ol start="2"><li><strong>Cydia Substrate</strong></li></ol><p>Cydia Substrate 框架为苹果用户提供了越狱相关的服务框架，当然也推出了 Android 版 。Cydia Substrate 是一个代码修改平台，它可以修改任何进程的代码。</p><p>不管是用 Java 还是 C/C++（native代码）编写的，而 Xposed 只支持 Hook app_process 中的 Java 函数。</p><ol start="3"><li>Legend</li></ol><p>Legend 是 Android 免 Root 环境下的一个 Apk Hook 框架，该框架代码设计简洁，通用性高，适合逆向工程时一些 Hook 场景。大部分的功能都放到了 Java 层，这样的兼容性就非常好。</p><p>原理是这样的，直接构造出新旧方法对应的虚拟机数据结构，然后替换信息写到内存中即可。</p><h3 id="Hook-必须掌握的知识"><a href="#Hook-必须掌握的知识" class="headerlink" title="Hook 必须掌握的知识"></a>Hook 必须掌握的知识</h3><ul><li>反射</li></ul><p>如果你对反射还不是很熟悉的话，建议你先复习一下 java 反射的相关知识。有兴趣的，可以看一下我的这一篇博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/68947735">Java 反射机制详解</a></p><ul><li>java 的动态代理</li></ul><p>动态代理是指在运行时动态生成代理类，不需要我们像静态代理那个去手动写一个个的代理类。在 java 中，我们可以使用 InvocationHandler 实现动态代理，有兴趣的，可以查看我的这一篇博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/81394050">java 代理模式详解</a></p><p>本文的主要内容是讲解单个进程的 Hook，以及怎样 Hook。有兴趣的可以关注我的微信公众号：<strong>程序员徐公</strong><br><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="Hook-使用实例"><a href="#Hook-使用实例" class="headerlink" title="Hook 使用实例"></a>Hook 使用实例</h2><h3 id="Hook-选择的关键点"><a href="#Hook-选择的关键点" class="headerlink" title="Hook 选择的关键点"></a>Hook 选择的关键点</h3><ul><li><p>Hook 的选择点：尽量静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。</p></li><li><p>Hook 过程：</p><ul><li>寻找 Hook 点，原则是尽量静态变量或者单例对象，尽量 Hook public 的对象和方法。</li><li>选择合适的代理方式，如果是接口可以用动态代理。</li><li>偷梁换柱——用代理对象替换原始对象。</li></ul></li><li><p>Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。</p></li></ul><h3 id="简单案例一-使用-Hook-修改-View-OnClickListener-事件"><a href="#简单案例一-使用-Hook-修改-View-OnClickListener-事件" class="headerlink" title="简单案例一: 使用 Hook 修改 View.OnClickListener 事件"></a>简单案例一: 使用 Hook 修改 View.OnClickListener 事件</h3><p>首先，我们先分析 View.setOnClickListener 源码，找出合适的 Hook 点。可以看到 OnClickListener 对象被保存在了一个叫做 ListenerInfo 的内部类里，其中 mListenerInfo 是 View 的成员变量。ListeneInfo 里面保存了 View 的各种监听事件。因此，我们可以想办法 hook ListenerInfo 的 mOnClickListener 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">    if (!isClickable()) &#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line">    getListenerInfo().mOnClickListener &#x3D; l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class ListenerInfo &#123;</span><br><span class="line"></span><br><span class="line">     ---</span><br><span class="line"></span><br><span class="line">    ListenerInfo getListenerInfo() &#123;</span><br><span class="line">        if (mListenerInfo !&#x3D; null) &#123;</span><br><span class="line">            return mListenerInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        mListenerInfo &#x3D; new ListenerInfo();</span><br><span class="line">        return mListenerInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们一起来看一下怎样 Hook View.OnClickListener 事件？</p><p>大概分为三步：</p><ul><li>第一步：获取 ListenerInfo 对象</li></ul><p>从 View 的源代码，我们可以知道我们可以通过 getListenerInfo 方法获取，于是，我们利用反射得到 ListenerInfo 对象</p><ul><li>第二步：获取原始的 OnClickListener事件方法</li></ul><p>从上面的分析，我们知道 OnClickListener 事件被保存在 ListenerInfo 里面，同理我们利用反射获取</p><ul><li>第三步：偷梁换柱，用 Hook代理类 替换原始的 OnClickListener</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void hookOnClickListener(View view) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一步：反射得到 ListenerInfo 对象</span><br><span class="line">    Method getListenerInfo &#x3D; View.class.getDeclaredMethod(&quot;getListenerInfo&quot;);</span><br><span class="line">    getListenerInfo.setAccessible(true);</span><br><span class="line">    Object listenerInfo &#x3D; getListenerInfo.invoke(view);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到原始的 OnClickListener事件方法</span><br><span class="line">    Class&lt;?&gt; listenerInfoClz &#x3D; Class.forName(&quot;android.view.View$ListenerInfo&quot;);</span><br><span class="line">    Field mOnClickListener &#x3D; listenerInfoClz.getDeclaredField(&quot;mOnClickListener&quot;);</span><br><span class="line">    mOnClickListener.setAccessible(true);</span><br><span class="line">    View.OnClickListener originOnClickListener &#x3D; (View.OnClickListener) mOnClickListener.get(listenerInfo);</span><br><span class="line">    &#x2F;&#x2F; 第三步：用 Hook代理类 替换原始的 OnClickListener</span><br><span class="line">    View.OnClickListener hookedOnClickListener &#x3D; new HookedClickListenerProxy(originOnClickListener);</span><br><span class="line">    mOnClickListener.set(listenerInfo, hookedOnClickListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HookedClickListenerProxy implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private View.OnClickListener origin;</span><br><span class="line"></span><br><span class="line">    public HookedClickListenerProxy(View.OnClickListener origin) &#123;</span><br><span class="line">        this.origin &#x3D; origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Toast.makeText(v.getContext(), &quot;Hook Click Listener&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        if (origin !&#x3D; null) &#123;</span><br><span class="line">            origin.onClick(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下代码，将会看到当我们点击该按钮的时候，会弹出 toast “Hook Click Listener”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mBtn1 &#x3D; (Button) findViewById(R.id.btn_1);</span><br><span class="line">mBtn1.setOnClickListener(this);</span><br><span class="line">try &#123;</span><br><span class="line">    HookHelper.hookOnClickListener(mBtn1);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单案例二：-HooK-Notification"><a href="#简单案例二：-HooK-Notification" class="headerlink" title="简单案例二： HooK Notification"></a>简单案例二： HooK Notification</h3><p>发送消息到通知栏的核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">notificationManager.notify(id, builder.build());</span><br></pre></td></tr></table></figure><p>跟踪 notify 方法发现最终会调用到 notifyAsUser 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void notify(String tag, int id, Notification notification)</span><br><span class="line">&#123;</span><br><span class="line">    notifyAsUser(tag, id, notification, new UserHandle(UserHandle.myUserId()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在 notifyAsUser 方法中，我们惊喜地发现 service 是一个单例，因此，我们可以想方法 hook 住这个 service，而 notifyAsUser 最终会调用到 service 的 enqueueNotificationWithTag 方法。因此 hook 住 service 的 enqueueNotificationWithTag 方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    INotificationManager service &#x3D; getService();</span><br><span class="line">    String pkg &#x3D; mContext.getPackageName();</span><br><span class="line">    &#x2F;&#x2F; Fix the notification as best we can.</span><br><span class="line">    Notification.addFieldsFromContext(mContext, notification);</span><br><span class="line">    if (notification.sound !&#x3D; null) &#123;</span><br><span class="line">        notification.sound &#x3D; notification.sound.getCanonicalUri();</span><br><span class="line">        if (StrictMode.vmFileUriExposureEnabled()) &#123;</span><br><span class="line">            notification.sound.checkFileUriExposed(&quot;Notification.sound&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fixLegacySmallIcon(notification, pkg);</span><br><span class="line">    if (mContext.getApplicationInfo().targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">        if (notification.getSmallIcon() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid notification (no valid small icon): &quot;</span><br><span class="line">                    + notification);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (localLOGV) Log.v(TAG, pkg + &quot;: notify(&quot; + id + &quot;, &quot; + notification + &quot;)&quot;);</span><br><span class="line">    final Notification copy &#x3D; Builder.maybeCloneStrippedForDelivery(notification);</span><br><span class="line">    try &#123;</span><br><span class="line">        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id,</span><br><span class="line">                copy, user.getIdentifier());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static INotificationManager sService;</span><br><span class="line"></span><br><span class="line">static public INotificationManager getService()</span><br><span class="line">&#123;</span><br><span class="line">    if (sService !&#x3D; null) &#123;</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b &#x3D; ServiceManager.getService(&quot;notification&quot;);</span><br><span class="line">    sService &#x3D; INotificationManager.Stub.asInterface(b);</span><br><span class="line">    return sService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上，要 Hook Notification，大概需要三步：</p><ul><li>第一步：得到 NotificationManager 的 sService</li><li>第二步：因为 sService 是接口，所以我们可以使用动态代理，获取动态代理对象</li><li>第三步：偷梁换柱，使用动态代理对象 proxyNotiMng 替换系统的 sService</li></ul><p>于是，我们可以写出如下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void hookNotificationManager(final Context context) throws Exception &#123;</span><br><span class="line">    NotificationManager notificationManager &#x3D; (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line"></span><br><span class="line">    Method getService &#x3D; NotificationManager.class.getDeclaredMethod(&quot;getService&quot;);</span><br><span class="line">    getService.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 sService</span><br><span class="line">    final Object sOriginService &#x3D; getService.invoke(notificationManager);</span><br><span class="line"></span><br><span class="line">    Class iNotiMngClz &#x3D; Class.forName(&quot;android.app.INotificationManager&quot;);</span><br><span class="line">    &#x2F;&#x2F; 第二步：得到我们的动态代理对象</span><br><span class="line">    Object proxyNotiMng &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;iNotiMngClz&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            Log.d(TAG, &quot;invoke: name&#x3D;&quot; + name);</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Toast.makeText(context.getApplicationContext(), &quot;检测到有人发通知了&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(sOriginService, args);</span><br><span class="line">            &#x2F;&#x2F; 拦截通知，什么也不做</span><br><span class="line">            &#x2F;&#x2F;                    return null;</span><br><span class="line">            &#x2F;&#x2F; 或者是根据通知的 Tag 和 ID 进行筛选</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 sService</span><br><span class="line">    Field sServiceField &#x3D; NotificationManager.class.getDeclaredField(&quot;sService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(notificationManager, proxyNotiMng);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Hook-使用进阶"><a href="#Hook-使用进阶" class="headerlink" title="Hook 使用进阶"></a>Hook 使用进阶</h2><h3 id="Hook-ClipboardManager"><a href="#Hook-ClipboardManager" class="headerlink" title="Hook ClipboardManager"></a>Hook ClipboardManager</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><p>从上面的 hook NotificationManager 例子中，我们可以得知 NotificationManager 中有一个静态变量 sService，这个变量是远端的 service。因此，我们尝试查找 ClipboardManager 中是不是也存在相同的类似静态变量。</p><p>查看它的源码发现它存在 mService 变量，该变量是在 ClipboardManager 构造函数中初始化的，而 ClipboardManager 的构造方法用 @hide 标记，表明该方法对调用者不可见。</p><p>而我们知道 ClipboardManager，NotificationManager 其实这些都是单例的，即系统只会创建一次。因此我们也可以认为<br>ClipboardManager 的 mService 是单例的。因此 mService 应该是可以考虑 hook 的一个点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ClipboardManager extends android.text.ClipboardManager &#123;</span><br><span class="line">    private final Context mContext;</span><br><span class="line">    private final IClipboard mService;</span><br><span class="line"></span><br><span class="line">    &#x2F;** &#123;@hide&#125; *&#x2F;</span><br><span class="line">    public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mService &#x3D; IClipboard.Stub.asInterface(</span><br><span class="line">                ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们再来一个看一下 ClipboardManager 的相关方法 setPrimaryClip ， getPrimaryClip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void setPrimaryClip(ClipData clip) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (clip !&#x3D; null) &#123;</span><br><span class="line">            clip.prepareToLeaveProcess(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.setPrimaryClip(clip, mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns the current primary clip on the clipboard.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ClipData getPrimaryClip() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return mService.getPrimaryClip(mContext.getOpPackageName());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这些方法最终都会调用到 mService 的相关方法。因此，ClipboardManager 的 mService 确实是一个可以 hook 的一个点。</p><p><strong>hook ClipboardManager.mService 的实现</strong></p><p>大概需要三个步骤</p><ul><li>第一步：得到 ClipboardManager 的 mService</li><li>第二步：初始化动态代理对象</li><li>第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static void hookClipboardService(final Context context) throws Exception &#123;</span><br><span class="line">    ClipboardManager clipboardManager &#x3D; (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line">    Field mServiceFiled &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    mServiceFiled.setAccessible(true);</span><br><span class="line">    &#x2F;&#x2F; 第一步：得到系统的 mService</span><br><span class="line">    final Object mService &#x3D; mServiceFiled.get(clipboardManager);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二步：初始化动态代理对象</span><br><span class="line">    Class aClass &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">    Object proxyInstance &#x3D; Proxy.newProxyInstance(context.getClass().getClassLoader(), new</span><br><span class="line">            Class[]&#123;aClass&#125;, new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            Log.d(TAG, &quot;invoke(). method:&quot; + method);</span><br><span class="line">            String name &#x3D; method.getName();</span><br><span class="line">            if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    Log.d(TAG, &quot;invoke: arg&#x3D;&quot; + arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;setPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Object arg &#x3D; args[0];</span><br><span class="line">                if (arg instanceof ClipData) &#123;</span><br><span class="line">                    ClipData clipData &#x3D; (ClipData) arg;</span><br><span class="line">                    int itemCount &#x3D; clipData.getItemCount();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; itemCount; i++) &#123;</span><br><span class="line">                        ClipData.Item item &#x3D; clipData.getItemAt(i);</span><br><span class="line">                        Log.i(TAG, &quot;invoke: item&#x3D;&quot; + item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人设置粘贴板内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; else if (&quot;getPrimaryClip&quot;.equals(name)) &#123;</span><br><span class="line">                Toast.makeText(context, &quot;检测到有人要获取粘贴板的内容&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 操作交由 sOriginService 处理，不拦截通知</span><br><span class="line">            return method.invoke(mService, args);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第三步：偷梁换柱，使用 proxyNotiMng 替换系统的 mService</span><br><span class="line">    Field sServiceField &#x3D; ClipboardManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">    sServiceField.setAccessible(true);</span><br><span class="line">    sServiceField.set(clipboardManager, proxyInstance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3MS5zaW5haW1nLmNuL213NjkwLzlmZTRhZmEwZ3kxZnR4ajVleWl6aWcyMGM3MG9wcTdyLmdpZg"></p><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>对 Android 源码有基本了解的人都知道，Android 中的各种 Manager 都是通过 ServiceManager 获取的。因此，我们可以通过 ServiceManager hook 所有系统 Manager，ClipboardManager 当然也不例外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns a reference to a service with the given name.</span><br><span class="line">     * </span><br><span class="line">     * @param name the name of the service to get</span><br><span class="line">     * @return a reference to the service, or &lt;code&gt;null&lt;&#x2F;code&gt; if the service doesn&#39;t exist</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老套路</p><ul><li>第一步：通过反射获取剪切板服务的远程Binder对象，这里我们可以通过 ServiceManager getService 方法获得</li><li>第二步：创建我们的动态代理对象，动态代理原来的Binder对象</li><li>第三步：偷梁换柱，把我们的动态代理对象设置进去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void hookClipboardService() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取剪切板服务的远程Binder对象</span><br><span class="line">    Class serviceManager &#x3D; Class.forName(&quot;android.os.ServiceManager&quot;);</span><br><span class="line">    Method getServiceMethod &#x3D; serviceManager.getMethod(&quot;getService&quot;, String.class);</span><br><span class="line">    IBinder remoteBinder &#x3D; (IBinder) getServiceMethod.invoke(null, Context.CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;新建一个我们需要的Binder，动态代理原来的Binder对象</span><br><span class="line">    IBinder hookBinder &#x3D; (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">            new Class[]&#123;IBinder.class&#125;, new ClipboardHookRemoteBinderHandler(remoteBinder));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通过反射获取ServiceManger存储Binder对象的缓存集合,把我们新建的代理Binder放进缓存</span><br><span class="line">    Field sCacheField &#x3D; serviceManager.getDeclaredField(&quot;sCache&quot;);</span><br><span class="line">    sCacheField.setAccessible(true);</span><br><span class="line">    Map&lt;String, IBinder&gt; sCache &#x3D; (Map&lt;String, IBinder&gt;) sCacheField.get(null);</span><br><span class="line">    sCache.put(Context.CLIPBOARD_SERVICE, hookBinder);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ClipboardHookRemoteBinderHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private IBinder remoteBinder;</span><br><span class="line">    private Class iInterface;</span><br><span class="line">    private Class stubClass;</span><br><span class="line"></span><br><span class="line">    public ClipboardHookRemoteBinderHandler(IBinder remoteBinder) &#123;</span><br><span class="line">        this.remoteBinder &#x3D; remoteBinder;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.iInterface &#x3D; Class.forName(&quot;android.content.IClipboard&quot;);</span><br><span class="line">            this.stubClass &#x3D; Class.forName(&quot;android.content.IClipboard$Stub&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Log.d(&quot;RemoteBinderHandler&quot;, method.getName() + &quot;() is invoked&quot;);</span><br><span class="line">        if (&quot;queryLocalInterface&quot;.equals(method.getName())) &#123;</span><br><span class="line">            &#x2F;&#x2F;这里不能拦截具体的服务的方法，因为这是一个远程的Binder，还没有转化为本地Binder对象</span><br><span class="line">            &#x2F;&#x2F;所以先拦截我们所知的queryLocalInterface方法，返回一个本地Binder对象的代理</span><br><span class="line">            return Proxy.newProxyInstance(remoteBinder.getClass().getClassLoader(),</span><br><span class="line">                    new Class[]&#123;this.iInterface&#125;,</span><br><span class="line">                    new ClipboardHookLocalBinderHandler(remoteBinder, stubClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return method.invoke(remoteBinder, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook-Activity"><a href="#Hook-Activity" class="headerlink" title="Hook Activity"></a>Hook Activity</h3><p>关于怎样 hook activity，以及怎样启动没有在 AndroidManifet 注册的 activity，可以查看我的这一篇博客。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gdutxiaoxu/article/details/81459910">Android Hook Activity 的几种姿势</a></p><p><strong>源码下载地址</strong>： <a target="_blank" rel="noopener" href="https://github.com/gdutxiaoxu/HookDemo">HookDemo</a></p><hr><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xWYe-uxgXTPuitYcLgXYNg">Android 启动优化（一） - 有向无环图</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ShfxD_Z7M_NuWYNodn-vqA">Android 启动优化（二） - 拓扑排序的原理以及解题思路</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YRUpf9jKEwIHV0A4FqltXg">Android 启动优化（三）- AnchorTask 开源了</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6RKco9JTm6ZrFyw99k9Rlg">Android 启动优化（四）- AnchorTask 是怎么实现的</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0MsJa0ZepWkPUs-ymnVb-w">Android 启动优化（五）- AnchorTask 1.0.0 版本正式发布了</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7_dQd2wGZYKWf9kHNlv2fg">Android 启动优化（六）- 深入理解布局优化</a></p><p>这几篇文章从 0 到 1，讲解 DAG 有向无环图是怎么实现的，以及在 Android 启动优化的应用。</p><p><strong>推荐理由：现在挺多文章一谈到启动优化，动不动就聊拓扑结构，这篇文章从数据结构到算法、到设计都给大家说清楚了，开源项目也有非常强的借鉴意义。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414231709248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dkdXR4aWFveHU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/images/wechat_channel.jpg"><span class="icon"><i class="fab fa-weixin"></i> </span><span class="label">WeChat</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/hook/" rel="tag"># hook</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2017/05/12/%E8%87%AA%E5%AE%9A%E4%B9%89-Behavior-%E4%BB%BF%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%8F%91%E7%8E%B0%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="prev" title="自定义-Behavior-仿新浪微博发现页的实现"><i class="fa fa-chevron-left"></i> 自定义-Behavior-仿新浪微博发现页的实现</a></div><div class="post-nav-item"><a href="/2019/01/11/Android%20lifecycle%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" rel="next" title="Android lifecycle 使用详解">Android lifecycle 使用详解 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:e}=CONFIG.comments;if(CONFIG.comments.storage&&(e=localStorage.getItem("comments_active")||e),e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Hook"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">Hook 分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81-Hook-%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.</span> <span class="nav-text">常见 Hook 框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="nav-number">1.4.</span> <span class="nav-text">Hook 必须掌握的知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hook-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">Hook 使用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E9%80%89%E6%8B%A9%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">Hook 选择的关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E4%B8%80-%E4%BD%BF%E7%94%A8-Hook-%E4%BF%AE%E6%94%B9-View-OnClickListener-%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">简单案例一: 使用 Hook 修改 View.OnClickListener 事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A-HooK-Notification"><span class="nav-number">2.3.</span> <span class="nav-text">简单案例二： HooK Notification</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hook-%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6"><span class="nav-number">3.</span> <span class="nav-text">Hook 使用进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-ClipboardManager"><span class="nav-number">3.1.</span> <span class="nav-text">Hook ClipboardManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">第一种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">第二种方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-Activity"><span class="nav-number">3.2.</span> <span class="nav-text">Hook Activity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="nav-number">4.</span> <span class="nav-text">推荐阅读</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">徐公</p><div class="site-description" itemprop="description">「Android学习+面试指南」助你升职加薪</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div><div></div><div class="wechat_OA"><br><span>公众号回复 <b>“黑马”</b> 两字，可以领取 Android 学习视频，回复 <b>“徐公666”</b>，可以获取简历模板，带你走进大厂</span><br><img src="https://gitee.com/gdutxiaoxu/blog-picture/raw/master/21/01/qrcode_for_gh_f0b7a2d93f70_430%20(2).jpg"></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">徐公</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">260k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">3:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script>!function(){function c(e){return e=encodeURI(e),document.getElementById(e).querySelector(".leancloud-visitors-count")}let{app_id:i,app_key:a,server_url:e}={enable:!0,app_id:"sybN87KmhJxd3H4Da6hVBgOf-gzGzoHsz",app_key:"7Ak1SzgvL37BJyjeMRDi6MVr",server_url:null,security:!1};function t(n){var r,t,e,o,l,s=(e,t,o)=>fetch(`${n}/1.1${t}`,{method:e,headers:{"X-LC-Id":i,"X-LC-Key":a,"Content-Type":"application/json"},body:JSON.stringify(o)});CONFIG.page.isPost?CONFIG.hostname===location.hostname&&(t=s,e=document.querySelector(".leancloud_visitors"),o=decodeURI(e.id),l=e.dataset.flagTitle,t("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:o}))).then(e=>e.json()).then(({results:e})=>{0<e.length?(e=e[0],c(o).innerText=e.time+1,t("put","/classes/Counter/"+e.objectId,{time:{__op:"Increment",amount:1}}).catch(e=>{console.error("Failed to save visitor count",e)})):t("post","/classes/Counter",{title:l,url:o,time:1}).then(e=>e.json()).then(()=>{c(o).innerText=1}).catch(e=>{console.error("Failed to create",e)})}).catch(e=>{console.error("LeanCloud Counter Error",e)})):1<=document.querySelectorAll(".post-title-link").length&&(s=s,r=[...document.querySelectorAll(".leancloud_visitors")].map(e=>decodeURI(e.id)),s("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:{$in:r}}))).then(e=>e.json()).then(({results:e})=>{for(let t of r){var o=e.find(e=>e.url===t);c(t).innerText=o?o.time:0}}).catch(e=>{console.error("LeanCloud Counter Error",e)}))}var o="-MdYXbMMI"!==i.slice(-9)?e:`https://${i.slice(0,8).toLowerCase()}.api.lncldglobal.com`;o?t(o):fetch("https://app-router.leancloud.cn/2/route?appId="+i).then(e=>e.json()).then(({api_server:e})=>{t("https://"+e)})}()</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="/js/local-search.js"></script></body></html>